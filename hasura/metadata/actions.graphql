type Mutation {
  acceptOrgInvite(
    profileId: String!
  ): AcceptOrgInviteOutput
}

type Query {
  canApplyPromoCode(
    input: CanApplyPromoCodeInput!
  ): CanApplyPromoCodeOutput!
}

type Mutation {
  cancelIndividualFromCourse(
    courseId: Int!
    profileId: uuid!
    reason: String!
    fee: Int!
  ): Boolean
}

type Mutation {
  cancelMyselfFromCourse(
    courseId: Int!
  ): Boolean
}

type Mutation {
  createOrder(
    input: CreateOrderInput!
  ): CreateOrderOutput
}

type Mutation {
  createStripeSubscription(
    priceId: String!
    customerId: String!
  ): createSubscriptionOutput
}

type Mutation {
  createUser(
    input: CreateAppUserInput!
  ): CreateUserOutput!
}

type Mutation {
  declineInvite(
    note: String
  ): DeclineInviteOutput
}

type Mutation {
  declineOrgInvite: DeclineOrgInviteOutput
}

type Query {
  eligibleTransferCourses(
    fromCourseId: Int!
  ): [TransferCourse!]!
}

type Query {
  fetchPlans: [PlanObject]
}

type Query {
  getCoursePricing(
    input: GetCoursePricingInput!
  ): GetCoursePricingOutput
}

type Query {
  getInvite: CourseInvite
}

type Query {
  getOrgInvite: OrgInvite
}

type Query {
  getTrainersLevels(
    input: GetTrainersLevelsInput!
  ): [TrainerLevels]
}

type Query {
  getXeroInvoicesForOrders(
    invoiceNumbers: [String!]!
  ): [XeroInvoice]!
}

type Mutation {
  go1LicensesChange(
    input: Go1LicensesChangeInput!
  ): Go1LicensesChangeOutput
}

type Query {
  initAuth: InitAuthOutput!
}

type Query {
  isUserSubscribedToMembership(
    customerId: String!
  ): isUserSubscribedToMembershipResponse
}

type Mutation {
  plansCreate(
    data: PlansCreateInput!
  ): PlansCreateResult
}

type Query {
  podcast(
    id: ID!
  ): PodcastPayload
}

type Query {
  podcasts(
    input: PodcastsInput
  ): PodcastsPayload
}

type Mutation {
  replaceParticipant(
    input: ReplaceParticipantInput!
  ): ReplaceParticipantOutput
}

type Query {
  searchTrainers(
    input: SearchTrainersInput!
  ): [SearchTrainer]
}

type Mutation {
  stripeCreatePaymentIntent(
    input: StripeCreatePaymentIntentInput!
  ): StripeCreatePaymentIntentOutput
}

type Mutation {
  transferParticipant(
    input: TransferInput!
  ): TransferParticipantOutput
}

type Mutation {
  updateAvatar(
    avatar: bytea!
  ): UpdateAvatarResponse
}

type Mutation {
  upsertZoomMeeting(
    input: UpsertZoomMeetingInput
  ): UpsertZoomMeetingPayload
}

type Mutation {
  verifyUser(
    inviteId: uuid!
  ): Boolean
}

type Mutation {
  xeroCallback(
    input: XeroCallbackInput!
  ): XeroCallbackOutput
}

type Query {
  xeroConnect: XeroConnectOutput
}

type Query {
  xeroContactSearch(
    input: XeroContactSearchInput!
  ): XeroContactSearchOutput
}

type Mutation {
  xeroDisconnect: XeroDisconnectOutput
}

type Query {
  xeroInvoicesStatus(
    input: XeroInvoicesStatusInput!
  ): XeroInvoicesStatusOutput
}

enum BillingInterval {
  day
  week
  month
  year
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
}

enum CourseLevel {
  LEVEL_1
  LEVEL_2
  ADVANCED
  BILD_ACT
  INTERMEDIATE_TRAINER
  ADVANCED_TRAINER
  BILD_ACT_TRAINER
}

enum SearchTrainerAvailability {
  UNAVAILABLE
  AVAILABLE
  PENDING
  EXPIRED
}

enum CourseTrainerType {
  LEADER
  ASSISTANT
  MODERATOR
}

enum Currency {
  GBP
}

enum OrderDirection {
  ASC
  DESC
}

enum XeroContactStatus {
  ACTIVE
  ARCHIVED
  GDPRREQUEST
}

enum CourseType {
  OPEN
  CLOSED
  INDIRECT
}

enum XeroInvoiceStatus {
  DRAFT
  SUBMITTED
  DELETED
  AUTHORISED
  PAID
  VOIDED
  UNKNOWN
  OVERDUE
}

enum Go1ChangeType {
  LICENSES_ADDED
  LICENSES_REMOVED
  LICENSE_REVOKED
  LICENSES_RELEASED
  LICENSE_ISSUED
  LICENSES_PURCHASED
}

enum PaymentMethod {
  CC
  INVOICE
}

enum ReplaceParticipantError {
  NO_PARTICIPANT
  INVALID_EMAIL
  GENERIC_ERROR
  NOT_AUTHORIZED
}

enum TransferFeeType {
  APPLY_TERMS
  CUSTOM_FEE
  FREE
}

enum TransferFeeTypeEnum {
  APPLY_TERMS
  CUSTOM_FEE
  FREE
}

input PlansCreateInput {
  name: String!
  currency: String!
  amount: Int!
  recurring_type: BillingInterval!
  recurring_count: Int!
  trial_type: BillingInterval!
  trial_count: Int!
}

input UpsertZoomMeetingInput {
  id: Float
  """ ISO 8601 date string, e.g. '2022-04-18T16:48:04.836Z' """ startTime: String
  """ Timezone string, e.g. Europe/London """ timezone: String
}

input GetTrainersLevelsInput {
  ids: [uuid!]!
  trainerType: CourseTrainerType!
  courseLevel: CourseLevel!
  courseStart: date!
  courseEnd: date!
}

input StripeCreatePaymentIntentInput {
  orderId: String!
}

input SearchTrainersInput {
  query: String
  trainerType: CourseTrainerType
  courseLevel: CourseLevel
  courseStart: date
  courseEnd: date
}

input Ordering {
  direction: OrderDirection
}

input PodcastsInput {
  term: String
  order: Ordering
  paging: Paging
}

input Paging {
  perPage: Int
  page: Int
}

input XeroCallbackInput {
  url: String!
}

input XeroContactSearchInput {
  searchTerm: String!
}

input CreateAppUserInput {
  firstName: String!
  lastName: String!
  password: String!
  phone: String
  dob: String
  acceptMarketing: Boolean!
  acceptTnc: Boolean!
}

input GetCoursePricingInput {
  courseId: Int!
}

input XeroInvoicesStatusInput {
  invoiceNumbers: [String]!
  invoiceNumberContains: String
  statuses: [XeroInvoiceStatus]
}

input Go1LicensesChangeInput {
  amount: Int!
  type: Go1ChangeType!
  payload: jsonb
  orgId: uuid!
}

input CanApplyPromoCodeInput {
  courseId: Int!
  code: String!
}

input CreateOrderInput {
  courseId: Int!
  quantity: Int!
  paymentMethod: PaymentMethod!
  billingAddress: String!
  billingGivenName: String!
  billingFamilyName: String!
  billingEmail: String!
  billingPhone: String!
  clientPurchaseOrder: String!
  registrants: [String!]!
  organizationId: String!
  promoCodes: [String!]!
}

input ReplaceParticipantInput {
  participantId: uuid!
  inviteeEmail: String!
}

input TransferFee {
  type: TransferFeeType!
  customFee: Int
}

input TransferInput {
  participantId: uuid!
  toCourseId: Int!
  fee: TransferFee!
}

type LinkProfileResult {
  status: Boolean!
}

type PlansCreateResult {
  id: String!
}

type PlanObject {
  id: String
  active: Boolean
  currency: String
  productName: String
  billingInterval: String
  unitAmount: Int
  name: String
}

type createSubscriptionOutput {
  subscriptionId: String!
  clientSecret: String!
}

type isUserSubscribedToMembershipResponse {
  isSubscribed: Boolean!
}

type DeclineInviteOutput {
  status: Boolean!
}

type DeclineOrgInviteOutput {
  id: uuid!
}

type AcceptOrgInviteOutput {
  id: uuid!
}

type Invite {
  status: InviteStatus
}

type CourseInvite {
  id: String!
  status: InviteStatus!
  courseId: String!
  courseName: String!
  description: String
  trainerName: String!
  startDate: String!
  endDate: String!
  venueName: String!
  venueAddress: Address
  venueCoordinates: String
}

type OrgInvite {
  id: String!
  orgName: String!
}

type Address {
  addressLineOne: String
  addressLineTwo: String
  city: String
  postCode: String
}

type UpsertZoomMeetingPayload {
  success: Boolean!
  meeting: ZoomMeeting
  userError: ZoomMeetingNotFoundError
}

type ZoomMeeting {
  id: Int!
  joinUrl: String!
}

type ZoomMeetingNotFoundError {
  id: String!
}

type TrainerLevels {
  profile_id: uuid!
  levels: [CourseLevel!]!
  availability: SearchTrainerAvailability!
}

type StripeCreatePaymentIntentOutput {
  clientSecret: String!
  amount: Float!
  currency: Currency!
}

type SearchTrainer {
  id: uuid!
  fullName: String!
  avatar: String
  trainer_role_types: [TrainerRoleType!]!
  levels: [CourseLevel!]!
  availability: SearchTrainerAvailability
}

type Podcast {
  id: String!
  name: String!
  description: String
  mediaUrl: String!
  author: String!
  publishedDate: String!
  thumbnail: String!
  episodeNumber: Int!
}

type PodcastsPayload {
  records: [Podcast!]!
  total: Int!
}

type PodcastPayload {
  podcast: Podcast
}

type XeroConnectOutput {
  consentUrl: String
}

type XeroCallbackOutput {
  status: Boolean!
}

type XeroContactSearchOutput {
  contacts: [XeroContact!]!
}

type XeroContact {
  contactID: ID!
  contactNumber: String
  contactStatus: XeroContactStatus!
  updatedDateUTC: date
  isCustomer: Boolean
  name: String!
  firstName: String
  lastName: String
  emailAddress: String
  phones: [XeroPhone]
  addresses: [XeroAddress]
}

type XeroPhone {
  phoneType: String
  phoneCountryCode: String
  phoneAreaCode: String
  phoneNumber: String
}

type XeroAddress {
  addressType: String
  addressLine1: String
  addressLine2: String
  city: String
  region: String
  postalCode: String
  country: String
}

type CreateUserOutput {
  cognitoId: String!
  profileId: String!
  email: String!
}

type InitAuthOutput {
  email: String!
  authChallenge: String!
}

type GetCoursePricingOutput {
  type: CourseType
  level: CourseLevel
  blended: Boolean
  reaccreditation: Boolean
  priceAmount: Float!
  priceCurrency: Currency!
  xeroCode: String!
}

type XeroInvoicesStatusOutput {
  invoices: [XeroInvoiceStatusKV]!
}

type XeroInvoiceStatusKV {
  invoiceNumber: String!
  status: XeroInvoiceStatus!
}

type XeroDisconnectOutput {
  connected: Boolean!
}

type XeroInvoice {
  invoiceID: ID!
  url: String
  type: String!
  date: String!
  total: Float!
  status: XeroInvoiceStatus!
  contact: XeroContact!
  dueDate: String
  subTotal: Float
  totalTax: Float
  lineItems: [XeroLineItem]!
  reference: String
  currencyCode: Currency!
  invoiceNumber: String
  totalDiscount: Float
  fullyPaidOnDate: String
  amountPaid: String
  amountDue: String
}

type XeroItem {
  id: String
  name: String!
  code: String!
}

type XeroLineItem {
  description: String
  quantity: Int!
  unitAmount: Float!
  itemCode: String!
  accountCode: String
  item: XeroItem
  lineItemId: String
  taxType: String!
  taxAmount: Float!
  lineAmount: Float!
  discountRate: Float!
  discountAmount: Float!
}

type Go1LicensesChangeOutput {
  success: Boolean!
}

type UpdateAvatarResponse {
  avatar: String!
}

type CanApplyPromoCodeOutput {
  result: Boolean!
}

type CreateOrderOutput {
  id: uuid!
}

type TransferCourse {
  id: Int!
  courseCode: String!
  startDate: String!
  endDate: String!
  virtualLink: String
  venue: String
  venueName: String
  venueCity: String
}

type TransferParticipantOutput {
  success: Boolean!
  error: String
}

type ReplaceParticipantOutput {
  success: Boolean!
  error: ReplaceParticipantError
}

type TrainerRoleTypeObj {
  id: String!
  name: String!
}

type TrainerRoleType {
  trainerRoleType: TrainerRoleTypeObj
}

