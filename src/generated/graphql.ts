export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  bytea: any;
  date: any;
  float8: any;
  json: any;
  jsonb: any;
  numeric: any;
  point: any;
  timestamp: any;
  timestamptz: any;
  uuid: any;
};

export type AcceptOrgInviteOutput = {
  __typename?: 'AcceptOrgInviteOutput';
  id: Scalars['uuid'];
};

/** A Field Group registered by ACF */
export type AcfFieldGroup = {
  /** The name of the ACF Field Group */
  fieldGroupName?: Maybe<Scalars['String']>;
};

export type Address = {
  __typename?: 'Address';
  addressLineOne?: Maybe<Scalars['String']>;
  addressLineTwo?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  postCode?: Maybe<Scalars['String']>;
};

/** Avatars are profile images for users. WordPress by default uses the Gravatar service to host and fetch avatars from. */
export type Avatar = {
  __typename?: 'Avatar';
  /** URL for the default image or a default type. Accepts &#039;404&#039; (return a 404 instead of a default image), &#039;retro&#039; (8bit), &#039;monsterid&#039; (monster), &#039;wavatar&#039; (cartoon face), &#039;indenticon&#039; (the &#039;quilt&#039;), &#039;mystery&#039;, &#039;mm&#039;, or &#039;mysteryman&#039; (The Oyster Man), &#039;blank&#039; (transparent GIF), or &#039;gravatar_default&#039; (the Gravatar logo). */
  default?: Maybe<Scalars['String']>;
  /** HTML attributes to insert in the IMG element. Is not sanitized. */
  extraAttr?: Maybe<Scalars['String']>;
  /** Whether to always show the default image, never the Gravatar. */
  forceDefault?: Maybe<Scalars['Boolean']>;
  /** Whether the avatar was successfully found. */
  foundAvatar?: Maybe<Scalars['Boolean']>;
  /** Height of the avatar image. */
  height?: Maybe<Scalars['Int']>;
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** What rating to display avatars up to. Accepts &#039;G&#039;, &#039;PG&#039;, &#039;R&#039;, &#039;X&#039;, and are judged in that order. */
  rating?: Maybe<Scalars['String']>;
  /** Type of url scheme to use. Typically HTTP vs. HTTPS. */
  scheme?: Maybe<Scalars['String']>;
  /** The size of the avatar in pixels. A value of 96 will match a 96px x 96px gravatar image. */
  size?: Maybe<Scalars['Int']>;
  /** URL for the gravatar image source. */
  url?: Maybe<Scalars['String']>;
  /** Width of the avatar image. */
  width?: Maybe<Scalars['Int']>;
};

/** What rating to display avatars up to. Accepts 'G', 'PG', 'R', 'X', and are judged in that order. Default is the value of the 'avatar_rating' option */
export enum AvatarRatingEnum {
  /** Indicates a G level avatar rating level. */
  G = 'G',
  /** Indicates a PG level avatar rating level. */
  Pg = 'PG',
  /** Indicates an R level avatar rating level. */
  R = 'R',
  /** Indicates an X level avatar rating level. */
  X = 'X'
}

export enum BillingInterval {
  Day = 'day',
  Month = 'month',
  Week = 'week',
  Year = 'year'
}

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Boolean']>;
  _gt?: InputMaybe<Scalars['Boolean']>;
  _gte?: InputMaybe<Scalars['Boolean']>;
  _in?: InputMaybe<Array<Scalars['Boolean']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Boolean']>;
  _lte?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Scalars['Boolean']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']>>;
};

export type CanApplyPromoCodeInput = {
  code: Scalars['String'];
  courseId: Scalars['Int'];
};

export type CanApplyPromoCodeOutput = {
  __typename?: 'CanApplyPromoCodeOutput';
  result?: Maybe<PromoCodeOutput>;
};

/** The category type */
export type Category = DatabaseIdentifier & HierarchicalTermNode & MenuItemLinkable & Node & TermNode & UniformResourceIdentifiable & {
  __typename?: 'Category';
  /** The ancestors of the node. Default ordered as lowest (closest to the child) to highest (closest to the root). */
  ancestors?: Maybe<CategoryToAncestorsCategoryConnection>;
  /** The id field matches the WP_Post-&gt;ID field. */
  categoryId?: Maybe<Scalars['Int']>;
  /** Connection between the category type and the category type */
  children?: Maybe<CategoryToCategoryConnection>;
  /** Connection between the category type and the ContentNode type */
  contentNodes?: Maybe<CategoryToContentNodeConnection>;
  /** The number of objects connected to the object */
  count?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** The description of the object */
  description?: Maybe<Scalars['String']>;
  /** Connection between the TermNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<TermNodeToEnqueuedScriptConnection>;
  /** Connection between the TermNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<TermNodeToEnqueuedStylesheetConnection>;
  /** The unique resource identifier path */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The link to the term */
  link?: Maybe<Scalars['String']>;
  /** The human friendly name of the object. */
  name?: Maybe<Scalars['String']>;
  /** Connection between the category type and the category type */
  parent?: Maybe<CategoryToParentCategoryConnectionEdge>;
  /** Database id of the parent node */
  parentDatabaseId?: Maybe<Scalars['Int']>;
  /** The globally unique identifier of the parent node. */
  parentId?: Maybe<Scalars['ID']>;
  /** Connection between the category type and the post type */
  posts?: Maybe<CategoryToPostConnection>;
  /** An alphanumeric identifier for the object unique to its type. */
  slug?: Maybe<Scalars['String']>;
  /** Connection between the category type and the Taxonomy type */
  taxonomy?: Maybe<CategoryToTaxonomyConnectionEdge>;
  /** The name of the taxonomy that the object is associated with */
  taxonomyName?: Maybe<Scalars['String']>;
  /** The ID of the term group that this term object belongs to */
  termGroupId?: Maybe<Scalars['Int']>;
  /** The taxonomy ID that the object is associated with */
  termTaxonomyId?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** The category type */
export type CategoryAncestorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The category type */
export type CategoryChildrenArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CategoryToCategoryConnectionWhereArgs>;
};


/** The category type */
export type CategoryContentNodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CategoryToContentNodeConnectionWhereArgs>;
};


/** The category type */
export type CategoryEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The category type */
export type CategoryEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The category type */
export type CategoryPostsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CategoryToPostConnectionWhereArgs>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum CategoryIdType {
  /** The Database ID for the node */
  DatabaseId = 'DATABASE_ID',
  /** The hashed Global ID */
  Id = 'ID',
  /** The name of the node */
  Name = 'NAME',
  /** Url friendly name of the node */
  Slug = 'SLUG',
  /** The URI for the node */
  Uri = 'URI'
}

/** Connection between the category type and the category type */
export type CategoryToAncestorsCategoryConnection = {
  __typename?: 'CategoryToAncestorsCategoryConnection';
  /** Edges for the CategoryToAncestorsCategoryConnection connection */
  edges?: Maybe<Array<Maybe<CategoryToAncestorsCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Category>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type CategoryToAncestorsCategoryConnectionEdge = {
  __typename?: 'CategoryToAncestorsCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Category>;
};

/** Connection between the category type and the category type */
export type CategoryToCategoryConnection = {
  __typename?: 'CategoryToCategoryConnection';
  /** Edges for the CategoryToCategoryConnection connection */
  edges?: Maybe<Array<Maybe<CategoryToCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Category>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type CategoryToCategoryConnectionEdge = {
  __typename?: 'CategoryToCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Category>;
};

/** Arguments for filtering the CategoryToCategoryConnection connection */
export type CategoryToCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the category type and the ContentNode type */
export type CategoryToContentNodeConnection = {
  __typename?: 'CategoryToContentNodeConnection';
  /** Edges for the CategoryToContentNodeConnection connection */
  edges?: Maybe<Array<Maybe<CategoryToContentNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type CategoryToContentNodeConnectionEdge = {
  __typename?: 'CategoryToContentNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentNode>;
};

/** Arguments for filtering the CategoryToContentNodeConnection connection */
export type CategoryToContentNodeConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfCategoryEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the category type and the category type */
export type CategoryToParentCategoryConnectionEdge = {
  __typename?: 'CategoryToParentCategoryConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Category>;
};

/** Connection between the category type and the post type */
export type CategoryToPostConnection = {
  __typename?: 'CategoryToPostConnection';
  /** Edges for the CategoryToPostConnection connection */
  edges?: Maybe<Array<Maybe<CategoryToPostConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Post>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type CategoryToPostConnectionEdge = {
  __typename?: 'CategoryToPostConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Post>;
};

/** Arguments for filtering the CategoryToPostConnection connection */
export type CategoryToPostConnectionWhereArgs = {
  /** The user that's connected as the author of the object. Use the userId for the author object. */
  author?: InputMaybe<Scalars['Int']>;
  /** Find objects connected to author(s) in the array of author's userIds */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Find objects connected to the author by the author's nicename */
  authorName?: InputMaybe<Scalars['String']>;
  /** Find objects NOT connected to author(s) in the array of author's userIds */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Category ID */
  categoryId?: InputMaybe<Scalars['Int']>;
  /** Array of category IDs, used to display objects from one category OR another */
  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Use Category Slug */
  categoryName?: InputMaybe<Scalars['String']>;
  /** Array of category IDs, used to display objects from one category OR another */
  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Tag Slug */
  tag?: InputMaybe<Scalars['String']>;
  /** Use Tag ID */
  tagId?: InputMaybe<Scalars['String']>;
  /** Array of tag IDs, used to display objects from one tag OR another */
  tagIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of tag IDs, used to display objects from one tag OR another */
  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of tag slugs, used to display objects from one tag OR another */
  tagSlugAnd?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of tag slugs, used to exclude objects in specified tags */
  tagSlugIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the category type and the Taxonomy type */
export type CategoryToTaxonomyConnectionEdge = {
  __typename?: 'CategoryToTaxonomyConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Taxonomy>;
};

/** A Comment object */
export type Comment = DatabaseIdentifier & Node & {
  __typename?: 'Comment';
  /** User agent used to post the comment. This field is equivalent to WP_Comment-&gt;comment_agent and the value matching the &quot;comment_agent&quot; column in SQL. */
  agent?: Maybe<Scalars['String']>;
  /** The approval status of the comment. This field is equivalent to WP_Comment-&gt;comment_approved and the value matching the &quot;comment_approved&quot; column in SQL. */
  approved?: Maybe<Scalars['Boolean']>;
  /** The author of the comment */
  author?: Maybe<CommentToCommenterConnectionEdge>;
  /** IP address for the author. This field is equivalent to WP_Comment-&gt;comment_author_IP and the value matching the &quot;comment_author_IP&quot; column in SQL. */
  authorIp?: Maybe<Scalars['String']>;
  /** ID for the comment, unique among comments. */
  commentId?: Maybe<Scalars['Int']>;
  /** Connection between the Comment type and the ContentNode type */
  commentedOn?: Maybe<CommentToContentNodeConnectionEdge>;
  /** Content of the comment. This field is equivalent to WP_Comment-&gt;comment_content and the value matching the &quot;comment_content&quot; column in SQL. */
  content?: Maybe<Scalars['String']>;
  /** The unique identifier stored in the database */
  databaseId: Scalars['Int'];
  /** Date the comment was posted in local time. This field is equivalent to WP_Comment-&gt;date and the value matching the &quot;date&quot; column in SQL. */
  date?: Maybe<Scalars['String']>;
  /** Date the comment was posted in GMT. This field is equivalent to WP_Comment-&gt;date_gmt and the value matching the &quot;date_gmt&quot; column in SQL. */
  dateGmt?: Maybe<Scalars['String']>;
  /** The globally unique identifier for the comment object */
  id: Scalars['ID'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Karma value for the comment. This field is equivalent to WP_Comment-&gt;comment_karma and the value matching the &quot;comment_karma&quot; column in SQL. */
  karma?: Maybe<Scalars['Int']>;
  /** Connection between the Comment type and the Comment type */
  parent?: Maybe<CommentToParentCommentConnectionEdge>;
  /** The database id of the parent comment node or null if it is the root comment */
  parentDatabaseId?: Maybe<Scalars['Int']>;
  /** The globally unique identifier of the parent comment node. */
  parentId?: Maybe<Scalars['ID']>;
  /** Connection between the Comment type and the Comment type */
  replies?: Maybe<CommentToCommentConnection>;
  /** Type of comment. This field is equivalent to WP_Comment-&gt;comment_type and the value matching the &quot;comment_type&quot; column in SQL. */
  type?: Maybe<Scalars['String']>;
};


/** A Comment object */
export type CommentContentArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};


/** A Comment object */
export type CommentParentArgs = {
  where?: InputMaybe<CommentToParentCommentConnectionWhereArgs>;
};


/** A Comment object */
export type CommentRepliesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CommentToCommentConnectionWhereArgs>;
};

/** A Comment Author object */
export type CommentAuthor = Commenter & Node & {
  __typename?: 'CommentAuthor';
  /** Avatar object for user. The avatar object can be retrieved in different sizes by specifying the size argument. */
  avatar?: Maybe<Avatar>;
  /** Identifies the primary key from the database. */
  databaseId: Scalars['Int'];
  /** The email for the comment author */
  email?: Maybe<Scalars['String']>;
  /** The globally unique identifier for the comment author object */
  id: Scalars['ID'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** The name for the comment author. */
  name?: Maybe<Scalars['String']>;
  /** The url the comment author. */
  url?: Maybe<Scalars['String']>;
};


/** A Comment Author object */
export type CommentAuthorAvatarArgs = {
  forceDefault?: InputMaybe<Scalars['Boolean']>;
  rating?: InputMaybe<AvatarRatingEnum>;
  size?: InputMaybe<Scalars['Int']>;
};

/** The Type of Identifier used to fetch a single comment node. Default is "ID". To be used along with the "id" field. */
export enum CommentNodeIdTypeEnum {
  /** Identify a resource by the Database ID. */
  DatabaseId = 'DATABASE_ID',
  /** Identify a resource by the (hashed) Global ID. */
  Id = 'ID'
}

/** Connection between the Comment type and the Comment type */
export type CommentToCommentConnection = {
  __typename?: 'CommentToCommentConnection';
  /** Edges for the CommentToCommentConnection connection */
  edges?: Maybe<Array<Maybe<CommentToCommentConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Comment>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type CommentToCommentConnectionEdge = {
  __typename?: 'CommentToCommentConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Comment>;
};

/** Arguments for filtering the CommentToCommentConnection connection */
export type CommentToCommentConnectionWhereArgs = {
  /** Comment author email address. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** Array of author IDs to include comments for. */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to exclude comments for. */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Comment author URL. */
  authorUrl?: InputMaybe<Scalars['String']>;
  /** Array of comment IDs to include. */
  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */
  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Include comments of a given type. */
  commentType?: InputMaybe<Scalars['String']>;
  /** Include comments from a given array of comment types. */
  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Exclude comments from a given array of comment types. */
  commentTypeNotIn?: InputMaybe<Scalars['String']>;
  /** Content object author ID to limit results by. */
  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to retrieve comments for. */
  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs *not* to retrieve comments for. */
  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Limit results to those affiliated with a given content object ID. */
  contentId?: InputMaybe<Scalars['ID']>;
  /** Array of content object IDs to include affiliated comments for. */
  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of content object IDs to exclude affiliated comments for. */
  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Content object name to retrieve affiliated comments for. */
  contentName?: InputMaybe<Scalars['String']>;
  /** Content Object parent ID to retrieve affiliated comments for. */
  contentParent?: InputMaybe<Scalars['Int']>;
  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */
  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Karma score to retrieve matching comments for. */
  karma?: InputMaybe<Scalars['Int']>;
  /** The cardinality of the order of the connection */
  order?: InputMaybe<OrderEnum>;
  /** Field to order the comments by. */
  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;
  /** Parent ID of comment to retrieve children of. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Array of parent IDs of comments to retrieve children for. */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of parent IDs of comments *not* to retrieve children for. */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Search term(s) to retrieve matching comments for. */
  search?: InputMaybe<Scalars['String']>;
  /** Comment status to limit results by. */
  status?: InputMaybe<Scalars['String']>;
  /** Include comments for a specific user ID. */
  userId?: InputMaybe<Scalars['ID']>;
};

/** Connection between the Comment type and the Commenter type */
export type CommentToCommenterConnectionEdge = {
  __typename?: 'CommentToCommenterConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Commenter>;
};

/** Connection between the Comment type and the ContentNode type */
export type CommentToContentNodeConnectionEdge = {
  __typename?: 'CommentToContentNodeConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<ContentNode>;
};

/** Connection between the Comment type and the Comment type */
export type CommentToParentCommentConnectionEdge = {
  __typename?: 'CommentToParentCommentConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Comment>;
};

/** Arguments for filtering the CommentToParentCommentConnection connection */
export type CommentToParentCommentConnectionWhereArgs = {
  /** Comment author email address. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** Array of author IDs to include comments for. */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to exclude comments for. */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Comment author URL. */
  authorUrl?: InputMaybe<Scalars['String']>;
  /** Array of comment IDs to include. */
  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */
  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Include comments of a given type. */
  commentType?: InputMaybe<Scalars['String']>;
  /** Include comments from a given array of comment types. */
  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Exclude comments from a given array of comment types. */
  commentTypeNotIn?: InputMaybe<Scalars['String']>;
  /** Content object author ID to limit results by. */
  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to retrieve comments for. */
  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs *not* to retrieve comments for. */
  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Limit results to those affiliated with a given content object ID. */
  contentId?: InputMaybe<Scalars['ID']>;
  /** Array of content object IDs to include affiliated comments for. */
  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of content object IDs to exclude affiliated comments for. */
  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Content object name to retrieve affiliated comments for. */
  contentName?: InputMaybe<Scalars['String']>;
  /** Content Object parent ID to retrieve affiliated comments for. */
  contentParent?: InputMaybe<Scalars['Int']>;
  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */
  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Karma score to retrieve matching comments for. */
  karma?: InputMaybe<Scalars['Int']>;
  /** The cardinality of the order of the connection */
  order?: InputMaybe<OrderEnum>;
  /** Field to order the comments by. */
  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;
  /** Parent ID of comment to retrieve children of. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Array of parent IDs of comments to retrieve children for. */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of parent IDs of comments *not* to retrieve children for. */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Search term(s) to retrieve matching comments for. */
  search?: InputMaybe<Scalars['String']>;
  /** Comment status to limit results by. */
  status?: InputMaybe<Scalars['String']>;
  /** Include comments for a specific user ID. */
  userId?: InputMaybe<Scalars['ID']>;
};

/** The author of a comment */
export type Commenter = {
  /** Avatar object for user. The avatar object can be retrieved in different sizes by specifying the size argument. */
  avatar?: Maybe<Avatar>;
  /** Identifies the primary key from the database. */
  databaseId: Scalars['Int'];
  /** The email address of the author of a comment. */
  email?: Maybe<Scalars['String']>;
  /** The globally unique identifier for the comment author. */
  id: Scalars['ID'];
  /** Whether the author information is considered restricted. (not fully public) */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** The name of the author of a comment. */
  name?: Maybe<Scalars['String']>;
  /** The url of the author of a comment. */
  url?: Maybe<Scalars['String']>;
};

/** Options for ordering the connection */
export enum CommentsConnectionOrderbyEnum {
  /** Order by browser user agent of the commenter. */
  CommentAgent = 'COMMENT_AGENT',
  /** Order by true/false approval of the comment. */
  CommentApproved = 'COMMENT_APPROVED',
  /** Order by name of the comment author. */
  CommentAuthor = 'COMMENT_AUTHOR',
  /** Order by e-mail of the comment author. */
  CommentAuthorEmail = 'COMMENT_AUTHOR_EMAIL',
  /** Order by IP address of the comment author. */
  CommentAuthorIp = 'COMMENT_AUTHOR_IP',
  /** Order by URL address of the comment author. */
  CommentAuthorUrl = 'COMMENT_AUTHOR_URL',
  /** Order by the comment contents. */
  CommentContent = 'COMMENT_CONTENT',
  /** Order by date/time timestamp of the comment. */
  CommentDate = 'COMMENT_DATE',
  /** Order by GMT timezone date/time timestamp of the comment. */
  CommentDateGmt = 'COMMENT_DATE_GMT',
  /** Order by the globally unique identifier for the comment object */
  CommentId = 'COMMENT_ID',
  /** Order by the array list of comment IDs listed in the where clause. */
  CommentIn = 'COMMENT_IN',
  /** Order by the comment karma score. */
  CommentKarma = 'COMMENT_KARMA',
  /** Order by the comment parent ID. */
  CommentParent = 'COMMENT_PARENT',
  /** Order by the post object ID. */
  CommentPostId = 'COMMENT_POST_ID',
  /** Order by the the type of comment, such as 'comment', 'pingback', or 'trackback'. */
  CommentType = 'COMMENT_TYPE',
  /** Order by the user ID. */
  UserId = 'USER_ID'
}

export enum ConfirmCreditCardPaymentError {
  GenericError = 'GENERIC_ERROR',
  OrderNotFound = 'ORDER_NOT_FOUND',
  PaymentNotSucceeded = 'PAYMENT_NOT_SUCCEEDED'
}

export type ConfirmCreditCardPaymentOutput = {
  __typename?: 'ConfirmCreditCardPaymentOutput';
  confirmed: Scalars['Boolean'];
  error?: Maybe<ConfirmCreditCardPaymentError>;
};

/** Nodes used to manage content */
export type ContentNode = {
  /** Connection between the ContentNode type and the ContentType type */
  contentType?: Maybe<ContentNodeToContentTypeConnectionEdge>;
  /** The name of the Content Type the node belongs to */
  contentTypeName: Scalars['String'];
  /** The ID of the node in the database. */
  databaseId: Scalars['Int'];
  /** Post publishing date. */
  date?: Maybe<Scalars['String']>;
  /** The publishing date set in GMT. */
  dateGmt?: Maybe<Scalars['String']>;
  /** The desired slug of the post */
  desiredSlug?: Maybe<Scalars['String']>;
  /** If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds */
  editingLockedBy?: Maybe<ContentNodeToEditLockConnectionEdge>;
  /** The RSS enclosure for the object */
  enclosure?: Maybe<Scalars['String']>;
  /** Connection between the ContentNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<ContentNodeToEnqueuedScriptConnection>;
  /** Connection between the ContentNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<ContentNodeToEnqueuedStylesheetConnection>;
  /** The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table. */
  guid?: Maybe<Scalars['String']>;
  /** The unique resource identifier path */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is a node in the preview state */
  isPreview?: Maybe<Scalars['Boolean']>;
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The user that most recently edited the node */
  lastEditedBy?: Maybe<ContentNodeToEditLastConnectionEdge>;
  /** The permalink of the post */
  link?: Maybe<Scalars['String']>;
  /** The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time. */
  modified?: Maybe<Scalars['String']>;
  /** The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT. */
  modifiedGmt?: Maybe<Scalars['String']>;
  /** The database id of the preview node */
  previewRevisionDatabaseId?: Maybe<Scalars['Int']>;
  /** Whether the object is a node in the preview state */
  previewRevisionId?: Maybe<Scalars['ID']>;
  /** The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table. */
  slug?: Maybe<Scalars['String']>;
  /** The current status of the object */
  status?: Maybe<Scalars['String']>;
  /** The template assigned to a node of content */
  template?: Maybe<ContentTemplate>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** Nodes used to manage content */
export type ContentNodeEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Nodes used to manage content */
export type ContentNodeEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum ContentNodeIdTypeEnum {
  /** Identify a resource by the Database ID. */
  DatabaseId = 'DATABASE_ID',
  /** Identify a resource by the (hashed) Global ID. */
  Id = 'ID',
  /** Identify a resource by the URI. */
  Uri = 'URI'
}

/** Connection between the ContentNode type and the ContentType type */
export type ContentNodeToContentTypeConnectionEdge = {
  __typename?: 'ContentNodeToContentTypeConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<ContentType>;
};

/** Connection between the ContentNode type and the User type */
export type ContentNodeToEditLastConnectionEdge = {
  __typename?: 'ContentNodeToEditLastConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<User>;
};

/** Connection between the ContentNode type and the User type */
export type ContentNodeToEditLockConnectionEdge = {
  __typename?: 'ContentNodeToEditLockConnectionEdge';
  /** The timestamp for when the node was last edited */
  lockTimestamp?: Maybe<Scalars['String']>;
  /** The node of the connection, without the edges */
  node?: Maybe<User>;
};

/** Connection between the ContentNode type and the EnqueuedScript type */
export type ContentNodeToEnqueuedScriptConnection = {
  __typename?: 'ContentNodeToEnqueuedScriptConnection';
  /** Edges for the ContentNodeToEnqueuedScriptConnection connection */
  edges?: Maybe<Array<Maybe<ContentNodeToEnqueuedScriptConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<EnqueuedScript>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ContentNodeToEnqueuedScriptConnectionEdge = {
  __typename?: 'ContentNodeToEnqueuedScriptConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<EnqueuedScript>;
};

/** Connection between the ContentNode type and the EnqueuedStylesheet type */
export type ContentNodeToEnqueuedStylesheetConnection = {
  __typename?: 'ContentNodeToEnqueuedStylesheetConnection';
  /** Edges for the ContentNodeToEnqueuedStylesheetConnection connection */
  edges?: Maybe<Array<Maybe<ContentNodeToEnqueuedStylesheetConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<EnqueuedStylesheet>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ContentNodeToEnqueuedStylesheetConnectionEdge = {
  __typename?: 'ContentNodeToEnqueuedStylesheetConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<EnqueuedStylesheet>;
};

/** A union of Content Node Types that support revisions */
export type ContentRevisionUnion = Page | Post;

/** The template assigned to a node of content */
export type ContentTemplate = {
  /** The name of the template */
  templateName?: Maybe<Scalars['String']>;
};

/** An Post Type object */
export type ContentType = Node & UniformResourceIdentifiable & {
  __typename?: 'ContentType';
  /** Whether this content type should can be exported. */
  canExport?: Maybe<Scalars['Boolean']>;
  /** Connection between the ContentType type and the Taxonomy type */
  connectedTaxonomies?: Maybe<ContentTypeToTaxonomyConnection>;
  /** Connection between the ContentType type and the ContentNode type */
  contentNodes?: Maybe<ContentTypeToContentNodeConnection>;
  /** Whether content of this type should be deleted when the author of it is deleted from the system. */
  deleteWithUser?: Maybe<Scalars['Boolean']>;
  /** Description of the content type. */
  description?: Maybe<Scalars['String']>;
  /** Whether to exclude nodes of this content type from front end search results. */
  excludeFromSearch?: Maybe<Scalars['Boolean']>;
  /** The plural name of the content type within the GraphQL Schema. */
  graphqlPluralName?: Maybe<Scalars['String']>;
  /** The singular name of the content type within the GraphQL Schema. */
  graphqlSingleName?: Maybe<Scalars['String']>;
  /** Whether this content type should have archives. Content archives are generated by type and by date. */
  hasArchive?: Maybe<Scalars['Boolean']>;
  /** Whether the content type is hierarchical, for example pages. */
  hierarchical?: Maybe<Scalars['Boolean']>;
  /** The globally unique identifier of the post-type object. */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether this page is set to the static front page. */
  isFrontPage: Scalars['Boolean'];
  /** Whether this page is set to the blog posts page. */
  isPostsPage: Scalars['Boolean'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** Display name of the content type. */
  label?: Maybe<Scalars['String']>;
  /** Details about the content type labels. */
  labels?: Maybe<PostTypeLabelDetails>;
  /** The name of the icon file to display as a menu icon. */
  menuIcon?: Maybe<Scalars['String']>;
  /** The position of this post type in the menu. Only applies if show_in_menu is true. */
  menuPosition?: Maybe<Scalars['Int']>;
  /** The internal name of the post type. This should not be used for display purposes. */
  name?: Maybe<Scalars['String']>;
  /** Whether a content type is intended for use publicly either via the admin interface or by front-end users. While the default settings of exclude_from_search, publicly_queryable, show_ui, and show_in_nav_menus are inherited from public, each does not rely on this relationship and controls a very specific intention. */
  public?: Maybe<Scalars['Boolean']>;
  /** Whether queries can be performed on the front end for the content type as part of parse_request(). */
  publiclyQueryable?: Maybe<Scalars['Boolean']>;
  /** Name of content type to display in REST API &quot;wp/v2&quot; namespace. */
  restBase?: Maybe<Scalars['String']>;
  /** The REST Controller class assigned to handling this content type. */
  restControllerClass?: Maybe<Scalars['String']>;
  /** Makes this content type available via the admin bar. */
  showInAdminBar?: Maybe<Scalars['Boolean']>;
  /** Whether to add the content type to the GraphQL Schema. */
  showInGraphql?: Maybe<Scalars['Boolean']>;
  /** Where to show the content type in the admin menu. To work, $show_ui must be true. If true, the post type is shown in its own top level menu. If false, no menu is shown. If a string of an existing top level menu (eg. &quot;tools.php&quot; or &quot;edit.php?post_type=page&quot;), the post type will be placed as a sub-menu of that. */
  showInMenu?: Maybe<Scalars['Boolean']>;
  /** Makes this content type available for selection in navigation menus. */
  showInNavMenus?: Maybe<Scalars['Boolean']>;
  /** Whether the content type is associated with a route under the the REST API &quot;wp/v2&quot; namespace. */
  showInRest?: Maybe<Scalars['Boolean']>;
  /** Whether to generate and allow a UI for managing this content type in the admin. */
  showUi?: Maybe<Scalars['Boolean']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** An Post Type object */
export type ContentTypeConnectedTaxonomiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** An Post Type object */
export type ContentTypeContentNodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ContentTypeToContentNodeConnectionWhereArgs>;
};

/** Allowed Content Types */
export enum ContentTypeEnum {
  /** The Type of Content object */
  Attachment = 'ATTACHMENT',
  /** The Type of Content object */
  Ebooks = 'EBOOKS',
  /** The Type of Content object */
  Page = 'PAGE',
  /** The Type of Content object */
  Post = 'POST',
  /** The Type of Content object */
  ResearchSummary = 'RESEARCH_SUMMARY',
  /** The Type of Content object */
  Resource = 'RESOURCE',
  /** The Type of Content object */
  VideoSeries = 'VIDEO_SERIES',
  /** The Type of Content object */
  Webinar = 'WEBINAR'
}

/** The Type of Identifier used to fetch a single Content Type node. To be used along with the "id" field. Default is "ID". */
export enum ContentTypeIdTypeEnum {
  /** The globally unique ID */
  Id = 'ID',
  /** The name of the content type. */
  Name = 'NAME'
}

/** Connection between the ContentType type and the ContentNode type */
export type ContentTypeToContentNodeConnection = {
  __typename?: 'ContentTypeToContentNodeConnection';
  /** Edges for the ContentTypeToContentNodeConnection connection */
  edges?: Maybe<Array<Maybe<ContentTypeToContentNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ContentTypeToContentNodeConnectionEdge = {
  __typename?: 'ContentTypeToContentNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentNode>;
};

/** Arguments for filtering the ContentTypeToContentNodeConnection connection */
export type ContentTypeToContentNodeConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the ContentType type and the Taxonomy type */
export type ContentTypeToTaxonomyConnection = {
  __typename?: 'ContentTypeToTaxonomyConnection';
  /** Edges for the ContentTypeToTaxonomyConnection connection */
  edges?: Maybe<Array<Maybe<ContentTypeToTaxonomyConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Taxonomy>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ContentTypeToTaxonomyConnectionEdge = {
  __typename?: 'ContentTypeToTaxonomyConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Taxonomy>;
};

/** Allowed Content Types of the Category taxonomy. */
export enum ContentTypesOfCategoryEnum {
  /** The Type of Content object */
  Post = 'POST'
}

/** Allowed Content Types of the EbooksCategory taxonomy. */
export enum ContentTypesOfEbooksCategoryEnum {
  /** The Type of Content object */
  Ebooks = 'EBOOKS'
}

/** Allowed Content Types of the PostFormat taxonomy. */
export enum ContentTypesOfPostFormatEnum {
  /** The Type of Content object */
  Post = 'POST'
}

/** Allowed Content Types of the ResearchSummariesCategory taxonomy. */
export enum ContentTypesOfResearchSummariesCategoryEnum {
  /** The Type of Content object */
  ResearchSummary = 'RESEARCH_SUMMARY'
}

/** Allowed Content Types of the ResourceCategory taxonomy. */
export enum ContentTypesOfResourceCategoryEnum {
  /** The Type of Content object */
  Resource = 'RESOURCE'
}

/** Allowed Content Types of the Tag taxonomy. */
export enum ContentTypesOfTagEnum {
  /** The Type of Content object */
  Post = 'POST'
}

/** Allowed Content Types of the VideoSeriesCategory taxonomy. */
export enum ContentTypesOfVideoSeriesCategoryEnum {
  /** The Type of Content object */
  VideoSeries = 'VIDEO_SERIES'
}

/** Allowed Content Types of the WebinarsCategory taxonomy. */
export enum ContentTypesOfWebinarsCategoryEnum {
  /** The Type of Content object */
  Webinar = 'WEBINAR'
}

export type CourseCertificateLevel = {
  __typename?: 'CourseCertificateLevel';
  courseLevel: CourseLevel;
  expiryDate: Scalars['date'];
};

export type CourseInvite = {
  __typename?: 'CourseInvite';
  courseId: Scalars['String'];
  courseName: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  endDate: Scalars['String'];
  id: Scalars['String'];
  startDate: Scalars['String'];
  status: InviteStatus;
  trainerName: Scalars['String'];
  venueAddress?: Maybe<Address>;
  venueCoordinates?: Maybe<Scalars['String']>;
  venueName: Scalars['String'];
};

export enum CourseLevel {
  Advanced = 'ADVANCED',
  AdvancedTrainer = 'ADVANCED_TRAINER',
  BildAct = 'BILD_ACT',
  BildActTrainer = 'BILD_ACT_TRAINER',
  IntermediateTrainer = 'INTERMEDIATE_TRAINER',
  Level_1 = 'LEVEL_1',
  Level_2 = 'LEVEL_2'
}

export enum CourseTrainerType {
  Assistant = 'ASSISTANT',
  Leader = 'LEADER',
  Moderator = 'MODERATOR'
}

export enum CourseType {
  Closed = 'CLOSED',
  Indirect = 'INDIRECT',
  Open = 'OPEN'
}

export type CreateAppUserInput = {
  acceptMarketing: Scalars['Boolean'];
  acceptTnc: Scalars['Boolean'];
  dob?: InputMaybe<Scalars['String']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  password: Scalars['String'];
  phone?: InputMaybe<Scalars['String']>;
};

/** Input for the createCategory mutation */
export type CreateCategoryInput = {
  /** The slug that the category will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the category object */
  description?: InputMaybe<Scalars['String']>;
  /** The name of the category object to mutate */
  name: Scalars['String'];
  /** The ID of the category that should be set as the parent */
  parentId?: InputMaybe<Scalars['ID']>;
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the createCategory mutation */
export type CreateCategoryPayload = {
  __typename?: 'CreateCategoryPayload';
  /** The created category */
  category?: Maybe<Category>;
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Input for the createComment mutation */
export type CreateCommentInput = {
  /** The approval status of the comment. */
  approved?: InputMaybe<Scalars['String']>;
  /** The name of the comment's author. */
  author?: InputMaybe<Scalars['String']>;
  /** The email of the comment's author. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** The url of the comment's author. */
  authorUrl?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The database ID of the post object the comment belongs to. */
  commentOn?: InputMaybe<Scalars['Int']>;
  /** Content of the comment. */
  content?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day ( e.g. 01/31/2017 ) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** Parent comment ID of current comment. */
  parent?: InputMaybe<Scalars['ID']>;
  /** Type of comment. */
  type?: InputMaybe<Scalars['String']>;
};

/** The payload for the createComment mutation */
export type CreateCommentPayload = {
  __typename?: 'CreateCommentPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The comment that was created */
  comment?: Maybe<Comment>;
  /** Whether the mutation succeeded. If the comment is not approved, the server will not return the comment to a non authenticated user, but a success message can be returned if the create succeeded, and the client can optimistically add the comment to the client cache */
  success?: Maybe<Scalars['Boolean']>;
};

/** Input for the createEbook mutation */
export type CreateEbookInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** Set connections between the Ebook and EbooksCategories */
  ebooksCategories?: InputMaybe<EbookEbooksCategoriesInput>;
  /** The excerpt of the object */
  excerpt?: InputMaybe<Scalars['String']>;
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** The payload for the createEbook mutation */
export type CreateEbookPayload = {
  __typename?: 'CreateEbookPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  ebook?: Maybe<Ebook>;
};

/** Input for the createEbooksCategory mutation */
export type CreateEbooksCategoryInput = {
  /** The slug that the ebooks_category will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the ebooks_category object */
  description?: InputMaybe<Scalars['String']>;
  /** The name of the ebooks_category object to mutate */
  name: Scalars['String'];
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the createEbooksCategory mutation */
export type CreateEbooksCategoryPayload = {
  __typename?: 'CreateEbooksCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created ebooks_category */
  ebooksCategory?: Maybe<EbooksCategory>;
};

/** Input for the createMediaItem mutation */
export type CreateMediaItemInput = {
  /** Alternative text to display when mediaItem is not displayed */
  altText?: InputMaybe<Scalars['String']>;
  /** The userId to assign as the author of the mediaItem */
  authorId?: InputMaybe<Scalars['ID']>;
  /** The caption for the mediaItem */
  caption?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The comment status for the mediaItem */
  commentStatus?: InputMaybe<Scalars['String']>;
  /** The date of the mediaItem */
  date?: InputMaybe<Scalars['String']>;
  /** The date (in GMT zone) of the mediaItem */
  dateGmt?: InputMaybe<Scalars['String']>;
  /** Description of the mediaItem */
  description?: InputMaybe<Scalars['String']>;
  /** The file name of the mediaItem */
  filePath?: InputMaybe<Scalars['String']>;
  /** The file type of the mediaItem */
  fileType?: InputMaybe<MimeTypeEnum>;
  /** The ID of the parent object */
  parentId?: InputMaybe<Scalars['ID']>;
  /** The ping status for the mediaItem */
  pingStatus?: InputMaybe<Scalars['String']>;
  /** The slug of the mediaItem */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the mediaItem */
  status?: InputMaybe<MediaItemStatusEnum>;
  /** The title of the mediaItem */
  title?: InputMaybe<Scalars['String']>;
};

/** The payload for the createMediaItem mutation */
export type CreateMediaItemPayload = {
  __typename?: 'CreateMediaItemPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The MediaItem object mutation type. */
  mediaItem?: Maybe<MediaItem>;
};

export type CreateOrderInput = {
  billingAddress: Scalars['String'];
  billingEmail: Scalars['String'];
  billingFamilyName: Scalars['String'];
  billingGivenName: Scalars['String'];
  billingPhone: Scalars['String'];
  clientPurchaseOrder: Scalars['String'];
  courseId: Scalars['Int'];
  organizationId: Scalars['String'];
  paymentMethod: PaymentMethod;
  promoCodes: Array<Scalars['String']>;
  quantity: Scalars['Int'];
  registrants: Array<Scalars['String']>;
};

export type CreateOrderOutput = {
  __typename?: 'CreateOrderOutput';
  id: Scalars['uuid'];
};

/** Input for the createPage mutation */
export type CreatePageInput = {
  /** The userId to assign as the author of the object */
  authorId?: InputMaybe<Scalars['ID']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The comment status for the object */
  commentStatus?: InputMaybe<Scalars['String']>;
  /** The content of the object */
  content?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The ID of the parent object */
  parentId?: InputMaybe<Scalars['ID']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** The payload for the createPage mutation */
export type CreatePagePayload = {
  __typename?: 'CreatePagePayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  page?: Maybe<Page>;
};

/** Input for the createPostFormat mutation */
export type CreatePostFormatInput = {
  /** The slug that the post_format will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the post_format object */
  description?: InputMaybe<Scalars['String']>;
  /** The name of the post_format object to mutate */
  name: Scalars['String'];
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the createPostFormat mutation */
export type CreatePostFormatPayload = {
  __typename?: 'CreatePostFormatPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created post_format */
  postFormat?: Maybe<PostFormat>;
};

/** Input for the createPost mutation */
export type CreatePostInput = {
  /** The userId to assign as the author of the object */
  authorId?: InputMaybe<Scalars['ID']>;
  /** Set connections between the post and categories */
  categories?: InputMaybe<PostCategoriesInput>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The comment status for the object */
  commentStatus?: InputMaybe<Scalars['String']>;
  /** The content of the object */
  content?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** The excerpt of the object */
  excerpt?: InputMaybe<Scalars['String']>;
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** The ping status for the object */
  pingStatus?: InputMaybe<Scalars['String']>;
  /** URLs that have been pinged. */
  pinged?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Set connections between the post and postFormats */
  postFormats?: InputMaybe<PostPostFormatsInput>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** Set connections between the post and tags */
  tags?: InputMaybe<PostTagsInput>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
  /** URLs queued to be pinged. */
  toPing?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

/** The payload for the createPost mutation */
export type CreatePostPayload = {
  __typename?: 'CreatePostPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  post?: Maybe<Post>;
};

/** Input for the createResearchSummariesCategory mutation */
export type CreateResearchSummariesCategoryInput = {
  /** The slug that the research_summaries_category will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the research_summaries_category object */
  description?: InputMaybe<Scalars['String']>;
  /** The name of the research_summaries_category object to mutate */
  name: Scalars['String'];
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the createResearchSummariesCategory mutation */
export type CreateResearchSummariesCategoryPayload = {
  __typename?: 'CreateResearchSummariesCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created research_summaries_category */
  researchSummariesCategory?: Maybe<ResearchSummariesCategory>;
};

/** Input for the createResearchSummary mutation */
export type CreateResearchSummaryInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** The excerpt of the object */
  excerpt?: InputMaybe<Scalars['String']>;
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** Set connections between the ResearchSummary and ResearchSummariesCategories */
  researchSummariesCategories?: InputMaybe<ResearchSummaryResearchSummariesCategoriesInput>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** The payload for the createResearchSummary mutation */
export type CreateResearchSummaryPayload = {
  __typename?: 'CreateResearchSummaryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  researchSummary?: Maybe<ResearchSummary>;
};

/** Input for the createResourceCategory mutation */
export type CreateResourceCategoryInput = {
  /** The slug that the resource_category will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the resource_category object */
  description?: InputMaybe<Scalars['String']>;
  /** The name of the resource_category object to mutate */
  name: Scalars['String'];
  /** The ID of the resource_category that should be set as the parent */
  parentId?: InputMaybe<Scalars['ID']>;
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the createResourceCategory mutation */
export type CreateResourceCategoryPayload = {
  __typename?: 'CreateResourceCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created resource_category */
  resourceCategory?: Maybe<ResourceCategory>;
};

/** Input for the createResource mutation */
export type CreateResourceInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** Set connections between the Resource and ResourceCategories */
  resourceCategories?: InputMaybe<ResourceResourceCategoriesInput>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** The payload for the createResource mutation */
export type CreateResourcePayload = {
  __typename?: 'CreateResourcePayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  resource?: Maybe<Resource>;
};

/** Input for the createTag mutation */
export type CreateTagInput = {
  /** The slug that the post_tag will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the post_tag object */
  description?: InputMaybe<Scalars['String']>;
  /** The name of the post_tag object to mutate */
  name: Scalars['String'];
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the createTag mutation */
export type CreateTagPayload = {
  __typename?: 'CreateTagPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created post_tag */
  tag?: Maybe<Tag>;
};

/** Input for the createUser mutation */
export type CreateUserInput = {
  /** User's AOL IM account. */
  aim?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A string containing content about the user. */
  description?: InputMaybe<Scalars['String']>;
  /** A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user). */
  displayName?: InputMaybe<Scalars['String']>;
  /** A string containing the user's email address. */
  email?: InputMaybe<Scalars['String']>;
  /** 	The user's first name. */
  firstName?: InputMaybe<Scalars['String']>;
  /** User's Jabber account. */
  jabber?: InputMaybe<Scalars['String']>;
  /** The user's last name. */
  lastName?: InputMaybe<Scalars['String']>;
  /** User's locale. */
  locale?: InputMaybe<Scalars['String']>;
  /** A string that contains a URL-friendly name for the user. The default is the user's username. */
  nicename?: InputMaybe<Scalars['String']>;
  /** The user's nickname, defaults to the user's username. */
  nickname?: InputMaybe<Scalars['String']>;
  /** A string that contains the plain text password for the user. */
  password?: InputMaybe<Scalars['String']>;
  /** The date the user registered. Format is Y-m-d H:i:s. */
  registered?: InputMaybe<Scalars['String']>;
  /** A string for whether to enable the rich editor or not. False if not empty. */
  richEditing?: InputMaybe<Scalars['String']>;
  /** An array of roles to be assigned to the user. */
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** A string that contains the user's username for logging in. */
  username: Scalars['String'];
  /** A string containing the user's URL for the user's web site. */
  websiteUrl?: InputMaybe<Scalars['String']>;
  /** User's Yahoo IM account. */
  yim?: InputMaybe<Scalars['String']>;
};

export type CreateUserOutput = {
  __typename?: 'CreateUserOutput';
  cognitoId: Scalars['String'];
  email: Scalars['String'];
  profileId: Scalars['String'];
};

/** The payload for the createUser mutation */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The User object mutation type. */
  user?: Maybe<User>;
};

/** Input for the createVideoSeriesCategory mutation */
export type CreateVideoSeriesCategoryInput = {
  /** The slug that the video_series_category will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the video_series_category object */
  description?: InputMaybe<Scalars['String']>;
  /** The name of the video_series_category object to mutate */
  name: Scalars['String'];
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the createVideoSeriesCategory mutation */
export type CreateVideoSeriesCategoryPayload = {
  __typename?: 'CreateVideoSeriesCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created video_series_category */
  videoSeriesCategory?: Maybe<VideoSeriesCategory>;
};

/** Input for the createVideoSeriesItem mutation */
export type CreateVideoSeriesItemInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** The excerpt of the object */
  excerpt?: InputMaybe<Scalars['String']>;
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
  /** Set connections between the VideoSeriesItem and VideoSeriesCategories */
  videoSeriesCategories?: InputMaybe<VideoSeriesItemVideoSeriesCategoriesInput>;
};

/** The payload for the createVideoSeriesItem mutation */
export type CreateVideoSeriesItemPayload = {
  __typename?: 'CreateVideoSeriesItemPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  videoSeriesItem?: Maybe<VideoSeriesItem>;
};

/** Input for the createWebinar mutation */
export type CreateWebinarInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** The excerpt of the object */
  excerpt?: InputMaybe<Scalars['String']>;
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
  /** Set connections between the Webinar and WebinarsCategories */
  webinarsCategories?: InputMaybe<WebinarWebinarsCategoriesInput>;
};

/** The payload for the createWebinar mutation */
export type CreateWebinarPayload = {
  __typename?: 'CreateWebinarPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  webinar?: Maybe<Webinar>;
};

/** Input for the createWebinarsCategory mutation */
export type CreateWebinarsCategoryInput = {
  /** The slug that the webinars_category will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the webinars_category object */
  description?: InputMaybe<Scalars['String']>;
  /** The name of the webinars_category object to mutate */
  name: Scalars['String'];
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the createWebinarsCategory mutation */
export type CreateWebinarsCategoryPayload = {
  __typename?: 'CreateWebinarsCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created webinars_category */
  webinarsCategory?: Maybe<WebinarsCategory>;
};

export enum Currency {
  Gbp = 'GBP'
}

/** Object that can be identified with a Database ID */
export type DatabaseIdentifier = {
  /** The unique identifier stored in the database */
  databaseId: Scalars['Int'];
};

/** Date values */
export type DateInput = {
  /** Day of the month (from 1 to 31) */
  day?: InputMaybe<Scalars['Int']>;
  /** Month number (from 1 to 12) */
  month?: InputMaybe<Scalars['Int']>;
  /** 4 digit year (e.g. 2017) */
  year?: InputMaybe<Scalars['Int']>;
};

/** Filter the connection based on input */
export type DateQueryInput = {
  /** Nodes should be returned after this date */
  after?: InputMaybe<DateInput>;
  /** Nodes should be returned before this date */
  before?: InputMaybe<DateInput>;
  /** Column to query against */
  column?: InputMaybe<PostObjectsConnectionDateColumnEnum>;
  /** For after/before, whether exact value should be matched or not */
  compare?: InputMaybe<Scalars['String']>;
  /** Day of the month (from 1 to 31) */
  day?: InputMaybe<Scalars['Int']>;
  /** Hour (from 0 to 23) */
  hour?: InputMaybe<Scalars['Int']>;
  /** For after/before, whether exact value should be matched or not */
  inclusive?: InputMaybe<Scalars['Boolean']>;
  /** Minute (from 0 to 59) */
  minute?: InputMaybe<Scalars['Int']>;
  /** Month number (from 1 to 12) */
  month?: InputMaybe<Scalars['Int']>;
  /** OR or AND, how the sub-arrays should be compared */
  relation?: InputMaybe<RelationEnum>;
  /** Second (0 to 59) */
  second?: InputMaybe<Scalars['Int']>;
  /** Week of the year (from 0 to 53) */
  week?: InputMaybe<Scalars['Int']>;
  /** 4 digit year (e.g. 2017) */
  year?: InputMaybe<Scalars['Int']>;
};

export type DeclineInviteOutput = {
  __typename?: 'DeclineInviteOutput';
  status: Scalars['Boolean'];
};

export type DeclineOrgInviteOutput = {
  __typename?: 'DeclineOrgInviteOutput';
  id: Scalars['uuid'];
};

/** The template assigned to the node */
export type DefaultTemplate = ContentTemplate & {
  __typename?: 'DefaultTemplate';
  /** The name of the template */
  templateName?: Maybe<Scalars['String']>;
};

/** Input for the deleteCategory mutation */
export type DeleteCategoryInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the category to delete */
  id: Scalars['ID'];
};

/** The payload for the deleteCategory mutation */
export type DeleteCategoryPayload = {
  __typename?: 'DeleteCategoryPayload';
  /** The deteted term object */
  category?: Maybe<Category>;
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
};

/** Input for the deleteComment mutation */
export type DeleteCommentInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the comment should be force deleted instead of being moved to the trash */
  forceDelete?: InputMaybe<Scalars['Boolean']>;
  /** The deleted comment ID */
  id: Scalars['ID'];
};

/** The payload for the deleteComment mutation */
export type DeleteCommentPayload = {
  __typename?: 'DeleteCommentPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The deleted comment object */
  comment?: Maybe<Comment>;
  /** The deleted comment ID */
  deletedId?: Maybe<Scalars['ID']>;
};

/** Input for the deleteEbook mutation */
export type DeleteEbookInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the object should be force deleted instead of being moved to the trash */
  forceDelete?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the Ebook to delete */
  id: Scalars['ID'];
};

/** The payload for the deleteEbook mutation */
export type DeleteEbookPayload = {
  __typename?: 'DeleteEbookPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The object before it was deleted */
  ebook?: Maybe<Ebook>;
};

/** Input for the deleteEbooksCategory mutation */
export type DeleteEbooksCategoryInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the EbooksCategory to delete */
  id: Scalars['ID'];
};

/** The payload for the deleteEbooksCategory mutation */
export type DeleteEbooksCategoryPayload = {
  __typename?: 'DeleteEbooksCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The deteted term object */
  ebooksCategory?: Maybe<EbooksCategory>;
};

/** Input for the deleteMediaItem mutation */
export type DeleteMediaItemInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the mediaItem should be force deleted instead of being moved to the trash */
  forceDelete?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the mediaItem to delete */
  id: Scalars['ID'];
};

/** The payload for the deleteMediaItem mutation */
export type DeleteMediaItemPayload = {
  __typename?: 'DeleteMediaItemPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted mediaItem */
  deletedId?: Maybe<Scalars['ID']>;
  /** The mediaItem before it was deleted */
  mediaItem?: Maybe<MediaItem>;
};

/** Input for the deletePage mutation */
export type DeletePageInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the object should be force deleted instead of being moved to the trash */
  forceDelete?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the page to delete */
  id: Scalars['ID'];
};

/** The payload for the deletePage mutation */
export type DeletePagePayload = {
  __typename?: 'DeletePagePayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The object before it was deleted */
  page?: Maybe<Page>;
};

/** Input for the deletePostFormat mutation */
export type DeletePostFormatInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the postFormat to delete */
  id: Scalars['ID'];
};

/** The payload for the deletePostFormat mutation */
export type DeletePostFormatPayload = {
  __typename?: 'DeletePostFormatPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The deteted term object */
  postFormat?: Maybe<PostFormat>;
};

/** Input for the deletePost mutation */
export type DeletePostInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the object should be force deleted instead of being moved to the trash */
  forceDelete?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the post to delete */
  id: Scalars['ID'];
};

/** The payload for the deletePost mutation */
export type DeletePostPayload = {
  __typename?: 'DeletePostPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The object before it was deleted */
  post?: Maybe<Post>;
};

/** Input for the deleteResearchSummariesCategory mutation */
export type DeleteResearchSummariesCategoryInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the ResearchSummariesCategory to delete */
  id: Scalars['ID'];
};

/** The payload for the deleteResearchSummariesCategory mutation */
export type DeleteResearchSummariesCategoryPayload = {
  __typename?: 'DeleteResearchSummariesCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The deteted term object */
  researchSummariesCategory?: Maybe<ResearchSummariesCategory>;
};

/** Input for the deleteResearchSummary mutation */
export type DeleteResearchSummaryInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the object should be force deleted instead of being moved to the trash */
  forceDelete?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the ResearchSummary to delete */
  id: Scalars['ID'];
};

/** The payload for the deleteResearchSummary mutation */
export type DeleteResearchSummaryPayload = {
  __typename?: 'DeleteResearchSummaryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The object before it was deleted */
  researchSummary?: Maybe<ResearchSummary>;
};

/** Input for the deleteResourceCategory mutation */
export type DeleteResourceCategoryInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the ResourceCategory to delete */
  id: Scalars['ID'];
};

/** The payload for the deleteResourceCategory mutation */
export type DeleteResourceCategoryPayload = {
  __typename?: 'DeleteResourceCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The deteted term object */
  resourceCategory?: Maybe<ResourceCategory>;
};

/** Input for the deleteResource mutation */
export type DeleteResourceInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the object should be force deleted instead of being moved to the trash */
  forceDelete?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the Resource to delete */
  id: Scalars['ID'];
};

/** The payload for the deleteResource mutation */
export type DeleteResourcePayload = {
  __typename?: 'DeleteResourcePayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The object before it was deleted */
  resource?: Maybe<Resource>;
};

/** Input for the deleteTag mutation */
export type DeleteTagInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the tag to delete */
  id: Scalars['ID'];
};

/** The payload for the deleteTag mutation */
export type DeleteTagPayload = {
  __typename?: 'DeleteTagPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The deteted term object */
  tag?: Maybe<Tag>;
};

/** Input for the deleteUser mutation */
export type DeleteUserInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the user you want to delete */
  id: Scalars['ID'];
  /** Reassign posts and links to new User ID. */
  reassignId?: InputMaybe<Scalars['ID']>;
};

/** The payload for the deleteUser mutation */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the user that you just deleted */
  deletedId?: Maybe<Scalars['ID']>;
  /** The deleted user object */
  user?: Maybe<User>;
};

/** Input for the deleteVideoSeriesCategory mutation */
export type DeleteVideoSeriesCategoryInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the VideoSeriesCategory to delete */
  id: Scalars['ID'];
};

/** The payload for the deleteVideoSeriesCategory mutation */
export type DeleteVideoSeriesCategoryPayload = {
  __typename?: 'DeleteVideoSeriesCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The deteted term object */
  videoSeriesCategory?: Maybe<VideoSeriesCategory>;
};

/** Input for the deleteVideoSeriesItem mutation */
export type DeleteVideoSeriesItemInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the object should be force deleted instead of being moved to the trash */
  forceDelete?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the VideoSeriesItem to delete */
  id: Scalars['ID'];
};

/** The payload for the deleteVideoSeriesItem mutation */
export type DeleteVideoSeriesItemPayload = {
  __typename?: 'DeleteVideoSeriesItemPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The object before it was deleted */
  videoSeriesItem?: Maybe<VideoSeriesItem>;
};

/** Input for the deleteWebinar mutation */
export type DeleteWebinarInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Whether the object should be force deleted instead of being moved to the trash */
  forceDelete?: InputMaybe<Scalars['Boolean']>;
  /** The ID of the Webinar to delete */
  id: Scalars['ID'];
};

/** The payload for the deleteWebinar mutation */
export type DeleteWebinarPayload = {
  __typename?: 'DeleteWebinarPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The object before it was deleted */
  webinar?: Maybe<Webinar>;
};

/** Input for the deleteWebinarsCategory mutation */
export type DeleteWebinarsCategoryInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the WebinarsCategory to delete */
  id: Scalars['ID'];
};

/** The payload for the deleteWebinarsCategory mutation */
export type DeleteWebinarsCategoryPayload = {
  __typename?: 'DeleteWebinarsCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The ID of the deleted object */
  deletedId?: Maybe<Scalars['ID']>;
  /** The deteted term object */
  webinarsCategory?: Maybe<WebinarsCategory>;
};

/** The discussion setting type */
export type DiscussionSettings = {
  __typename?: 'DiscussionSettings';
  /** Allow people to submit comments on new posts. */
  defaultCommentStatus?: Maybe<Scalars['String']>;
  /** Allow link notifications from other blogs (pingbacks and trackbacks) on new articles. */
  defaultPingStatus?: Maybe<Scalars['String']>;
};

/** The Ebook type */
export type Ebook = ContentNode & DatabaseIdentifier & MenuItemLinkable & Node & NodeWithExcerpt & NodeWithFeaturedImage & NodeWithTemplate & NodeWithTitle & UniformResourceIdentifiable & {
  __typename?: 'Ebook';
  /** Connection between the ContentNode type and the ContentType type */
  contentType?: Maybe<ContentNodeToContentTypeConnectionEdge>;
  /** The name of the Content Type the node belongs to */
  contentTypeName: Scalars['String'];
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** Post publishing date. */
  date?: Maybe<Scalars['String']>;
  /** The publishing date set in GMT. */
  dateGmt?: Maybe<Scalars['String']>;
  /** The desired slug of the post */
  desiredSlug?: Maybe<Scalars['String']>;
  /** Added to the GraphQL Schema because the ACF Field Group &quot;Downloads&quot; was set to Show in GraphQL. */
  downloads?: Maybe<Ebook_Downloads>;
  /** The id field matches the WP_Post-&gt;ID field. */
  ebookId: Scalars['Int'];
  /** Connection between the Ebook type and the EbooksCategory type */
  ebooksCategories?: Maybe<EbookToEbooksCategoryConnection>;
  /** If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds */
  editingLockedBy?: Maybe<ContentNodeToEditLockConnectionEdge>;
  /** The RSS enclosure for the object */
  enclosure?: Maybe<Scalars['String']>;
  /** Connection between the ContentNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<ContentNodeToEnqueuedScriptConnection>;
  /** Connection between the ContentNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<ContentNodeToEnqueuedStylesheetConnection>;
  /** The excerpt of the post. */
  excerpt?: Maybe<Scalars['String']>;
  /** Connection between the NodeWithFeaturedImage type and the MediaItem type */
  featuredImage?: Maybe<NodeWithFeaturedImageToMediaItemConnectionEdge>;
  /** The database identifier for the featured image node assigned to the content node */
  featuredImageDatabaseId?: Maybe<Scalars['Int']>;
  /** Globally unique ID of the featured image assigned to the node */
  featuredImageId?: Maybe<Scalars['ID']>;
  /** The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table. */
  guid?: Maybe<Scalars['String']>;
  /** The globally unique identifier of the ebooks object. */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is a node in the preview state */
  isPreview?: Maybe<Scalars['Boolean']>;
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The user that most recently edited the node */
  lastEditedBy?: Maybe<ContentNodeToEditLastConnectionEdge>;
  /** The permalink of the post */
  link?: Maybe<Scalars['String']>;
  /** The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time. */
  modified?: Maybe<Scalars['String']>;
  /** The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT. */
  modifiedGmt?: Maybe<Scalars['String']>;
  /** Connection between the Ebook type and the Ebook type */
  preview?: Maybe<EbookToPreviewConnectionEdge>;
  /** The database id of the preview node */
  previewRevisionDatabaseId?: Maybe<Scalars['Int']>;
  /** Whether the object is a node in the preview state */
  previewRevisionId?: Maybe<Scalars['ID']>;
  /** The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table. */
  slug?: Maybe<Scalars['String']>;
  /** The current status of the object */
  status?: Maybe<Scalars['String']>;
  /** The template assigned to a node of content */
  template?: Maybe<ContentTemplate>;
  /** Connection between the Ebook type and the TermNode type */
  terms?: Maybe<EbookToTermNodeConnection>;
  /** The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made. */
  title?: Maybe<Scalars['String']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** The Ebook type */
export type EbookEbooksCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EbookToEbooksCategoryConnectionWhereArgs>;
};


/** The Ebook type */
export type EbookEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The Ebook type */
export type EbookEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The Ebook type */
export type EbookExcerptArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};


/** The Ebook type */
export type EbookTermsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EbookToTermNodeConnectionWhereArgs>;
};


/** The Ebook type */
export type EbookTitleArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};

/** Set relationships between the Ebook to EbooksCategories */
export type EbookEbooksCategoriesInput = {
  /** If true, this will append the EbooksCategory to existing related EbooksCategories. If false, this will replace existing relationships. Default true. */
  append?: InputMaybe<Scalars['Boolean']>;
  /** The input list of items to set. */
  nodes?: InputMaybe<Array<InputMaybe<EbookEbooksCategoriesNodeInput>>>;
};

/** List of EbooksCategories to connect the Ebook to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */
export type EbookEbooksCategoriesNodeInput = {
  /** The description of the EbooksCategory. This field is used to set a description of the EbooksCategory if a new one is created during the mutation. */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the EbooksCategory. If present, this will be used to connect to the Ebook. If no existing EbooksCategory exists with this ID, no connection will be made. */
  id?: InputMaybe<Scalars['ID']>;
  /** The name of the EbooksCategory. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */
  name?: InputMaybe<Scalars['String']>;
  /** The slug of the EbooksCategory. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum EbookIdType {
  /** Identify a resource by the Database ID. */
  DatabaseId = 'DATABASE_ID',
  /** Identify a resource by the (hashed) Global ID. */
  Id = 'ID',
  /** Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier. */
  Slug = 'SLUG',
  /** Identify a resource by the URI. */
  Uri = 'URI'
}

/** Connection between the Ebook type and the EbooksCategory type */
export type EbookToEbooksCategoryConnection = {
  __typename?: 'EbookToEbooksCategoryConnection';
  /** Edges for the EbookToEbooksCategoryConnection connection */
  edges?: Maybe<Array<Maybe<EbookToEbooksCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<EbooksCategory>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type EbookToEbooksCategoryConnectionEdge = {
  __typename?: 'EbookToEbooksCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<EbooksCategory>;
};

/** Arguments for filtering the EbookToEbooksCategoryConnection connection */
export type EbookToEbooksCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the Ebook type and the Ebook type */
export type EbookToPreviewConnectionEdge = {
  __typename?: 'EbookToPreviewConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Ebook>;
};

/** Connection between the Ebook type and the TermNode type */
export type EbookToTermNodeConnection = {
  __typename?: 'EbookToTermNodeConnection';
  /** Edges for the EbookToTermNodeConnection connection */
  edges?: Maybe<Array<Maybe<EbookToTermNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<TermNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type EbookToTermNodeConnectionEdge = {
  __typename?: 'EbookToTermNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<TermNode>;
};

/** Arguments for filtering the EbookToTermNodeConnection connection */
export type EbookToTermNodeConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** The Taxonomy to filter terms by */
  taxonomies?: InputMaybe<Array<InputMaybe<TaxonomyEnum>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Field Group */
export type Ebook_Downloads = AcfFieldGroup & {
  __typename?: 'Ebook_Downloads';
  /** The name of the ACF Field Group */
  fieldGroupName?: Maybe<Scalars['String']>;
  file?: Maybe<MediaItem>;
};

/** The EbooksCategory type */
export type EbooksCategory = DatabaseIdentifier & MenuItemLinkable & Node & TermNode & UniformResourceIdentifiable & {
  __typename?: 'EbooksCategory';
  /** Connection between the EbooksCategory type and the ContentNode type */
  contentNodes?: Maybe<EbooksCategoryToContentNodeConnection>;
  /** The number of objects connected to the object */
  count?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** The description of the object */
  description?: Maybe<Scalars['String']>;
  /** Connection between the EbooksCategory type and the Ebook type */
  ebooks?: Maybe<EbooksCategoryToEbookConnection>;
  /** The id field matches the WP_Post-&gt;ID field. */
  ebooksCategoryId?: Maybe<Scalars['Int']>;
  /** Connection between the TermNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<TermNodeToEnqueuedScriptConnection>;
  /** Connection between the TermNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<TermNodeToEnqueuedStylesheetConnection>;
  /** The unique resource identifier path */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The link to the term */
  link?: Maybe<Scalars['String']>;
  /** The human friendly name of the object. */
  name?: Maybe<Scalars['String']>;
  /** An alphanumeric identifier for the object unique to its type. */
  slug?: Maybe<Scalars['String']>;
  /** Connection between the EbooksCategory type and the Taxonomy type */
  taxonomy?: Maybe<EbooksCategoryToTaxonomyConnectionEdge>;
  /** The name of the taxonomy that the object is associated with */
  taxonomyName?: Maybe<Scalars['String']>;
  /** The ID of the term group that this term object belongs to */
  termGroupId?: Maybe<Scalars['Int']>;
  /** The taxonomy ID that the object is associated with */
  termTaxonomyId?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** The EbooksCategory type */
export type EbooksCategoryContentNodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EbooksCategoryToContentNodeConnectionWhereArgs>;
};


/** The EbooksCategory type */
export type EbooksCategoryEbooksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EbooksCategoryToEbookConnectionWhereArgs>;
};


/** The EbooksCategory type */
export type EbooksCategoryEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The EbooksCategory type */
export type EbooksCategoryEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum EbooksCategoryIdType {
  /** The Database ID for the node */
  DatabaseId = 'DATABASE_ID',
  /** The hashed Global ID */
  Id = 'ID',
  /** The name of the node */
  Name = 'NAME',
  /** Url friendly name of the node */
  Slug = 'SLUG',
  /** The URI for the node */
  Uri = 'URI'
}

/** Connection between the EbooksCategory type and the ContentNode type */
export type EbooksCategoryToContentNodeConnection = {
  __typename?: 'EbooksCategoryToContentNodeConnection';
  /** Edges for the EbooksCategoryToContentNodeConnection connection */
  edges?: Maybe<Array<Maybe<EbooksCategoryToContentNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type EbooksCategoryToContentNodeConnectionEdge = {
  __typename?: 'EbooksCategoryToContentNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentNode>;
};

/** Arguments for filtering the EbooksCategoryToContentNodeConnection connection */
export type EbooksCategoryToContentNodeConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfEbooksCategoryEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the EbooksCategory type and the Ebook type */
export type EbooksCategoryToEbookConnection = {
  __typename?: 'EbooksCategoryToEbookConnection';
  /** Edges for the EbooksCategoryToEbookConnection connection */
  edges?: Maybe<Array<Maybe<EbooksCategoryToEbookConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Ebook>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type EbooksCategoryToEbookConnectionEdge = {
  __typename?: 'EbooksCategoryToEbookConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Ebook>;
};

/** Arguments for filtering the EbooksCategoryToEbookConnection connection */
export type EbooksCategoryToEbookConnectionWhereArgs = {
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the EbooksCategory type and the Taxonomy type */
export type EbooksCategoryToTaxonomyConnectionEdge = {
  __typename?: 'EbooksCategoryToTaxonomyConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Taxonomy>;
};

/** Asset enqueued by the CMS */
export type EnqueuedAsset = {
  /** @todo */
  args?: Maybe<Scalars['Boolean']>;
  /** Dependencies needed to use this asset */
  dependencies?: Maybe<Array<Maybe<EnqueuedScript>>>;
  /** Extra information needed for the script */
  extra?: Maybe<Scalars['String']>;
  /** The handle of the enqueued asset */
  handle?: Maybe<Scalars['String']>;
  /** The ID of the enqueued asset */
  id: Scalars['ID'];
  /** The source of the asset */
  src?: Maybe<Scalars['String']>;
  /** The version of the enqueued asset */
  version?: Maybe<Scalars['String']>;
};

/** Script enqueued by the CMS */
export type EnqueuedScript = EnqueuedAsset & Node & {
  __typename?: 'EnqueuedScript';
  /** @todo */
  args?: Maybe<Scalars['Boolean']>;
  /** Dependencies needed to use this asset */
  dependencies?: Maybe<Array<Maybe<EnqueuedScript>>>;
  /** Extra information needed for the script */
  extra?: Maybe<Scalars['String']>;
  /** The handle of the enqueued asset */
  handle?: Maybe<Scalars['String']>;
  /** The ID of the enqueued asset */
  id: Scalars['ID'];
  /** The source of the asset */
  src?: Maybe<Scalars['String']>;
  /** The version of the enqueued asset */
  version?: Maybe<Scalars['String']>;
};

/** Stylesheet enqueued by the CMS */
export type EnqueuedStylesheet = EnqueuedAsset & Node & {
  __typename?: 'EnqueuedStylesheet';
  /** @todo */
  args?: Maybe<Scalars['Boolean']>;
  /** Dependencies needed to use this asset */
  dependencies?: Maybe<Array<Maybe<EnqueuedScript>>>;
  /** Extra information needed for the script */
  extra?: Maybe<Scalars['String']>;
  /** The handle of the enqueued asset */
  handle?: Maybe<Scalars['String']>;
  /** The ID of the enqueued asset */
  id: Scalars['ID'];
  /** The source of the asset */
  src?: Maybe<Scalars['String']>;
  /** The version of the enqueued asset */
  version?: Maybe<Scalars['String']>;
};

/** The general setting type */
export type GeneralSettings = {
  __typename?: 'GeneralSettings';
  /** A date format for all date strings. */
  dateFormat?: Maybe<Scalars['String']>;
  /** Site tagline. */
  description?: Maybe<Scalars['String']>;
  /** This address is used for admin purposes, like new user notification. */
  email?: Maybe<Scalars['String']>;
  /** WordPress locale code. */
  language?: Maybe<Scalars['String']>;
  /** A day number of the week that the week should start on. */
  startOfWeek?: Maybe<Scalars['Int']>;
  /** A time format for all time strings. */
  timeFormat?: Maybe<Scalars['String']>;
  /** A city in the same timezone as you. */
  timezone?: Maybe<Scalars['String']>;
  /** Site title. */
  title?: Maybe<Scalars['String']>;
  /** Site URL. */
  url?: Maybe<Scalars['String']>;
};

export type GetCoursePricingInput = {
  courseId: Scalars['Int'];
};

export type GetCoursePricingOutput = {
  __typename?: 'GetCoursePricingOutput';
  blended?: Maybe<Scalars['Boolean']>;
  level?: Maybe<CourseLevel>;
  priceAmount: Scalars['Float'];
  priceCurrency: Currency;
  reaccreditation?: Maybe<Scalars['Boolean']>;
  type?: Maybe<CourseType>;
  xeroCode: Scalars['String'];
};

export type GetTrainersLevelsInput = {
  courseEnd: Scalars['date'];
  courseLevel: CourseLevel;
  courseStart: Scalars['date'];
  ids: Array<Scalars['uuid']>;
  trainerType: CourseTrainerType;
};

export enum Go1ChangeError {
  GenericError = 'GENERIC_ERROR',
  InvoiceNotAuthorized = 'INVOICE_NOT_AUTHORIZED'
}

export enum Go1ChangeType {
  LicensesAdded = 'LICENSES_ADDED',
  LicensesPurchased = 'LICENSES_PURCHASED',
  LicensesReleased = 'LICENSES_RELEASED',
  LicensesRemoved = 'LICENSES_REMOVED',
  LicenseIssued = 'LICENSE_ISSUED',
  LicenseRevoked = 'LICENSE_REVOKED'
}

export type Go1LicensesChangeInput = {
  amount: Scalars['Int'];
  orgId: Scalars['uuid'];
  payload?: InputMaybe<Scalars['jsonb']>;
  type: Go1ChangeType;
};

export type Go1LicensesChangeOutput = {
  __typename?: 'Go1LicensesChangeOutput';
  error?: Maybe<Go1ChangeError>;
  success: Scalars['Boolean'];
};

/** Content node with hierarchical (parent/child) relationships */
export type HierarchicalContentNode = {
  /** Returns ancestors of the node. Default ordered as lowest (closest to the child) to highest (closest to the root). */
  ancestors?: Maybe<HierarchicalContentNodeToContentNodeAncestorsConnection>;
  /** Connection between the HierarchicalContentNode type and the ContentNode type */
  children?: Maybe<HierarchicalContentNodeToContentNodeChildrenConnection>;
  /** The parent of the node. The parent object can be of various types */
  parent?: Maybe<HierarchicalContentNodeToParentContentNodeConnectionEdge>;
  /** Database id of the parent node */
  parentDatabaseId?: Maybe<Scalars['Int']>;
  /** The globally unique identifier of the parent node. */
  parentId?: Maybe<Scalars['ID']>;
};


/** Content node with hierarchical (parent/child) relationships */
export type HierarchicalContentNodeAncestorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<HierarchicalContentNodeToContentNodeAncestorsConnectionWhereArgs>;
};


/** Content node with hierarchical (parent/child) relationships */
export type HierarchicalContentNodeChildrenArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<HierarchicalContentNodeToContentNodeChildrenConnectionWhereArgs>;
};

/** Connection between the HierarchicalContentNode type and the ContentNode type */
export type HierarchicalContentNodeToContentNodeAncestorsConnection = {
  __typename?: 'HierarchicalContentNodeToContentNodeAncestorsConnection';
  /** Edges for the HierarchicalContentNodeToContentNodeAncestorsConnection connection */
  edges?: Maybe<Array<Maybe<HierarchicalContentNodeToContentNodeAncestorsConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type HierarchicalContentNodeToContentNodeAncestorsConnectionEdge = {
  __typename?: 'HierarchicalContentNodeToContentNodeAncestorsConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentNode>;
};

/** Arguments for filtering the HierarchicalContentNodeToContentNodeAncestorsConnection connection */
export type HierarchicalContentNodeToContentNodeAncestorsConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the HierarchicalContentNode type and the ContentNode type */
export type HierarchicalContentNodeToContentNodeChildrenConnection = {
  __typename?: 'HierarchicalContentNodeToContentNodeChildrenConnection';
  /** Edges for the HierarchicalContentNodeToContentNodeChildrenConnection connection */
  edges?: Maybe<Array<Maybe<HierarchicalContentNodeToContentNodeChildrenConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type HierarchicalContentNodeToContentNodeChildrenConnectionEdge = {
  __typename?: 'HierarchicalContentNodeToContentNodeChildrenConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentNode>;
};

/** Arguments for filtering the HierarchicalContentNodeToContentNodeChildrenConnection connection */
export type HierarchicalContentNodeToContentNodeChildrenConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the HierarchicalContentNode type and the ContentNode type */
export type HierarchicalContentNodeToParentContentNodeConnectionEdge = {
  __typename?: 'HierarchicalContentNodeToParentContentNodeConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<ContentNode>;
};

/** Term node with hierarchical (parent/child) relationships */
export type HierarchicalTermNode = {
  /** Database id of the parent node */
  parentDatabaseId?: Maybe<Scalars['Int']>;
  /** The globally unique identifier of the parent node. */
  parentId?: Maybe<Scalars['ID']>;
};

export type InitAuthOutput = {
  __typename?: 'InitAuthOutput';
  authChallenge: Scalars['String'];
  email: Scalars['String'];
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Int']>;
  _gt?: InputMaybe<Scalars['Int']>;
  _gte?: InputMaybe<Scalars['Int']>;
  _in?: InputMaybe<Array<Scalars['Int']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Int']>;
  _lte?: InputMaybe<Scalars['Int']>;
  _neq?: InputMaybe<Scalars['Int']>;
  _nin?: InputMaybe<Array<Scalars['Int']>>;
};

export enum InviteStatus {
  Accepted = 'ACCEPTED',
  Declined = 'DECLINED',
  Pending = 'PENDING'
}

/** File details for a Media Item */
export type MediaDetails = {
  __typename?: 'MediaDetails';
  /** The filename of the mediaItem */
  file?: Maybe<Scalars['String']>;
  /** The height of the mediaItem */
  height?: Maybe<Scalars['Int']>;
  /** Meta information associated with the mediaItem */
  meta?: Maybe<MediaItemMeta>;
  /** The available sizes of the mediaItem */
  sizes?: Maybe<Array<Maybe<MediaSize>>>;
  /** The width of the mediaItem */
  width?: Maybe<Scalars['Int']>;
};


/** File details for a Media Item */
export type MediaDetailsSizesArgs = {
  exclude?: InputMaybe<Array<InputMaybe<MediaItemSizeEnum>>>;
  include?: InputMaybe<Array<InputMaybe<MediaItemSizeEnum>>>;
};

/** The mediaItem type */
export type MediaItem = ContentNode & DatabaseIdentifier & HierarchicalContentNode & Node & NodeWithAuthor & NodeWithComments & NodeWithTemplate & NodeWithTitle & UniformResourceIdentifiable & {
  __typename?: 'MediaItem';
  /** Alternative text to display when resource is not displayed */
  altText?: Maybe<Scalars['String']>;
  /** Returns ancestors of the node. Default ordered as lowest (closest to the child) to highest (closest to the root). */
  ancestors?: Maybe<HierarchicalContentNodeToContentNodeAncestorsConnection>;
  /** Connection between the NodeWithAuthor type and the User type */
  author?: Maybe<NodeWithAuthorToUserConnectionEdge>;
  /** The database identifier of the author of the node */
  authorDatabaseId?: Maybe<Scalars['Int']>;
  /** The globally unique identifier of the author of the node */
  authorId?: Maybe<Scalars['ID']>;
  /** The caption for the resource */
  caption?: Maybe<Scalars['String']>;
  /** Connection between the HierarchicalContentNode type and the ContentNode type */
  children?: Maybe<HierarchicalContentNodeToContentNodeChildrenConnection>;
  /** The number of comments. Even though WPGraphQL denotes this field as an integer, in WordPress this field should be saved as a numeric string for compatibility. */
  commentCount?: Maybe<Scalars['Int']>;
  /** Whether the comments are open or closed for this particular post. */
  commentStatus?: Maybe<Scalars['String']>;
  /** Connection between the mediaItem type and the Comment type */
  comments?: Maybe<MediaItemToCommentConnection>;
  /** Connection between the ContentNode type and the ContentType type */
  contentType?: Maybe<ContentNodeToContentTypeConnectionEdge>;
  /** The name of the Content Type the node belongs to */
  contentTypeName: Scalars['String'];
  /** The unique identifier stored in the database */
  databaseId: Scalars['Int'];
  /** Post publishing date. */
  date?: Maybe<Scalars['String']>;
  /** The publishing date set in GMT. */
  dateGmt?: Maybe<Scalars['String']>;
  /** Description of the image (stored as post_content) */
  description?: Maybe<Scalars['String']>;
  /** The desired slug of the post */
  desiredSlug?: Maybe<Scalars['String']>;
  /** If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds */
  editingLockedBy?: Maybe<ContentNodeToEditLockConnectionEdge>;
  /** The RSS enclosure for the object */
  enclosure?: Maybe<Scalars['String']>;
  /** Connection between the ContentNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<ContentNodeToEnqueuedScriptConnection>;
  /** Connection between the ContentNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<ContentNodeToEnqueuedStylesheetConnection>;
  /** The filesize in bytes of the resource */
  fileSize?: Maybe<Scalars['Int']>;
  /** The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table. */
  guid?: Maybe<Scalars['String']>;
  /** The globally unique identifier of the attachment object. */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is a node in the preview state */
  isPreview?: Maybe<Scalars['Boolean']>;
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The user that most recently edited the node */
  lastEditedBy?: Maybe<ContentNodeToEditLastConnectionEdge>;
  /** The permalink of the post */
  link?: Maybe<Scalars['String']>;
  /** Details about the mediaItem */
  mediaDetails?: Maybe<MediaDetails>;
  /** The id field matches the WP_Post-&gt;ID field. */
  mediaItemId: Scalars['Int'];
  /** Url of the mediaItem */
  mediaItemUrl?: Maybe<Scalars['String']>;
  /** Type of resource */
  mediaType?: Maybe<Scalars['String']>;
  /** The mime type of the mediaItem */
  mimeType?: Maybe<Scalars['String']>;
  /** The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time. */
  modified?: Maybe<Scalars['String']>;
  /** The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT. */
  modifiedGmt?: Maybe<Scalars['String']>;
  /** The parent of the node. The parent object can be of various types */
  parent?: Maybe<HierarchicalContentNodeToParentContentNodeConnectionEdge>;
  /** Database id of the parent node */
  parentDatabaseId?: Maybe<Scalars['Int']>;
  /** The globally unique identifier of the parent node. */
  parentId?: Maybe<Scalars['ID']>;
  /** The database id of the preview node */
  previewRevisionDatabaseId?: Maybe<Scalars['Int']>;
  /** Whether the object is a node in the preview state */
  previewRevisionId?: Maybe<Scalars['ID']>;
  /** The sizes attribute value for an image. */
  sizes?: Maybe<Scalars['String']>;
  /** The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table. */
  slug?: Maybe<Scalars['String']>;
  /** Url of the mediaItem */
  sourceUrl?: Maybe<Scalars['String']>;
  /** The srcset attribute specifies the URL of the image to use in different situations. It is a comma separated string of urls and their widths. */
  srcSet?: Maybe<Scalars['String']>;
  /** The current status of the object */
  status?: Maybe<Scalars['String']>;
  /** The template assigned to the node */
  template?: Maybe<ContentTemplate>;
  /** The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made. */
  title?: Maybe<Scalars['String']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** The mediaItem type */
export type MediaItemAncestorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<HierarchicalContentNodeToContentNodeAncestorsConnectionWhereArgs>;
};


/** The mediaItem type */
export type MediaItemCaptionArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};


/** The mediaItem type */
export type MediaItemChildrenArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<HierarchicalContentNodeToContentNodeChildrenConnectionWhereArgs>;
};


/** The mediaItem type */
export type MediaItemCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MediaItemToCommentConnectionWhereArgs>;
};


/** The mediaItem type */
export type MediaItemDescriptionArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};


/** The mediaItem type */
export type MediaItemEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The mediaItem type */
export type MediaItemEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The mediaItem type */
export type MediaItemFileSizeArgs = {
  size?: InputMaybe<MediaItemSizeEnum>;
};


/** The mediaItem type */
export type MediaItemSizesArgs = {
  size?: InputMaybe<MediaItemSizeEnum>;
};


/** The mediaItem type */
export type MediaItemSourceUrlArgs = {
  size?: InputMaybe<MediaItemSizeEnum>;
};


/** The mediaItem type */
export type MediaItemSrcSetArgs = {
  size?: InputMaybe<MediaItemSizeEnum>;
};


/** The mediaItem type */
export type MediaItemTitleArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum MediaItemIdType {
  /** Identify a resource by the Database ID. */
  DatabaseId = 'DATABASE_ID',
  /** Identify a resource by the (hashed) Global ID. */
  Id = 'ID',
  /** Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier. */
  Slug = 'SLUG',
  /** Identify a media item by its source url */
  SourceUrl = 'SOURCE_URL',
  /** Identify a resource by the URI. */
  Uri = 'URI'
}

/** Meta connected to a MediaItem */
export type MediaItemMeta = {
  __typename?: 'MediaItemMeta';
  /** Aperture measurement of the media item. */
  aperture?: Maybe<Scalars['Float']>;
  /** Information about the camera used to create the media item. */
  camera?: Maybe<Scalars['String']>;
  /** The text string description associated with the media item. */
  caption?: Maybe<Scalars['String']>;
  /** Copyright information associated with the media item. */
  copyright?: Maybe<Scalars['String']>;
  /** The date/time when the media was created. */
  createdTimestamp?: Maybe<Scalars['Int']>;
  /** The original creator of the media item. */
  credit?: Maybe<Scalars['String']>;
  /** The focal length value of the media item. */
  focalLength?: Maybe<Scalars['Float']>;
  /** The ISO (International Organization for Standardization) value of the media item. */
  iso?: Maybe<Scalars['Int']>;
  /** List of keywords used to describe or identfy the media item. */
  keywords?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** The vertical or horizontal aspect of the media item. */
  orientation?: Maybe<Scalars['String']>;
  /** The shutter speed information of the media item. */
  shutterSpeed?: Maybe<Scalars['Float']>;
  /** A useful title for the media item. */
  title?: Maybe<Scalars['String']>;
};

/** The size of the media item object. */
export enum MediaItemSizeEnum {
  /** MediaItem with the blog-large size */
  BlogLarge = 'BLOG_LARGE',
  /** MediaItem with the blog-medium size */
  BlogMedium = 'BLOG_MEDIUM',
  /** MediaItem with the fusion-200 size */
  Fusion_200 = 'FUSION_200',
  /** MediaItem with the fusion-400 size */
  Fusion_400 = 'FUSION_400',
  /** MediaItem with the fusion-600 size */
  Fusion_600 = 'FUSION_600',
  /** MediaItem with the fusion-800 size */
  Fusion_800 = 'FUSION_800',
  /** MediaItem with the fusion-1200 size */
  Fusion_1200 = 'FUSION_1200',
  /** MediaItem with the large size */
  Large = 'LARGE',
  /** MediaItem with the medium size */
  Medium = 'MEDIUM',
  /** MediaItem with the medium_large size */
  MediumLarge = 'MEDIUM_LARGE',
  /** MediaItem with the portfolio-five size */
  PortfolioFive = 'PORTFOLIO_FIVE',
  /** MediaItem with the portfolio-full size */
  PortfolioFull = 'PORTFOLIO_FULL',
  /** MediaItem with the portfolio-one size */
  PortfolioOne = 'PORTFOLIO_ONE',
  /** MediaItem with the portfolio-three size */
  PortfolioThree = 'PORTFOLIO_THREE',
  /** MediaItem with the portfolio-two size */
  PortfolioTwo = 'PORTFOLIO_TWO',
  /** MediaItem with the recent-posts size */
  RecentPosts = 'RECENT_POSTS',
  /** MediaItem with the recent-works-thumbnail size */
  RecentWorksThumbnail = 'RECENT_WORKS_THUMBNAIL',
  /** MediaItem with the thumbnail size */
  Thumbnail = 'THUMBNAIL',
  /** MediaItem with the wpsm_team_pro_small size */
  WpsmTeamProSmall = 'WPSM_TEAM_PRO_SMALL',
  /** MediaItem with the wpsm_team_pro_small3 size */
  WpsmTeamProSmall3 = 'WPSM_TEAM_PRO_SMALL3',
  /** MediaItem with the wpsm_team_pro_small4 size */
  WpsmTeamProSmall4 = 'WPSM_TEAM_PRO_SMALL4',
  /** MediaItem with the wpsm_team_pro_small5 size */
  WpsmTeamProSmall5 = 'WPSM_TEAM_PRO_SMALL5',
  /** MediaItem with the wpsm_team_pro_small6 size */
  WpsmTeamProSmall6 = 'WPSM_TEAM_PRO_SMALL6',
  /** MediaItem with the 1536x1536 size */
  '1536X1536' = '_1536X1536',
  /** MediaItem with the 2048x2048 size */
  '2048X2048' = '_2048X2048'
}

/** The status of the media item object. */
export enum MediaItemStatusEnum {
  /** Objects with the auto-draft status */
  AutoDraft = 'AUTO_DRAFT',
  /** Objects with the inherit status */
  Inherit = 'INHERIT',
  /** Objects with the private status */
  Private = 'PRIVATE',
  /** Objects with the trash status */
  Trash = 'TRASH'
}

/** Connection between the mediaItem type and the Comment type */
export type MediaItemToCommentConnection = {
  __typename?: 'MediaItemToCommentConnection';
  /** Edges for the MediaItemToCommentConnection connection */
  edges?: Maybe<Array<Maybe<MediaItemToCommentConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Comment>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type MediaItemToCommentConnectionEdge = {
  __typename?: 'MediaItemToCommentConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Comment>;
};

/** Arguments for filtering the MediaItemToCommentConnection connection */
export type MediaItemToCommentConnectionWhereArgs = {
  /** Comment author email address. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** Array of author IDs to include comments for. */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to exclude comments for. */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Comment author URL. */
  authorUrl?: InputMaybe<Scalars['String']>;
  /** Array of comment IDs to include. */
  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */
  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Include comments of a given type. */
  commentType?: InputMaybe<Scalars['String']>;
  /** Include comments from a given array of comment types. */
  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Exclude comments from a given array of comment types. */
  commentTypeNotIn?: InputMaybe<Scalars['String']>;
  /** Content object author ID to limit results by. */
  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to retrieve comments for. */
  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs *not* to retrieve comments for. */
  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Limit results to those affiliated with a given content object ID. */
  contentId?: InputMaybe<Scalars['ID']>;
  /** Array of content object IDs to include affiliated comments for. */
  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of content object IDs to exclude affiliated comments for. */
  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Content object name to retrieve affiliated comments for. */
  contentName?: InputMaybe<Scalars['String']>;
  /** Content Object parent ID to retrieve affiliated comments for. */
  contentParent?: InputMaybe<Scalars['Int']>;
  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */
  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Karma score to retrieve matching comments for. */
  karma?: InputMaybe<Scalars['Int']>;
  /** The cardinality of the order of the connection */
  order?: InputMaybe<OrderEnum>;
  /** Field to order the comments by. */
  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;
  /** Parent ID of comment to retrieve children of. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Array of parent IDs of comments to retrieve children for. */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of parent IDs of comments *not* to retrieve children for. */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Search term(s) to retrieve matching comments for. */
  search?: InputMaybe<Scalars['String']>;
  /** Comment status to limit results by. */
  status?: InputMaybe<Scalars['String']>;
  /** Include comments for a specific user ID. */
  userId?: InputMaybe<Scalars['ID']>;
};

/** Details of an available size for a media item */
export type MediaSize = {
  __typename?: 'MediaSize';
  /** The filename of the referenced size */
  file?: Maybe<Scalars['String']>;
  /** The filesize of the resource */
  fileSize?: Maybe<Scalars['Int']>;
  /** The height of the referenced size */
  height?: Maybe<Scalars['String']>;
  /** The mime type of the referenced size */
  mimeType?: Maybe<Scalars['String']>;
  /** The referenced size name */
  name?: Maybe<Scalars['String']>;
  /** The url of the referenced size */
  sourceUrl?: Maybe<Scalars['String']>;
  /** The width of the referenced size */
  width?: Maybe<Scalars['String']>;
};

/** Menus are the containers for navigation items. Menus can be assigned to menu locations, which are typically registered by the active theme. */
export type Menu = DatabaseIdentifier & Node & {
  __typename?: 'Menu';
  /** The number of items in the menu */
  count?: Maybe<Scalars['Int']>;
  /** The unique identifier stored in the database */
  databaseId: Scalars['Int'];
  /** The globally unique identifier of the nav menu object. */
  id: Scalars['ID'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** The locations a menu is assigned to */
  locations?: Maybe<Array<Maybe<MenuLocationEnum>>>;
  /** WP ID of the nav menu. */
  menuId?: Maybe<Scalars['Int']>;
  /** Connection between the Menu type and the MenuItem type */
  menuItems?: Maybe<MenuToMenuItemConnection>;
  /** Display name of the menu. Equivalent to WP_Term-&gt;name. */
  name?: Maybe<Scalars['String']>;
  /** The url friendly name of the menu. Equivalent to WP_Term-&gt;slug */
  slug?: Maybe<Scalars['String']>;
};


/** Menus are the containers for navigation items. Menus can be assigned to menu locations, which are typically registered by the active theme. */
export type MenuMenuItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MenuToMenuItemConnectionWhereArgs>;
};

/** Navigation menu items are the individual items assigned to a menu. These are rendered as the links in a navigation menu. */
export type MenuItem = DatabaseIdentifier & Node & {
  __typename?: 'MenuItem';
  /** Connection between the MenuItem type and the MenuItem type */
  childItems?: Maybe<MenuItemToMenuItemConnection>;
  /** Connection from MenuItem to it&#039;s connected node */
  connectedNode?: Maybe<MenuItemToMenuItemLinkableConnectionEdge>;
  /** The object connected to this menu item. */
  connectedObject?: Maybe<MenuItemObjectUnion>;
  /** Class attribute for the menu item link */
  cssClasses?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** The unique identifier stored in the database */
  databaseId: Scalars['Int'];
  /** Description of the menu item. */
  description?: Maybe<Scalars['String']>;
  /** The globally unique identifier of the nav menu item object. */
  id: Scalars['ID'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Label or title of the menu item. */
  label?: Maybe<Scalars['String']>;
  /** Link relationship (XFN) of the menu item. */
  linkRelationship?: Maybe<Scalars['String']>;
  /** The locations the menu item&#039;s Menu is assigned to */
  locations?: Maybe<Array<Maybe<MenuLocationEnum>>>;
  /** The Menu a MenuItem is part of */
  menu?: Maybe<MenuItemToMenuConnectionEdge>;
  /** WP ID of the menu item. */
  menuItemId?: Maybe<Scalars['Int']>;
  /** Menu item order */
  order?: Maybe<Scalars['Int']>;
  /** The database id of the parent menu item or null if it is the root */
  parentDatabaseId?: Maybe<Scalars['Int']>;
  /** The globally unique identifier of the parent nav menu item object. */
  parentId?: Maybe<Scalars['ID']>;
  /** Path for the resource. Relative path for internal resources. Absolute path for external resources. */
  path?: Maybe<Scalars['String']>;
  /** Target attribute for the menu item link. */
  target?: Maybe<Scalars['String']>;
  /** Title attribute for the menu item link */
  title?: Maybe<Scalars['String']>;
  /** The uri of the resource the menu item links to */
  uri?: Maybe<Scalars['String']>;
  /** URL or destination of the menu item. */
  url?: Maybe<Scalars['String']>;
};


/** Navigation menu items are the individual items assigned to a menu. These are rendered as the links in a navigation menu. */
export type MenuItemChildItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<MenuItemToMenuItemConnectionWhereArgs>;
};

/** Nodes that can be linked to as Menu Items */
export type MenuItemLinkable = {
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** The unique resource identifier path */
  id: Scalars['ID'];
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};

/** The Type of Identifier used to fetch a single node. Default is "ID". To be used along with the "id" field. */
export enum MenuItemNodeIdTypeEnum {
  /** Identify a resource by the Database ID. */
  DatabaseId = 'DATABASE_ID',
  /** Identify a resource by the (hashed) Global ID. */
  Id = 'ID'
}

/** Deprecated in favor of MenuItemLinkeable Interface */
export type MenuItemObjectUnion = Category | Ebook | EbooksCategory | Page | Post | PostFormat | ResearchSummariesCategory | ResearchSummary | Resource | ResourceCategory | Tag | VideoSeriesCategory | VideoSeriesItem | Webinar | WebinarsCategory;

/** Connection between the MenuItem type and the Menu type */
export type MenuItemToMenuConnectionEdge = {
  __typename?: 'MenuItemToMenuConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Menu>;
};

/** Connection between the MenuItem type and the MenuItem type */
export type MenuItemToMenuItemConnection = {
  __typename?: 'MenuItemToMenuItemConnection';
  /** Edges for the MenuItemToMenuItemConnection connection */
  edges?: Maybe<Array<Maybe<MenuItemToMenuItemConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<MenuItem>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type MenuItemToMenuItemConnectionEdge = {
  __typename?: 'MenuItemToMenuItemConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<MenuItem>;
};

/** Arguments for filtering the MenuItemToMenuItemConnection connection */
export type MenuItemToMenuItemConnectionWhereArgs = {
  /** The database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** The menu location for the menu being queried */
  location?: InputMaybe<MenuLocationEnum>;
  /** The database ID of the parent menu object */
  parentDatabaseId?: InputMaybe<Scalars['Int']>;
  /** The ID of the parent menu object */
  parentId?: InputMaybe<Scalars['ID']>;
};

/** Connection between the MenuItem type and the MenuItemLinkable type */
export type MenuItemToMenuItemLinkableConnectionEdge = {
  __typename?: 'MenuItemToMenuItemLinkableConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<MenuItemLinkable>;
};

/** Registered menu locations */
export enum MenuLocationEnum {
  /** Put the menu in the main_navigation location */
  MainNavigation = 'MAIN_NAVIGATION',
  /** Put the menu in the mobile_navigation location */
  MobileNavigation = 'MOBILE_NAVIGATION',
  /** Put the menu in the sticky_navigation location */
  StickyNavigation = 'STICKY_NAVIGATION',
  /** Put the menu in the top_navigation location */
  TopNavigation = 'TOP_NAVIGATION',
  /** Put the menu in the 404_pages location */
  '404Pages' = '_404_PAGES'
}

/** The Type of Identifier used to fetch a single node. Default is "ID". To be used along with the "id" field. */
export enum MenuNodeIdTypeEnum {
  /** Identify a menu node by the Database ID. */
  DatabaseId = 'DATABASE_ID',
  /** Identify a menu node by the (hashed) Global ID. */
  Id = 'ID',
  /** Identify a menu node by the slug of menu location to which it is assigned */
  Location = 'LOCATION',
  /** Identify a menu node by its name */
  Name = 'NAME',
  /** Identify a menu node by its slug */
  Slug = 'SLUG'
}

/** Connection between the Menu type and the MenuItem type */
export type MenuToMenuItemConnection = {
  __typename?: 'MenuToMenuItemConnection';
  /** Edges for the MenuToMenuItemConnection connection */
  edges?: Maybe<Array<Maybe<MenuToMenuItemConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<MenuItem>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type MenuToMenuItemConnectionEdge = {
  __typename?: 'MenuToMenuItemConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<MenuItem>;
};

/** Arguments for filtering the MenuToMenuItemConnection connection */
export type MenuToMenuItemConnectionWhereArgs = {
  /** The database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** The menu location for the menu being queried */
  location?: InputMaybe<MenuLocationEnum>;
  /** The database ID of the parent menu object */
  parentDatabaseId?: InputMaybe<Scalars['Int']>;
  /** The ID of the parent menu object */
  parentId?: InputMaybe<Scalars['ID']>;
};

/** The MimeType of the object */
export enum MimeTypeEnum {
  /** MimeType application/java */
  ApplicationJava = 'APPLICATION_JAVA',
  /** MimeType application/json */
  ApplicationJson = 'APPLICATION_JSON',
  /** MimeType application/msword */
  ApplicationMsword = 'APPLICATION_MSWORD',
  /** MimeType application/octet-stream */
  ApplicationOctetStream = 'APPLICATION_OCTET_STREAM',
  /** MimeType application/onenote */
  ApplicationOnenote = 'APPLICATION_ONENOTE',
  /** MimeType application/oxps */
  ApplicationOxps = 'APPLICATION_OXPS',
  /** MimeType application/pdf */
  ApplicationPdf = 'APPLICATION_PDF',
  /** MimeType application/rar */
  ApplicationRar = 'APPLICATION_RAR',
  /** MimeType application/rtf */
  ApplicationRtf = 'APPLICATION_RTF',
  /** MimeType application/ttaf+xml */
  ApplicationTtafXml = 'APPLICATION_TTAF_XML',
  /** MimeType application/vnd.apple.keynote */
  ApplicationVndAppleKeynote = 'APPLICATION_VND_APPLE_KEYNOTE',
  /** MimeType application/vnd.apple.numbers */
  ApplicationVndAppleNumbers = 'APPLICATION_VND_APPLE_NUMBERS',
  /** MimeType application/vnd.apple.pages */
  ApplicationVndApplePages = 'APPLICATION_VND_APPLE_PAGES',
  /** MimeType application/vnd.ms-access */
  ApplicationVndMsAccess = 'APPLICATION_VND_MS_ACCESS',
  /** MimeType application/vnd.ms-excel */
  ApplicationVndMsExcel = 'APPLICATION_VND_MS_EXCEL',
  /** MimeType application/vnd.ms-excel.addin.macroEnabled.12 */
  ApplicationVndMsExcelAddinMacroenabled_12 = 'APPLICATION_VND_MS_EXCEL_ADDIN_MACROENABLED_12',
  /** MimeType application/vnd.ms-excel.sheet.binary.macroEnabled.12 */
  ApplicationVndMsExcelSheetBinaryMacroenabled_12 = 'APPLICATION_VND_MS_EXCEL_SHEET_BINARY_MACROENABLED_12',
  /** MimeType application/vnd.ms-excel.sheet.macroEnabled.12 */
  ApplicationVndMsExcelSheetMacroenabled_12 = 'APPLICATION_VND_MS_EXCEL_SHEET_MACROENABLED_12',
  /** MimeType application/vnd.ms-excel.template.macroEnabled.12 */
  ApplicationVndMsExcelTemplateMacroenabled_12 = 'APPLICATION_VND_MS_EXCEL_TEMPLATE_MACROENABLED_12',
  /** MimeType application/vnd.ms-powerpoint */
  ApplicationVndMsPowerpoint = 'APPLICATION_VND_MS_POWERPOINT',
  /** MimeType application/vnd.ms-powerpoint.addin.macroEnabled.12 */
  ApplicationVndMsPowerpointAddinMacroenabled_12 = 'APPLICATION_VND_MS_POWERPOINT_ADDIN_MACROENABLED_12',
  /** MimeType application/vnd.ms-powerpoint.presentation.macroEnabled.12 */
  ApplicationVndMsPowerpointPresentationMacroenabled_12 = 'APPLICATION_VND_MS_POWERPOINT_PRESENTATION_MACROENABLED_12',
  /** MimeType application/vnd.ms-powerpoint.slideshow.macroEnabled.12 */
  ApplicationVndMsPowerpointSlideshowMacroenabled_12 = 'APPLICATION_VND_MS_POWERPOINT_SLIDESHOW_MACROENABLED_12',
  /** MimeType application/vnd.ms-powerpoint.slide.macroEnabled.12 */
  ApplicationVndMsPowerpointSlideMacroenabled_12 = 'APPLICATION_VND_MS_POWERPOINT_SLIDE_MACROENABLED_12',
  /** MimeType application/vnd.ms-powerpoint.template.macroEnabled.12 */
  ApplicationVndMsPowerpointTemplateMacroenabled_12 = 'APPLICATION_VND_MS_POWERPOINT_TEMPLATE_MACROENABLED_12',
  /** MimeType application/vnd.ms-project */
  ApplicationVndMsProject = 'APPLICATION_VND_MS_PROJECT',
  /** MimeType application/vnd.ms-word.document.macroEnabled.12 */
  ApplicationVndMsWordDocumentMacroenabled_12 = 'APPLICATION_VND_MS_WORD_DOCUMENT_MACROENABLED_12',
  /** MimeType application/vnd.ms-word.template.macroEnabled.12 */
  ApplicationVndMsWordTemplateMacroenabled_12 = 'APPLICATION_VND_MS_WORD_TEMPLATE_MACROENABLED_12',
  /** MimeType application/vnd.ms-write */
  ApplicationVndMsWrite = 'APPLICATION_VND_MS_WRITE',
  /** MimeType application/vnd.ms-xpsdocument */
  ApplicationVndMsXpsdocument = 'APPLICATION_VND_MS_XPSDOCUMENT',
  /** MimeType application/vnd.oasis.opendocument.chart */
  ApplicationVndOasisOpendocumentChart = 'APPLICATION_VND_OASIS_OPENDOCUMENT_CHART',
  /** MimeType application/vnd.oasis.opendocument.database */
  ApplicationVndOasisOpendocumentDatabase = 'APPLICATION_VND_OASIS_OPENDOCUMENT_DATABASE',
  /** MimeType application/vnd.oasis.opendocument.formula */
  ApplicationVndOasisOpendocumentFormula = 'APPLICATION_VND_OASIS_OPENDOCUMENT_FORMULA',
  /** MimeType application/vnd.oasis.opendocument.graphics */
  ApplicationVndOasisOpendocumentGraphics = 'APPLICATION_VND_OASIS_OPENDOCUMENT_GRAPHICS',
  /** MimeType application/vnd.oasis.opendocument.presentation */
  ApplicationVndOasisOpendocumentPresentation = 'APPLICATION_VND_OASIS_OPENDOCUMENT_PRESENTATION',
  /** MimeType application/vnd.oasis.opendocument.spreadsheet */
  ApplicationVndOasisOpendocumentSpreadsheet = 'APPLICATION_VND_OASIS_OPENDOCUMENT_SPREADSHEET',
  /** MimeType application/vnd.oasis.opendocument.text */
  ApplicationVndOasisOpendocumentText = 'APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT',
  /** MimeType application/vnd.openxmlformats-officedocument.presentationml.presentation */
  ApplicationVndOpenxmlformatsOfficedocumentPresentationmlPresentation = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_PRESENTATION',
  /** MimeType application/vnd.openxmlformats-officedocument.presentationml.slide */
  ApplicationVndOpenxmlformatsOfficedocumentPresentationmlSlide = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDE',
  /** MimeType application/vnd.openxmlformats-officedocument.presentationml.slideshow */
  ApplicationVndOpenxmlformatsOfficedocumentPresentationmlSlideshow = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDESHOW',
  /** MimeType application/vnd.openxmlformats-officedocument.presentationml.template */
  ApplicationVndOpenxmlformatsOfficedocumentPresentationmlTemplate = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_TEMPLATE',
  /** MimeType application/vnd.openxmlformats-officedocument.spreadsheetml.sheet */
  ApplicationVndOpenxmlformatsOfficedocumentSpreadsheetmlSheet = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_SHEET',
  /** MimeType application/vnd.openxmlformats-officedocument.spreadsheetml.template */
  ApplicationVndOpenxmlformatsOfficedocumentSpreadsheetmlTemplate = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_TEMPLATE',
  /** MimeType application/vnd.openxmlformats-officedocument.wordprocessingml.document */
  ApplicationVndOpenxmlformatsOfficedocumentWordprocessingmlDocument = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_DOCUMENT',
  /** MimeType application/vnd.openxmlformats-officedocument.wordprocessingml.template */
  ApplicationVndOpenxmlformatsOfficedocumentWordprocessingmlTemplate = 'APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_TEMPLATE',
  /** MimeType application/wordperfect */
  ApplicationWordperfect = 'APPLICATION_WORDPERFECT',
  /** MimeType application/x-7z-compressed */
  ApplicationX_7ZCompressed = 'APPLICATION_X_7Z_COMPRESSED',
  /** MimeType application/x-gzip */
  ApplicationXGzip = 'APPLICATION_X_GZIP',
  /** MimeType application/x-tar */
  ApplicationXTar = 'APPLICATION_X_TAR',
  /** MimeType application/zip */
  ApplicationZip = 'APPLICATION_ZIP',
  /** MimeType audio/aac */
  AudioAac = 'AUDIO_AAC',
  /** MimeType audio/flac */
  AudioFlac = 'AUDIO_FLAC',
  /** MimeType audio/midi */
  AudioMidi = 'AUDIO_MIDI',
  /** MimeType audio/mpeg */
  AudioMpeg = 'AUDIO_MPEG',
  /** MimeType audio/ogg */
  AudioOgg = 'AUDIO_OGG',
  /** MimeType audio/wav */
  AudioWav = 'AUDIO_WAV',
  /** MimeType audio/x-matroska */
  AudioXMatroska = 'AUDIO_X_MATROSKA',
  /** MimeType audio/x-ms-wax */
  AudioXMsWax = 'AUDIO_X_MS_WAX',
  /** MimeType audio/x-ms-wma */
  AudioXMsWma = 'AUDIO_X_MS_WMA',
  /** MimeType audio/x-realaudio */
  AudioXRealaudio = 'AUDIO_X_REALAUDIO',
  /** MimeType image/bmp */
  ImageBmp = 'IMAGE_BMP',
  /** MimeType image/gif */
  ImageGif = 'IMAGE_GIF',
  /** MimeType image/heic */
  ImageHeic = 'IMAGE_HEIC',
  /** MimeType image/jpeg */
  ImageJpeg = 'IMAGE_JPEG',
  /** MimeType image/png */
  ImagePng = 'IMAGE_PNG',
  /** MimeType image/tiff */
  ImageTiff = 'IMAGE_TIFF',
  /** MimeType image/webp */
  ImageWebp = 'IMAGE_WEBP',
  /** MimeType image/x-icon */
  ImageXIcon = 'IMAGE_X_ICON',
  /** MimeType text/calendar */
  TextCalendar = 'TEXT_CALENDAR',
  /** MimeType text/css */
  TextCss = 'TEXT_CSS',
  /** MimeType text/csv */
  TextCsv = 'TEXT_CSV',
  /** MimeType text/plain */
  TextPlain = 'TEXT_PLAIN',
  /** MimeType text/richtext */
  TextRichtext = 'TEXT_RICHTEXT',
  /** MimeType text/tab-separated-values */
  TextTabSeparatedValues = 'TEXT_TAB_SEPARATED_VALUES',
  /** MimeType text/vtt */
  TextVtt = 'TEXT_VTT',
  /** MimeType video/3gpp */
  Video_3Gpp = 'VIDEO_3GPP',
  /** MimeType video/3gpp2 */
  Video_3Gpp2 = 'VIDEO_3GPP2',
  /** MimeType video/avi */
  VideoAvi = 'VIDEO_AVI',
  /** MimeType video/divx */
  VideoDivx = 'VIDEO_DIVX',
  /** MimeType video/mp4 */
  VideoMp4 = 'VIDEO_MP4',
  /** MimeType video/mpeg */
  VideoMpeg = 'VIDEO_MPEG',
  /** MimeType video/ogg */
  VideoOgg = 'VIDEO_OGG',
  /** MimeType video/quicktime */
  VideoQuicktime = 'VIDEO_QUICKTIME',
  /** MimeType video/webm */
  VideoWebm = 'VIDEO_WEBM',
  /** MimeType video/x-flv */
  VideoXFlv = 'VIDEO_X_FLV',
  /** MimeType video/x-matroska */
  VideoXMatroska = 'VIDEO_X_MATROSKA',
  /** MimeType video/x-ms-asf */
  VideoXMsAsf = 'VIDEO_X_MS_ASF',
  /** MimeType video/x-ms-wm */
  VideoXMsWm = 'VIDEO_X_MS_WM',
  /** MimeType video/x-ms-wmv */
  VideoXMsWmv = 'VIDEO_X_MS_WMV',
  /** MimeType video/x-ms-wmx */
  VideoXMsWmx = 'VIDEO_X_MS_WMX'
}

/** An object with an ID */
export type Node = {
  /** The globally unique ID for the object */
  id: Scalars['ID'];
};

/** A node that can have an author assigned to it */
export type NodeWithAuthor = {
  /** Connection between the NodeWithAuthor type and the User type */
  author?: Maybe<NodeWithAuthorToUserConnectionEdge>;
  /** The database identifier of the author of the node */
  authorDatabaseId?: Maybe<Scalars['Int']>;
  /** The globally unique identifier of the author of the node */
  authorId?: Maybe<Scalars['ID']>;
};

/** Connection between the NodeWithAuthor type and the User type */
export type NodeWithAuthorToUserConnectionEdge = {
  __typename?: 'NodeWithAuthorToUserConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<User>;
};

/** A node that can have comments associated with it */
export type NodeWithComments = {
  /** The number of comments. Even though WPGraphQL denotes this field as an integer, in WordPress this field should be saved as a numeric string for compatibility. */
  commentCount?: Maybe<Scalars['Int']>;
  /** Whether the comments are open or closed for this particular post. */
  commentStatus?: Maybe<Scalars['String']>;
};

/** A node that supports the content editor */
export type NodeWithContentEditor = {
  /** The content of the post. */
  content?: Maybe<Scalars['String']>;
};


/** A node that supports the content editor */
export type NodeWithContentEditorContentArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};

/** A node that can have an excerpt */
export type NodeWithExcerpt = {
  /** The excerpt of the post. */
  excerpt?: Maybe<Scalars['String']>;
};


/** A node that can have an excerpt */
export type NodeWithExcerptExcerptArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};

/** A node that can have a featured image set */
export type NodeWithFeaturedImage = {
  /** Connection between the ContentNode type and the ContentType type */
  contentType?: Maybe<ContentNodeToContentTypeConnectionEdge>;
  /** The name of the Content Type the node belongs to */
  contentTypeName: Scalars['String'];
  /** The unique identifier stored in the database */
  databaseId: Scalars['Int'];
  /** Post publishing date. */
  date?: Maybe<Scalars['String']>;
  /** The publishing date set in GMT. */
  dateGmt?: Maybe<Scalars['String']>;
  /** The desired slug of the post */
  desiredSlug?: Maybe<Scalars['String']>;
  /** If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds */
  editingLockedBy?: Maybe<ContentNodeToEditLockConnectionEdge>;
  /** The RSS enclosure for the object */
  enclosure?: Maybe<Scalars['String']>;
  /** Connection between the ContentNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<ContentNodeToEnqueuedScriptConnection>;
  /** Connection between the ContentNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<ContentNodeToEnqueuedStylesheetConnection>;
  /** Connection between the NodeWithFeaturedImage type and the MediaItem type */
  featuredImage?: Maybe<NodeWithFeaturedImageToMediaItemConnectionEdge>;
  /** The database identifier for the featured image node assigned to the content node */
  featuredImageDatabaseId?: Maybe<Scalars['Int']>;
  /** Globally unique ID of the featured image assigned to the node */
  featuredImageId?: Maybe<Scalars['ID']>;
  /** The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table. */
  guid?: Maybe<Scalars['String']>;
  /** The unique resource identifier path */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is a node in the preview state */
  isPreview?: Maybe<Scalars['Boolean']>;
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The user that most recently edited the node */
  lastEditedBy?: Maybe<ContentNodeToEditLastConnectionEdge>;
  /** The permalink of the post */
  link?: Maybe<Scalars['String']>;
  /** The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time. */
  modified?: Maybe<Scalars['String']>;
  /** The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT. */
  modifiedGmt?: Maybe<Scalars['String']>;
  /** The database id of the preview node */
  previewRevisionDatabaseId?: Maybe<Scalars['Int']>;
  /** Whether the object is a node in the preview state */
  previewRevisionId?: Maybe<Scalars['ID']>;
  /** The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table. */
  slug?: Maybe<Scalars['String']>;
  /** The current status of the object */
  status?: Maybe<Scalars['String']>;
  /** The template assigned to a node of content */
  template?: Maybe<ContentTemplate>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** A node that can have a featured image set */
export type NodeWithFeaturedImageEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A node that can have a featured image set */
export type NodeWithFeaturedImageEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Connection between the NodeWithFeaturedImage type and the MediaItem type */
export type NodeWithFeaturedImageToMediaItemConnectionEdge = {
  __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<MediaItem>;
};

/** A node that can have page attributes */
export type NodeWithPageAttributes = {
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: Maybe<Scalars['Int']>;
};

/** A node that can have revisions */
export type NodeWithRevisions = {
  /** True if the node is a revision of another node */
  isRevision?: Maybe<Scalars['Boolean']>;
  /** If the current node is a revision, this field exposes the node this is a revision of. Returns null if the node is not a revision of another node. */
  revisionOf?: Maybe<NodeWithRevisionsToContentNodeConnectionEdge>;
};

/** Connection between the NodeWithRevisions type and the ContentNode type */
export type NodeWithRevisionsToContentNodeConnectionEdge = {
  __typename?: 'NodeWithRevisionsToContentNodeConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<ContentNode>;
};

/** A node that can have a template associated with it */
export type NodeWithTemplate = {
  /** The template assigned to the node */
  template?: Maybe<ContentTemplate>;
};

/** A node that NodeWith a title */
export type NodeWithTitle = {
  /** The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made. */
  title?: Maybe<Scalars['String']>;
};


/** A node that NodeWith a title */
export type NodeWithTitleTitleArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};

/** A node that can have trackbacks and pingbacks */
export type NodeWithTrackbacks = {
  /** Whether the pings are open or closed for this particular post. */
  pingStatus?: Maybe<Scalars['String']>;
  /** URLs that have been pinged. */
  pinged?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** URLs queued to be pinged. */
  toPing?: Maybe<Array<Maybe<Scalars['String']>>>;
};

export enum OrderDirection {
  Asc = 'ASC',
  Desc = 'DESC'
}

/** The cardinality of the connection order */
export enum OrderEnum {
  /** Sort the query result set in an ascending order */
  Asc = 'ASC',
  /** Sort the query result set in a descending order */
  Desc = 'DESC'
}

export type Ordering = {
  direction?: InputMaybe<OrderDirection>;
};

export type OrgInvite = {
  __typename?: 'OrgInvite';
  id: Scalars['String'];
  orgName: Scalars['String'];
};

/** The page type */
export type Page = ContentNode & DatabaseIdentifier & HierarchicalContentNode & MenuItemLinkable & Node & NodeWithAuthor & NodeWithComments & NodeWithContentEditor & NodeWithFeaturedImage & NodeWithPageAttributes & NodeWithRevisions & NodeWithTemplate & NodeWithTitle & UniformResourceIdentifiable & {
  __typename?: 'Page';
  /** Returns ancestors of the node. Default ordered as lowest (closest to the child) to highest (closest to the root). */
  ancestors?: Maybe<HierarchicalContentNodeToContentNodeAncestorsConnection>;
  /** Connection between the NodeWithAuthor type and the User type */
  author?: Maybe<NodeWithAuthorToUserConnectionEdge>;
  /** The database identifier of the author of the node */
  authorDatabaseId?: Maybe<Scalars['Int']>;
  /** The globally unique identifier of the author of the node */
  authorId?: Maybe<Scalars['ID']>;
  /** Connection between the HierarchicalContentNode type and the ContentNode type */
  children?: Maybe<HierarchicalContentNodeToContentNodeChildrenConnection>;
  /** The number of comments. Even though WPGraphQL denotes this field as an integer, in WordPress this field should be saved as a numeric string for compatibility. */
  commentCount?: Maybe<Scalars['Int']>;
  /** Whether the comments are open or closed for this particular post. */
  commentStatus?: Maybe<Scalars['String']>;
  /** Connection between the page type and the Comment type */
  comments?: Maybe<PageToCommentConnection>;
  /** The content of the post. */
  content?: Maybe<Scalars['String']>;
  /** Connection between the ContentNode type and the ContentType type */
  contentType?: Maybe<ContentNodeToContentTypeConnectionEdge>;
  /** The name of the Content Type the node belongs to */
  contentTypeName: Scalars['String'];
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** Post publishing date. */
  date?: Maybe<Scalars['String']>;
  /** The publishing date set in GMT. */
  dateGmt?: Maybe<Scalars['String']>;
  /** The desired slug of the post */
  desiredSlug?: Maybe<Scalars['String']>;
  /** If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds */
  editingLockedBy?: Maybe<ContentNodeToEditLockConnectionEdge>;
  /** The RSS enclosure for the object */
  enclosure?: Maybe<Scalars['String']>;
  /** Connection between the ContentNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<ContentNodeToEnqueuedScriptConnection>;
  /** Connection between the ContentNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<ContentNodeToEnqueuedStylesheetConnection>;
  /** Connection between the NodeWithFeaturedImage type and the MediaItem type */
  featuredImage?: Maybe<NodeWithFeaturedImageToMediaItemConnectionEdge>;
  /** The database identifier for the featured image node assigned to the content node */
  featuredImageDatabaseId?: Maybe<Scalars['Int']>;
  /** Globally unique ID of the featured image assigned to the node */
  featuredImageId?: Maybe<Scalars['ID']>;
  /** The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table. */
  guid?: Maybe<Scalars['String']>;
  /** The globally unique identifier of the page object. */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether this page is set to the static front page. */
  isFrontPage: Scalars['Boolean'];
  /** Whether this page is set to the blog posts page. */
  isPostsPage: Scalars['Boolean'];
  /** Whether the object is a node in the preview state */
  isPreview?: Maybe<Scalars['Boolean']>;
  /** Whether this page is set to the privacy page. */
  isPrivacyPage: Scalars['Boolean'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** True if the node is a revision of another node */
  isRevision?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The user that most recently edited the node */
  lastEditedBy?: Maybe<ContentNodeToEditLastConnectionEdge>;
  /** The permalink of the post */
  link?: Maybe<Scalars['String']>;
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: Maybe<Scalars['Int']>;
  /** The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time. */
  modified?: Maybe<Scalars['String']>;
  /** The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT. */
  modifiedGmt?: Maybe<Scalars['String']>;
  /** The id field matches the WP_Post-&gt;ID field. */
  pageId: Scalars['Int'];
  /** The parent of the node. The parent object can be of various types */
  parent?: Maybe<HierarchicalContentNodeToParentContentNodeConnectionEdge>;
  /** Database id of the parent node */
  parentDatabaseId?: Maybe<Scalars['Int']>;
  /** The globally unique identifier of the parent node. */
  parentId?: Maybe<Scalars['ID']>;
  /** Connection between the page type and the page type */
  preview?: Maybe<PageToPreviewConnectionEdge>;
  /** The database id of the preview node */
  previewRevisionDatabaseId?: Maybe<Scalars['Int']>;
  /** Whether the object is a node in the preview state */
  previewRevisionId?: Maybe<Scalars['ID']>;
  /** If the current node is a revision, this field exposes the node this is a revision of. Returns null if the node is not a revision of another node. */
  revisionOf?: Maybe<NodeWithRevisionsToContentNodeConnectionEdge>;
  /** Connection between the page type and the page type */
  revisions?: Maybe<PageToRevisionConnection>;
  /** The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table. */
  slug?: Maybe<Scalars['String']>;
  /** The current status of the object */
  status?: Maybe<Scalars['String']>;
  /** The template assigned to a node of content */
  template?: Maybe<ContentTemplate>;
  /** The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made. */
  title?: Maybe<Scalars['String']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** The page type */
export type PageAncestorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<HierarchicalContentNodeToContentNodeAncestorsConnectionWhereArgs>;
};


/** The page type */
export type PageChildrenArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<HierarchicalContentNodeToContentNodeChildrenConnectionWhereArgs>;
};


/** The page type */
export type PageCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PageToCommentConnectionWhereArgs>;
};


/** The page type */
export type PageContentArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};


/** The page type */
export type PageEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The page type */
export type PageEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The page type */
export type PageRevisionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PageToRevisionConnectionWhereArgs>;
};


/** The page type */
export type PageTitleArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum PageIdType {
  /** Identify a resource by the Database ID. */
  DatabaseId = 'DATABASE_ID',
  /** Identify a resource by the (hashed) Global ID. */
  Id = 'ID',
  /** Identify a resource by the URI. */
  Uri = 'URI'
}

/** Connection between the page type and the Comment type */
export type PageToCommentConnection = {
  __typename?: 'PageToCommentConnection';
  /** Edges for the PageToCommentConnection connection */
  edges?: Maybe<Array<Maybe<PageToCommentConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Comment>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type PageToCommentConnectionEdge = {
  __typename?: 'PageToCommentConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Comment>;
};

/** Arguments for filtering the PageToCommentConnection connection */
export type PageToCommentConnectionWhereArgs = {
  /** Comment author email address. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** Array of author IDs to include comments for. */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to exclude comments for. */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Comment author URL. */
  authorUrl?: InputMaybe<Scalars['String']>;
  /** Array of comment IDs to include. */
  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */
  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Include comments of a given type. */
  commentType?: InputMaybe<Scalars['String']>;
  /** Include comments from a given array of comment types. */
  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Exclude comments from a given array of comment types. */
  commentTypeNotIn?: InputMaybe<Scalars['String']>;
  /** Content object author ID to limit results by. */
  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to retrieve comments for. */
  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs *not* to retrieve comments for. */
  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Limit results to those affiliated with a given content object ID. */
  contentId?: InputMaybe<Scalars['ID']>;
  /** Array of content object IDs to include affiliated comments for. */
  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of content object IDs to exclude affiliated comments for. */
  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Content object name to retrieve affiliated comments for. */
  contentName?: InputMaybe<Scalars['String']>;
  /** Content Object parent ID to retrieve affiliated comments for. */
  contentParent?: InputMaybe<Scalars['Int']>;
  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */
  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Karma score to retrieve matching comments for. */
  karma?: InputMaybe<Scalars['Int']>;
  /** The cardinality of the order of the connection */
  order?: InputMaybe<OrderEnum>;
  /** Field to order the comments by. */
  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;
  /** Parent ID of comment to retrieve children of. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Array of parent IDs of comments to retrieve children for. */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of parent IDs of comments *not* to retrieve children for. */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Search term(s) to retrieve matching comments for. */
  search?: InputMaybe<Scalars['String']>;
  /** Comment status to limit results by. */
  status?: InputMaybe<Scalars['String']>;
  /** Include comments for a specific user ID. */
  userId?: InputMaybe<Scalars['ID']>;
};

/** Connection between the page type and the page type */
export type PageToPreviewConnectionEdge = {
  __typename?: 'PageToPreviewConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Page>;
};

/** Connection between the page type and the page type */
export type PageToRevisionConnection = {
  __typename?: 'PageToRevisionConnection';
  /** Edges for the pageToRevisionConnection connection */
  edges?: Maybe<Array<Maybe<PageToRevisionConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Page>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type PageToRevisionConnectionEdge = {
  __typename?: 'PageToRevisionConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Page>;
};

/** Arguments for filtering the pageToRevisionConnection connection */
export type PageToRevisionConnectionWhereArgs = {
  /** The user that's connected as the author of the object. Use the userId for the author object. */
  author?: InputMaybe<Scalars['Int']>;
  /** Find objects connected to author(s) in the array of author's userIds */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Find objects connected to the author by the author's nicename */
  authorName?: InputMaybe<Scalars['String']>;
  /** Find objects NOT connected to author(s) in the array of author's userIds */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

export type Paging = {
  page?: InputMaybe<Scalars['Int']>;
  perPage?: InputMaybe<Scalars['Int']>;
};

export enum PaymentMethod {
  Cc = 'CC',
  Invoice = 'INVOICE'
}

export type PlanObject = {
  __typename?: 'PlanObject';
  active?: Maybe<Scalars['Boolean']>;
  billingInterval?: Maybe<Scalars['String']>;
  currency?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  productName?: Maybe<Scalars['String']>;
  unitAmount?: Maybe<Scalars['Int']>;
};

export type PlansCreateInput = {
  amount: Scalars['Int'];
  currency: Scalars['String'];
  name: Scalars['String'];
  recurring_count: Scalars['Int'];
  recurring_type: BillingInterval;
  trial_count: Scalars['Int'];
  trial_type: BillingInterval;
};

export type PlansCreateResult = {
  __typename?: 'PlansCreateResult';
  id: Scalars['String'];
};

/** An plugin object */
export type Plugin = Node & {
  __typename?: 'Plugin';
  /** Name of the plugin author(s), may also be a company name. */
  author?: Maybe<Scalars['String']>;
  /** URI for the related author(s)/company website. */
  authorUri?: Maybe<Scalars['String']>;
  /** Description of the plugin. */
  description?: Maybe<Scalars['String']>;
  /** The globally unique identifier of the plugin object. */
  id: Scalars['ID'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Display name of the plugin. */
  name?: Maybe<Scalars['String']>;
  /** Plugin path. */
  path?: Maybe<Scalars['String']>;
  /** URI for the plugin website. This is useful for directing users for support requests etc. */
  pluginUri?: Maybe<Scalars['String']>;
  /** Current version of the plugin. */
  version?: Maybe<Scalars['String']>;
};

/** The status of the WordPress plugin. */
export enum PluginStatusEnum {
  /** The plugin is currently active. */
  Active = 'ACTIVE',
  /** The plugin is a drop-in plugin. */
  DropIn = 'DROP_IN',
  /** The plugin is currently inactive. */
  Inactive = 'INACTIVE',
  /** The plugin is a must-use plugin. */
  MustUse = 'MUST_USE',
  /** The plugin is technically active but was paused while loading. */
  Paused = 'PAUSED',
  /** The plugin was active recently. */
  RecentlyActive = 'RECENTLY_ACTIVE',
  /** The plugin has an upgrade available. */
  Upgrade = 'UPGRADE'
}

export type Podcast = {
  __typename?: 'Podcast';
  author: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  episodeNumber: Scalars['Int'];
  id: Scalars['String'];
  mediaUrl: Scalars['String'];
  name: Scalars['String'];
  publishedDate: Scalars['String'];
  thumbnail: Scalars['String'];
};

export type PodcastPayload = {
  __typename?: 'PodcastPayload';
  podcast?: Maybe<Podcast>;
};

export type PodcastsInput = {
  order?: InputMaybe<Ordering>;
  paging?: InputMaybe<Paging>;
  term?: InputMaybe<Scalars['String']>;
};

export type PodcastsPayload = {
  __typename?: 'PodcastsPayload';
  records: Array<Podcast>;
  total: Scalars['Int'];
};

/** The post type */
export type Post = ContentNode & DatabaseIdentifier & MenuItemLinkable & Node & NodeWithAuthor & NodeWithComments & NodeWithContentEditor & NodeWithExcerpt & NodeWithFeaturedImage & NodeWithRevisions & NodeWithTemplate & NodeWithTitle & NodeWithTrackbacks & UniformResourceIdentifiable & {
  __typename?: 'Post';
  /** Connection between the NodeWithAuthor type and the User type */
  author?: Maybe<NodeWithAuthorToUserConnectionEdge>;
  /** The database identifier of the author of the node */
  authorDatabaseId?: Maybe<Scalars['Int']>;
  /** The globally unique identifier of the author of the node */
  authorId?: Maybe<Scalars['ID']>;
  /** Connection between the post type and the category type */
  categories?: Maybe<PostToCategoryConnection>;
  /** The number of comments. Even though WPGraphQL denotes this field as an integer, in WordPress this field should be saved as a numeric string for compatibility. */
  commentCount?: Maybe<Scalars['Int']>;
  /** Whether the comments are open or closed for this particular post. */
  commentStatus?: Maybe<Scalars['String']>;
  /** Connection between the post type and the Comment type */
  comments?: Maybe<PostToCommentConnection>;
  /** The content of the post. */
  content?: Maybe<Scalars['String']>;
  /** Connection between the ContentNode type and the ContentType type */
  contentType?: Maybe<ContentNodeToContentTypeConnectionEdge>;
  /** The name of the Content Type the node belongs to */
  contentTypeName: Scalars['String'];
  /** Added to the GraphQL Schema because the ACF Field Group &quot;Author (Hub)&quot; was set to Show in GraphQL. */
  customAuthor?: Maybe<Post_Customauthor>;
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** Post publishing date. */
  date?: Maybe<Scalars['String']>;
  /** The publishing date set in GMT. */
  dateGmt?: Maybe<Scalars['String']>;
  /** The desired slug of the post */
  desiredSlug?: Maybe<Scalars['String']>;
  /** If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds */
  editingLockedBy?: Maybe<ContentNodeToEditLockConnectionEdge>;
  /** The RSS enclosure for the object */
  enclosure?: Maybe<Scalars['String']>;
  /** Connection between the ContentNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<ContentNodeToEnqueuedScriptConnection>;
  /** Connection between the ContentNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<ContentNodeToEnqueuedStylesheetConnection>;
  /** The excerpt of the post. */
  excerpt?: Maybe<Scalars['String']>;
  /** Connection between the NodeWithFeaturedImage type and the MediaItem type */
  featuredImage?: Maybe<NodeWithFeaturedImageToMediaItemConnectionEdge>;
  /** The database identifier for the featured image node assigned to the content node */
  featuredImageDatabaseId?: Maybe<Scalars['Int']>;
  /** Globally unique ID of the featured image assigned to the node */
  featuredImageId?: Maybe<Scalars['ID']>;
  /** The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table. */
  guid?: Maybe<Scalars['String']>;
  /** The globally unique identifier of the post object. */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is a node in the preview state */
  isPreview?: Maybe<Scalars['Boolean']>;
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** True if the node is a revision of another node */
  isRevision?: Maybe<Scalars['Boolean']>;
  /** Whether this page is sticky */
  isSticky: Scalars['Boolean'];
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The user that most recently edited the node */
  lastEditedBy?: Maybe<ContentNodeToEditLastConnectionEdge>;
  /** The permalink of the post */
  link?: Maybe<Scalars['String']>;
  /** The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time. */
  modified?: Maybe<Scalars['String']>;
  /** The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT. */
  modifiedGmt?: Maybe<Scalars['String']>;
  /** Whether the pings are open or closed for this particular post. */
  pingStatus?: Maybe<Scalars['String']>;
  /** URLs that have been pinged. */
  pinged?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Connection between the post type and the postFormat type */
  postFormats?: Maybe<PostToPostFormatConnection>;
  /** The id field matches the WP_Post-&gt;ID field. */
  postId: Scalars['Int'];
  /** Connection between the post type and the post type */
  preview?: Maybe<PostToPreviewConnectionEdge>;
  /** The database id of the preview node */
  previewRevisionDatabaseId?: Maybe<Scalars['Int']>;
  /** Whether the object is a node in the preview state */
  previewRevisionId?: Maybe<Scalars['ID']>;
  /** If the current node is a revision, this field exposes the node this is a revision of. Returns null if the node is not a revision of another node. */
  revisionOf?: Maybe<NodeWithRevisionsToContentNodeConnectionEdge>;
  /** Connection between the post type and the post type */
  revisions?: Maybe<PostToRevisionConnection>;
  /** The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table. */
  slug?: Maybe<Scalars['String']>;
  /** The current status of the object */
  status?: Maybe<Scalars['String']>;
  /** Connection between the post type and the tag type */
  tags?: Maybe<PostToTagConnection>;
  /** The template assigned to a node of content */
  template?: Maybe<ContentTemplate>;
  /** Connection between the post type and the TermNode type */
  terms?: Maybe<PostToTermNodeConnection>;
  /** The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made. */
  title?: Maybe<Scalars['String']>;
  /** URLs queued to be pinged. */
  toPing?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** The post type */
export type PostCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PostToCategoryConnectionWhereArgs>;
};


/** The post type */
export type PostCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PostToCommentConnectionWhereArgs>;
};


/** The post type */
export type PostContentArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};


/** The post type */
export type PostEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The post type */
export type PostEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The post type */
export type PostExcerptArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};


/** The post type */
export type PostPostFormatsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PostToPostFormatConnectionWhereArgs>;
};


/** The post type */
export type PostRevisionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PostToRevisionConnectionWhereArgs>;
};


/** The post type */
export type PostTagsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PostToTagConnectionWhereArgs>;
};


/** The post type */
export type PostTermsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PostToTermNodeConnectionWhereArgs>;
};


/** The post type */
export type PostTitleArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};

/** Set relationships between the post to categories */
export type PostCategoriesInput = {
  /** If true, this will append the category to existing related categories. If false, this will replace existing relationships. Default true. */
  append?: InputMaybe<Scalars['Boolean']>;
  /** The input list of items to set. */
  nodes?: InputMaybe<Array<InputMaybe<PostCategoriesNodeInput>>>;
};

/** List of categories to connect the post to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */
export type PostCategoriesNodeInput = {
  /** The description of the category. This field is used to set a description of the category if a new one is created during the mutation. */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the category. If present, this will be used to connect to the post. If no existing category exists with this ID, no connection will be made. */
  id?: InputMaybe<Scalars['ID']>;
  /** The name of the category. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */
  name?: InputMaybe<Scalars['String']>;
  /** The slug of the category. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The postFormat type */
export type PostFormat = DatabaseIdentifier & MenuItemLinkable & Node & TermNode & UniformResourceIdentifiable & {
  __typename?: 'PostFormat';
  /** Connection between the postFormat type and the ContentNode type */
  contentNodes?: Maybe<PostFormatToContentNodeConnection>;
  /** The number of objects connected to the object */
  count?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** The description of the object */
  description?: Maybe<Scalars['String']>;
  /** Connection between the TermNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<TermNodeToEnqueuedScriptConnection>;
  /** Connection between the TermNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<TermNodeToEnqueuedStylesheetConnection>;
  /** The unique resource identifier path */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The link to the term */
  link?: Maybe<Scalars['String']>;
  /** The human friendly name of the object. */
  name?: Maybe<Scalars['String']>;
  /** The id field matches the WP_Post-&gt;ID field. */
  postFormatId?: Maybe<Scalars['Int']>;
  /** Connection between the postFormat type and the post type */
  posts?: Maybe<PostFormatToPostConnection>;
  /** An alphanumeric identifier for the object unique to its type. */
  slug?: Maybe<Scalars['String']>;
  /** Connection between the postFormat type and the Taxonomy type */
  taxonomy?: Maybe<PostFormatToTaxonomyConnectionEdge>;
  /** The name of the taxonomy that the object is associated with */
  taxonomyName?: Maybe<Scalars['String']>;
  /** The ID of the term group that this term object belongs to */
  termGroupId?: Maybe<Scalars['Int']>;
  /** The taxonomy ID that the object is associated with */
  termTaxonomyId?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** The postFormat type */
export type PostFormatContentNodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PostFormatToContentNodeConnectionWhereArgs>;
};


/** The postFormat type */
export type PostFormatEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The postFormat type */
export type PostFormatEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The postFormat type */
export type PostFormatPostsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PostFormatToPostConnectionWhereArgs>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum PostFormatIdType {
  /** The Database ID for the node */
  DatabaseId = 'DATABASE_ID',
  /** The hashed Global ID */
  Id = 'ID',
  /** The name of the node */
  Name = 'NAME',
  /** Url friendly name of the node */
  Slug = 'SLUG',
  /** The URI for the node */
  Uri = 'URI'
}

/** Connection between the postFormat type and the ContentNode type */
export type PostFormatToContentNodeConnection = {
  __typename?: 'PostFormatToContentNodeConnection';
  /** Edges for the PostFormatToContentNodeConnection connection */
  edges?: Maybe<Array<Maybe<PostFormatToContentNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type PostFormatToContentNodeConnectionEdge = {
  __typename?: 'PostFormatToContentNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentNode>;
};

/** Arguments for filtering the PostFormatToContentNodeConnection connection */
export type PostFormatToContentNodeConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfPostFormatEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the postFormat type and the post type */
export type PostFormatToPostConnection = {
  __typename?: 'PostFormatToPostConnection';
  /** Edges for the PostFormatToPostConnection connection */
  edges?: Maybe<Array<Maybe<PostFormatToPostConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Post>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type PostFormatToPostConnectionEdge = {
  __typename?: 'PostFormatToPostConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Post>;
};

/** Arguments for filtering the PostFormatToPostConnection connection */
export type PostFormatToPostConnectionWhereArgs = {
  /** The user that's connected as the author of the object. Use the userId for the author object. */
  author?: InputMaybe<Scalars['Int']>;
  /** Find objects connected to author(s) in the array of author's userIds */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Find objects connected to the author by the author's nicename */
  authorName?: InputMaybe<Scalars['String']>;
  /** Find objects NOT connected to author(s) in the array of author's userIds */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Category ID */
  categoryId?: InputMaybe<Scalars['Int']>;
  /** Array of category IDs, used to display objects from one category OR another */
  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Use Category Slug */
  categoryName?: InputMaybe<Scalars['String']>;
  /** Array of category IDs, used to display objects from one category OR another */
  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Tag Slug */
  tag?: InputMaybe<Scalars['String']>;
  /** Use Tag ID */
  tagId?: InputMaybe<Scalars['String']>;
  /** Array of tag IDs, used to display objects from one tag OR another */
  tagIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of tag IDs, used to display objects from one tag OR another */
  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of tag slugs, used to display objects from one tag OR another */
  tagSlugAnd?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of tag slugs, used to exclude objects in specified tags */
  tagSlugIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the postFormat type and the Taxonomy type */
export type PostFormatToTaxonomyConnectionEdge = {
  __typename?: 'PostFormatToTaxonomyConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Taxonomy>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum PostIdType {
  /** Identify a resource by the Database ID. */
  DatabaseId = 'DATABASE_ID',
  /** Identify a resource by the (hashed) Global ID. */
  Id = 'ID',
  /** Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier. */
  Slug = 'SLUG',
  /** Identify a resource by the URI. */
  Uri = 'URI'
}

/** The format of post field data. */
export enum PostObjectFieldFormatEnum {
  /** Provide the field value directly from database. Null on unauthenticated requests. */
  Raw = 'RAW',
  /** Provide the field value as rendered by WordPress. Default. */
  Rendered = 'RENDERED'
}

/** The column to use when filtering by date */
export enum PostObjectsConnectionDateColumnEnum {
  /** The date the comment was created in local time. */
  Date = 'DATE',
  /** The most recent modification date of the comment. */
  Modified = 'MODIFIED'
}

/** Field to order the connection by */
export enum PostObjectsConnectionOrderbyEnum {
  /** Order by author */
  Author = 'AUTHOR',
  /** Order by the number of comments it has acquired */
  CommentCount = 'COMMENT_COUNT',
  /** Order by publish date */
  Date = 'DATE',
  /** Preserve the ID order given in the IN array */
  In = 'IN',
  /** Order by the menu order value */
  MenuOrder = 'MENU_ORDER',
  /** Order by last modified date */
  Modified = 'MODIFIED',
  /** Preserve slug order given in the NAME_IN array */
  NameIn = 'NAME_IN',
  /** Order by parent ID */
  Parent = 'PARENT',
  /** Order by slug */
  Slug = 'SLUG',
  /** Order by title */
  Title = 'TITLE'
}

/** Options for ordering the connection */
export type PostObjectsConnectionOrderbyInput = {
  /** The field to order the connection by */
  field: PostObjectsConnectionOrderbyEnum;
  /** Possible directions in which to order a list of items */
  order: OrderEnum;
};

/** Set relationships between the post to postFormats */
export type PostPostFormatsInput = {
  /** If true, this will append the postFormat to existing related postFormats. If false, this will replace existing relationships. Default true. */
  append?: InputMaybe<Scalars['Boolean']>;
  /** The input list of items to set. */
  nodes?: InputMaybe<Array<InputMaybe<PostPostFormatsNodeInput>>>;
};

/** List of postFormats to connect the post to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */
export type PostPostFormatsNodeInput = {
  /** The description of the postFormat. This field is used to set a description of the postFormat if a new one is created during the mutation. */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the postFormat. If present, this will be used to connect to the post. If no existing postFormat exists with this ID, no connection will be made. */
  id?: InputMaybe<Scalars['ID']>;
  /** The name of the postFormat. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */
  name?: InputMaybe<Scalars['String']>;
  /** The slug of the postFormat. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The status of the object. */
export enum PostStatusEnum {
  /** Objects with the acf-disabled status */
  AcfDisabled = 'ACF_DISABLED',
  /** Objects with the auto-draft status */
  AutoDraft = 'AUTO_DRAFT',
  /** Objects with the draft status */
  Draft = 'DRAFT',
  /** Objects with the future status */
  Future = 'FUTURE',
  /** Objects with the inherit status */
  Inherit = 'INHERIT',
  /** Objects with the pending status */
  Pending = 'PENDING',
  /** Objects with the private status */
  Private = 'PRIVATE',
  /** Objects with the publish status */
  Publish = 'PUBLISH',
  /** Objects with the request-completed status */
  RequestCompleted = 'REQUEST_COMPLETED',
  /** Objects with the request-confirmed status */
  RequestConfirmed = 'REQUEST_CONFIRMED',
  /** Objects with the request-failed status */
  RequestFailed = 'REQUEST_FAILED',
  /** Objects with the request-pending status */
  RequestPending = 'REQUEST_PENDING',
  /** Objects with the trash status */
  Trash = 'TRASH'
}

/** Set relationships between the post to tags */
export type PostTagsInput = {
  /** If true, this will append the tag to existing related tags. If false, this will replace existing relationships. Default true. */
  append?: InputMaybe<Scalars['Boolean']>;
  /** The input list of items to set. */
  nodes?: InputMaybe<Array<InputMaybe<PostTagsNodeInput>>>;
};

/** List of tags to connect the post to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */
export type PostTagsNodeInput = {
  /** The description of the tag. This field is used to set a description of the tag if a new one is created during the mutation. */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the tag. If present, this will be used to connect to the post. If no existing tag exists with this ID, no connection will be made. */
  id?: InputMaybe<Scalars['ID']>;
  /** The name of the tag. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */
  name?: InputMaybe<Scalars['String']>;
  /** The slug of the tag. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */
  slug?: InputMaybe<Scalars['String']>;
};

/** Connection between the post type and the category type */
export type PostToCategoryConnection = {
  __typename?: 'PostToCategoryConnection';
  /** Edges for the PostToCategoryConnection connection */
  edges?: Maybe<Array<Maybe<PostToCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Category>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type PostToCategoryConnectionEdge = {
  __typename?: 'PostToCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Category>;
};

/** Arguments for filtering the PostToCategoryConnection connection */
export type PostToCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the post type and the Comment type */
export type PostToCommentConnection = {
  __typename?: 'PostToCommentConnection';
  /** Edges for the PostToCommentConnection connection */
  edges?: Maybe<Array<Maybe<PostToCommentConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Comment>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type PostToCommentConnectionEdge = {
  __typename?: 'PostToCommentConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Comment>;
};

/** Arguments for filtering the PostToCommentConnection connection */
export type PostToCommentConnectionWhereArgs = {
  /** Comment author email address. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** Array of author IDs to include comments for. */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to exclude comments for. */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Comment author URL. */
  authorUrl?: InputMaybe<Scalars['String']>;
  /** Array of comment IDs to include. */
  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */
  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Include comments of a given type. */
  commentType?: InputMaybe<Scalars['String']>;
  /** Include comments from a given array of comment types. */
  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Exclude comments from a given array of comment types. */
  commentTypeNotIn?: InputMaybe<Scalars['String']>;
  /** Content object author ID to limit results by. */
  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to retrieve comments for. */
  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs *not* to retrieve comments for. */
  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Limit results to those affiliated with a given content object ID. */
  contentId?: InputMaybe<Scalars['ID']>;
  /** Array of content object IDs to include affiliated comments for. */
  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of content object IDs to exclude affiliated comments for. */
  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Content object name to retrieve affiliated comments for. */
  contentName?: InputMaybe<Scalars['String']>;
  /** Content Object parent ID to retrieve affiliated comments for. */
  contentParent?: InputMaybe<Scalars['Int']>;
  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */
  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Karma score to retrieve matching comments for. */
  karma?: InputMaybe<Scalars['Int']>;
  /** The cardinality of the order of the connection */
  order?: InputMaybe<OrderEnum>;
  /** Field to order the comments by. */
  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;
  /** Parent ID of comment to retrieve children of. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Array of parent IDs of comments to retrieve children for. */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of parent IDs of comments *not* to retrieve children for. */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Search term(s) to retrieve matching comments for. */
  search?: InputMaybe<Scalars['String']>;
  /** Comment status to limit results by. */
  status?: InputMaybe<Scalars['String']>;
  /** Include comments for a specific user ID. */
  userId?: InputMaybe<Scalars['ID']>;
};

/** Connection between the post type and the postFormat type */
export type PostToPostFormatConnection = {
  __typename?: 'PostToPostFormatConnection';
  /** Edges for the PostToPostFormatConnection connection */
  edges?: Maybe<Array<Maybe<PostToPostFormatConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<PostFormat>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type PostToPostFormatConnectionEdge = {
  __typename?: 'PostToPostFormatConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<PostFormat>;
};

/** Arguments for filtering the PostToPostFormatConnection connection */
export type PostToPostFormatConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the post type and the post type */
export type PostToPreviewConnectionEdge = {
  __typename?: 'PostToPreviewConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Post>;
};

/** Connection between the post type and the post type */
export type PostToRevisionConnection = {
  __typename?: 'PostToRevisionConnection';
  /** Edges for the postToRevisionConnection connection */
  edges?: Maybe<Array<Maybe<PostToRevisionConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Post>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type PostToRevisionConnectionEdge = {
  __typename?: 'PostToRevisionConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Post>;
};

/** Arguments for filtering the postToRevisionConnection connection */
export type PostToRevisionConnectionWhereArgs = {
  /** The user that's connected as the author of the object. Use the userId for the author object. */
  author?: InputMaybe<Scalars['Int']>;
  /** Find objects connected to author(s) in the array of author's userIds */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Find objects connected to the author by the author's nicename */
  authorName?: InputMaybe<Scalars['String']>;
  /** Find objects NOT connected to author(s) in the array of author's userIds */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Category ID */
  categoryId?: InputMaybe<Scalars['Int']>;
  /** Array of category IDs, used to display objects from one category OR another */
  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Use Category Slug */
  categoryName?: InputMaybe<Scalars['String']>;
  /** Array of category IDs, used to display objects from one category OR another */
  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Tag Slug */
  tag?: InputMaybe<Scalars['String']>;
  /** Use Tag ID */
  tagId?: InputMaybe<Scalars['String']>;
  /** Array of tag IDs, used to display objects from one tag OR another */
  tagIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of tag IDs, used to display objects from one tag OR another */
  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of tag slugs, used to display objects from one tag OR another */
  tagSlugAnd?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of tag slugs, used to exclude objects in specified tags */
  tagSlugIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the post type and the tag type */
export type PostToTagConnection = {
  __typename?: 'PostToTagConnection';
  /** Edges for the PostToTagConnection connection */
  edges?: Maybe<Array<Maybe<PostToTagConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Tag>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type PostToTagConnectionEdge = {
  __typename?: 'PostToTagConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Tag>;
};

/** Arguments for filtering the PostToTagConnection connection */
export type PostToTagConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the post type and the TermNode type */
export type PostToTermNodeConnection = {
  __typename?: 'PostToTermNodeConnection';
  /** Edges for the PostToTermNodeConnection connection */
  edges?: Maybe<Array<Maybe<PostToTermNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<TermNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type PostToTermNodeConnectionEdge = {
  __typename?: 'PostToTermNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<TermNode>;
};

/** Arguments for filtering the PostToTermNodeConnection connection */
export type PostToTermNodeConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** The Taxonomy to filter terms by */
  taxonomies?: InputMaybe<Array<InputMaybe<TaxonomyEnum>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Details for labels of the PostType */
export type PostTypeLabelDetails = {
  __typename?: 'PostTypeLabelDetails';
  /** Default is Add New for both hierarchical and non-hierarchical types. */
  addNew?: Maybe<Scalars['String']>;
  /** Label for adding a new singular item. */
  addNewItem?: Maybe<Scalars['String']>;
  /** Label to signify all items in a submenu link. */
  allItems?: Maybe<Scalars['String']>;
  /** Label for archives in nav menus */
  archives?: Maybe<Scalars['String']>;
  /** Label for the attributes meta box. */
  attributes?: Maybe<Scalars['String']>;
  /** Label for editing a singular item. */
  editItem?: Maybe<Scalars['String']>;
  /** Label for the Featured Image meta box title. */
  featuredImage?: Maybe<Scalars['String']>;
  /** Label for the table views hidden heading. */
  filterItemsList?: Maybe<Scalars['String']>;
  /** Label for the media frame button. */
  insertIntoItem?: Maybe<Scalars['String']>;
  /** Label for the table hidden heading. */
  itemsList?: Maybe<Scalars['String']>;
  /** Label for the table pagination hidden heading. */
  itemsListNavigation?: Maybe<Scalars['String']>;
  /** Label for the menu name. */
  menuName?: Maybe<Scalars['String']>;
  /** General name for the post type, usually plural. */
  name?: Maybe<Scalars['String']>;
  /** Label for the new item page title. */
  newItem?: Maybe<Scalars['String']>;
  /** Label used when no items are found. */
  notFound?: Maybe<Scalars['String']>;
  /** Label used when no items are in the trash. */
  notFoundInTrash?: Maybe<Scalars['String']>;
  /** Label used to prefix parents of hierarchical items. */
  parentItemColon?: Maybe<Scalars['String']>;
  /** Label for removing the featured image. */
  removeFeaturedImage?: Maybe<Scalars['String']>;
  /** Label for searching plural items. */
  searchItems?: Maybe<Scalars['String']>;
  /** Label for setting the featured image. */
  setFeaturedImage?: Maybe<Scalars['String']>;
  /** Name for one object of this post type. */
  singularName?: Maybe<Scalars['String']>;
  /** Label for the media frame filter. */
  uploadedToThisItem?: Maybe<Scalars['String']>;
  /** Label in the media frame for using a featured image. */
  useFeaturedImage?: Maybe<Scalars['String']>;
  /** Label for viewing a singular item. */
  viewItem?: Maybe<Scalars['String']>;
  /** Label for viewing post type archives. */
  viewItems?: Maybe<Scalars['String']>;
};

/** Field Group */
export type Post_Customauthor = AcfFieldGroup & {
  __typename?: 'Post_Customauthor';
  authorName?: Maybe<Scalars['String']>;
  displayAuthor?: Maybe<Scalars['Boolean']>;
  /** The name of the ACF Field Group */
  fieldGroupName?: Maybe<Scalars['String']>;
};

export type PromoCodeOutput = {
  __typename?: 'PromoCodeOutput';
  amount: Scalars['Int'];
  code: Scalars['String'];
  type: Scalars['String'];
};

/** The reading setting type */
export type ReadingSettings = {
  __typename?: 'ReadingSettings';
  /** The ID of the page that should display the latest posts */
  pageForPosts?: Maybe<Scalars['Int']>;
  /** The ID of the page that should be displayed on the front page */
  pageOnFront?: Maybe<Scalars['Int']>;
  /** Blog pages show at most. */
  postsPerPage?: Maybe<Scalars['Int']>;
  /** What to show on the front page */
  showOnFront?: Maybe<Scalars['String']>;
};

/** Input for the registerUser mutation */
export type RegisterUserInput = {
  /** User's AOL IM account. */
  aim?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A string containing content about the user. */
  description?: InputMaybe<Scalars['String']>;
  /** A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user). */
  displayName?: InputMaybe<Scalars['String']>;
  /** A string containing the user's email address. */
  email?: InputMaybe<Scalars['String']>;
  /** 	The user's first name. */
  firstName?: InputMaybe<Scalars['String']>;
  /** User's Jabber account. */
  jabber?: InputMaybe<Scalars['String']>;
  /** The user's last name. */
  lastName?: InputMaybe<Scalars['String']>;
  /** User's locale. */
  locale?: InputMaybe<Scalars['String']>;
  /** A string that contains a URL-friendly name for the user. The default is the user's username. */
  nicename?: InputMaybe<Scalars['String']>;
  /** The user's nickname, defaults to the user's username. */
  nickname?: InputMaybe<Scalars['String']>;
  /** A string that contains the plain text password for the user. */
  password?: InputMaybe<Scalars['String']>;
  /** The date the user registered. Format is Y-m-d H:i:s. */
  registered?: InputMaybe<Scalars['String']>;
  /** A string for whether to enable the rich editor or not. False if not empty. */
  richEditing?: InputMaybe<Scalars['String']>;
  /** A string that contains the user's username. */
  username: Scalars['String'];
  /** A string containing the user's URL for the user's web site. */
  websiteUrl?: InputMaybe<Scalars['String']>;
  /** User's Yahoo IM account. */
  yim?: InputMaybe<Scalars['String']>;
};

/** The payload for the registerUser mutation */
export type RegisterUserPayload = {
  __typename?: 'RegisterUserPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The User object mutation type. */
  user?: Maybe<User>;
};

/** The logical relation between each item in the array when there are more than one. */
export enum RelationEnum {
  /** The logical AND condition returns true if both operands are true, otherwise, it returns false. */
  And = 'AND',
  /** The logical OR condition returns false if both operands are false, otherwise, it returns true. */
  Or = 'OR'
}

export enum ReplaceParticipantError {
  GenericError = 'GENERIC_ERROR',
  InvalidEmail = 'INVALID_EMAIL',
  NotAuthorized = 'NOT_AUTHORIZED',
  NoParticipant = 'NO_PARTICIPANT'
}

export type ReplaceParticipantInput = {
  inviteeEmail: Scalars['String'];
  inviteeFirstName: Scalars['String'];
  inviteeLastName: Scalars['String'];
  participantId: Scalars['uuid'];
};

export type ReplaceParticipantOutput = {
  __typename?: 'ReplaceParticipantOutput';
  error?: Maybe<ReplaceParticipantError>;
  success: Scalars['Boolean'];
};

/** The ResearchSummariesCategory type */
export type ResearchSummariesCategory = DatabaseIdentifier & MenuItemLinkable & Node & TermNode & UniformResourceIdentifiable & {
  __typename?: 'ResearchSummariesCategory';
  /** Connection between the ResearchSummariesCategory type and the ContentNode type */
  contentNodes?: Maybe<ResearchSummariesCategoryToContentNodeConnection>;
  /** The number of objects connected to the object */
  count?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** The description of the object */
  description?: Maybe<Scalars['String']>;
  /** Connection between the TermNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<TermNodeToEnqueuedScriptConnection>;
  /** Connection between the TermNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<TermNodeToEnqueuedStylesheetConnection>;
  /** The unique resource identifier path */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The link to the term */
  link?: Maybe<Scalars['String']>;
  /** The human friendly name of the object. */
  name?: Maybe<Scalars['String']>;
  /** Connection between the ResearchSummariesCategory type and the ResearchSummary type */
  researchSummaries?: Maybe<ResearchSummariesCategoryToResearchSummaryConnection>;
  /** The id field matches the WP_Post-&gt;ID field. */
  researchSummariesCategoryId?: Maybe<Scalars['Int']>;
  /** An alphanumeric identifier for the object unique to its type. */
  slug?: Maybe<Scalars['String']>;
  /** Connection between the ResearchSummariesCategory type and the Taxonomy type */
  taxonomy?: Maybe<ResearchSummariesCategoryToTaxonomyConnectionEdge>;
  /** The name of the taxonomy that the object is associated with */
  taxonomyName?: Maybe<Scalars['String']>;
  /** The ID of the term group that this term object belongs to */
  termGroupId?: Maybe<Scalars['Int']>;
  /** The taxonomy ID that the object is associated with */
  termTaxonomyId?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** The ResearchSummariesCategory type */
export type ResearchSummariesCategoryContentNodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ResearchSummariesCategoryToContentNodeConnectionWhereArgs>;
};


/** The ResearchSummariesCategory type */
export type ResearchSummariesCategoryEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The ResearchSummariesCategory type */
export type ResearchSummariesCategoryEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The ResearchSummariesCategory type */
export type ResearchSummariesCategoryResearchSummariesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ResearchSummariesCategoryToResearchSummaryConnectionWhereArgs>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum ResearchSummariesCategoryIdType {
  /** The Database ID for the node */
  DatabaseId = 'DATABASE_ID',
  /** The hashed Global ID */
  Id = 'ID',
  /** The name of the node */
  Name = 'NAME',
  /** Url friendly name of the node */
  Slug = 'SLUG',
  /** The URI for the node */
  Uri = 'URI'
}

/** Connection between the ResearchSummariesCategory type and the ContentNode type */
export type ResearchSummariesCategoryToContentNodeConnection = {
  __typename?: 'ResearchSummariesCategoryToContentNodeConnection';
  /** Edges for the ResearchSummariesCategoryToContentNodeConnection connection */
  edges?: Maybe<Array<Maybe<ResearchSummariesCategoryToContentNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ResearchSummariesCategoryToContentNodeConnectionEdge = {
  __typename?: 'ResearchSummariesCategoryToContentNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentNode>;
};

/** Arguments for filtering the ResearchSummariesCategoryToContentNodeConnection connection */
export type ResearchSummariesCategoryToContentNodeConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfResearchSummariesCategoryEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the ResearchSummariesCategory type and the ResearchSummary type */
export type ResearchSummariesCategoryToResearchSummaryConnection = {
  __typename?: 'ResearchSummariesCategoryToResearchSummaryConnection';
  /** Edges for the ResearchSummariesCategoryToResearchSummaryConnection connection */
  edges?: Maybe<Array<Maybe<ResearchSummariesCategoryToResearchSummaryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ResearchSummary>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ResearchSummariesCategoryToResearchSummaryConnectionEdge = {
  __typename?: 'ResearchSummariesCategoryToResearchSummaryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ResearchSummary>;
};

/** Arguments for filtering the ResearchSummariesCategoryToResearchSummaryConnection connection */
export type ResearchSummariesCategoryToResearchSummaryConnectionWhereArgs = {
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the ResearchSummariesCategory type and the Taxonomy type */
export type ResearchSummariesCategoryToTaxonomyConnectionEdge = {
  __typename?: 'ResearchSummariesCategoryToTaxonomyConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Taxonomy>;
};

/** The ResearchSummary type */
export type ResearchSummary = ContentNode & DatabaseIdentifier & MenuItemLinkable & Node & NodeWithExcerpt & NodeWithFeaturedImage & NodeWithTemplate & NodeWithTitle & UniformResourceIdentifiable & {
  __typename?: 'ResearchSummary';
  /** Connection between the ContentNode type and the ContentType type */
  contentType?: Maybe<ContentNodeToContentTypeConnectionEdge>;
  /** The name of the Content Type the node belongs to */
  contentTypeName: Scalars['String'];
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** Post publishing date. */
  date?: Maybe<Scalars['String']>;
  /** The publishing date set in GMT. */
  dateGmt?: Maybe<Scalars['String']>;
  /** The desired slug of the post */
  desiredSlug?: Maybe<Scalars['String']>;
  /** Added to the GraphQL Schema because the ACF Field Group &quot;Downloads&quot; was set to Show in GraphQL. */
  downloads?: Maybe<ResearchSummary_Downloads>;
  /** If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds */
  editingLockedBy?: Maybe<ContentNodeToEditLockConnectionEdge>;
  /** The RSS enclosure for the object */
  enclosure?: Maybe<Scalars['String']>;
  /** Connection between the ContentNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<ContentNodeToEnqueuedScriptConnection>;
  /** Connection between the ContentNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<ContentNodeToEnqueuedStylesheetConnection>;
  /** The excerpt of the post. */
  excerpt?: Maybe<Scalars['String']>;
  /** Connection between the NodeWithFeaturedImage type and the MediaItem type */
  featuredImage?: Maybe<NodeWithFeaturedImageToMediaItemConnectionEdge>;
  /** The database identifier for the featured image node assigned to the content node */
  featuredImageDatabaseId?: Maybe<Scalars['Int']>;
  /** Globally unique ID of the featured image assigned to the node */
  featuredImageId?: Maybe<Scalars['ID']>;
  /** The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table. */
  guid?: Maybe<Scalars['String']>;
  /** The globally unique identifier of the research-summary object. */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is a node in the preview state */
  isPreview?: Maybe<Scalars['Boolean']>;
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The user that most recently edited the node */
  lastEditedBy?: Maybe<ContentNodeToEditLastConnectionEdge>;
  /** The permalink of the post */
  link?: Maybe<Scalars['String']>;
  /** The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time. */
  modified?: Maybe<Scalars['String']>;
  /** The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT. */
  modifiedGmt?: Maybe<Scalars['String']>;
  /** Connection between the ResearchSummary type and the ResearchSummary type */
  preview?: Maybe<ResearchSummaryToPreviewConnectionEdge>;
  /** The database id of the preview node */
  previewRevisionDatabaseId?: Maybe<Scalars['Int']>;
  /** Whether the object is a node in the preview state */
  previewRevisionId?: Maybe<Scalars['ID']>;
  /** Connection between the ResearchSummary type and the ResearchSummariesCategory type */
  researchSummariesCategories?: Maybe<ResearchSummaryToResearchSummariesCategoryConnection>;
  /** The id field matches the WP_Post-&gt;ID field. */
  researchSummaryId: Scalars['Int'];
  /** The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table. */
  slug?: Maybe<Scalars['String']>;
  /** The current status of the object */
  status?: Maybe<Scalars['String']>;
  /** The template assigned to a node of content */
  template?: Maybe<ContentTemplate>;
  /** Connection between the ResearchSummary type and the TermNode type */
  terms?: Maybe<ResearchSummaryToTermNodeConnection>;
  /** The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made. */
  title?: Maybe<Scalars['String']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** The ResearchSummary type */
export type ResearchSummaryEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The ResearchSummary type */
export type ResearchSummaryEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The ResearchSummary type */
export type ResearchSummaryExcerptArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};


/** The ResearchSummary type */
export type ResearchSummaryResearchSummariesCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ResearchSummaryToResearchSummariesCategoryConnectionWhereArgs>;
};


/** The ResearchSummary type */
export type ResearchSummaryTermsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ResearchSummaryToTermNodeConnectionWhereArgs>;
};


/** The ResearchSummary type */
export type ResearchSummaryTitleArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum ResearchSummaryIdType {
  /** Identify a resource by the Database ID. */
  DatabaseId = 'DATABASE_ID',
  /** Identify a resource by the (hashed) Global ID. */
  Id = 'ID',
  /** Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier. */
  Slug = 'SLUG',
  /** Identify a resource by the URI. */
  Uri = 'URI'
}

/** Set relationships between the ResearchSummary to ResearchSummariesCategories */
export type ResearchSummaryResearchSummariesCategoriesInput = {
  /** If true, this will append the ResearchSummariesCategory to existing related ResearchSummariesCategories. If false, this will replace existing relationships. Default true. */
  append?: InputMaybe<Scalars['Boolean']>;
  /** The input list of items to set. */
  nodes?: InputMaybe<Array<InputMaybe<ResearchSummaryResearchSummariesCategoriesNodeInput>>>;
};

/** List of ResearchSummariesCategories to connect the ResearchSummary to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */
export type ResearchSummaryResearchSummariesCategoriesNodeInput = {
  /** The description of the ResearchSummariesCategory. This field is used to set a description of the ResearchSummariesCategory if a new one is created during the mutation. */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the ResearchSummariesCategory. If present, this will be used to connect to the ResearchSummary. If no existing ResearchSummariesCategory exists with this ID, no connection will be made. */
  id?: InputMaybe<Scalars['ID']>;
  /** The name of the ResearchSummariesCategory. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */
  name?: InputMaybe<Scalars['String']>;
  /** The slug of the ResearchSummariesCategory. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */
  slug?: InputMaybe<Scalars['String']>;
};

/** Connection between the ResearchSummary type and the ResearchSummary type */
export type ResearchSummaryToPreviewConnectionEdge = {
  __typename?: 'ResearchSummaryToPreviewConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<ResearchSummary>;
};

/** Connection between the ResearchSummary type and the ResearchSummariesCategory type */
export type ResearchSummaryToResearchSummariesCategoryConnection = {
  __typename?: 'ResearchSummaryToResearchSummariesCategoryConnection';
  /** Edges for the ResearchSummaryToResearchSummariesCategoryConnection connection */
  edges?: Maybe<Array<Maybe<ResearchSummaryToResearchSummariesCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ResearchSummariesCategory>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ResearchSummaryToResearchSummariesCategoryConnectionEdge = {
  __typename?: 'ResearchSummaryToResearchSummariesCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ResearchSummariesCategory>;
};

/** Arguments for filtering the ResearchSummaryToResearchSummariesCategoryConnection connection */
export type ResearchSummaryToResearchSummariesCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the ResearchSummary type and the TermNode type */
export type ResearchSummaryToTermNodeConnection = {
  __typename?: 'ResearchSummaryToTermNodeConnection';
  /** Edges for the ResearchSummaryToTermNodeConnection connection */
  edges?: Maybe<Array<Maybe<ResearchSummaryToTermNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<TermNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ResearchSummaryToTermNodeConnectionEdge = {
  __typename?: 'ResearchSummaryToTermNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<TermNode>;
};

/** Arguments for filtering the ResearchSummaryToTermNodeConnection connection */
export type ResearchSummaryToTermNodeConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** The Taxonomy to filter terms by */
  taxonomies?: InputMaybe<Array<InputMaybe<TaxonomyEnum>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Field Group */
export type ResearchSummary_Downloads = AcfFieldGroup & {
  __typename?: 'ResearchSummary_Downloads';
  /** The name of the ACF Field Group */
  fieldGroupName?: Maybe<Scalars['String']>;
  file?: Maybe<MediaItem>;
};

/** Input for the resetUserPassword mutation */
export type ResetUserPasswordInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Password reset key */
  key?: InputMaybe<Scalars['String']>;
  /** The user's login (username). */
  login?: InputMaybe<Scalars['String']>;
  /** The new password. */
  password?: InputMaybe<Scalars['String']>;
};

/** The payload for the resetUserPassword mutation */
export type ResetUserPasswordPayload = {
  __typename?: 'ResetUserPasswordPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The User object mutation type. */
  user?: Maybe<User>;
};

/** The Resource type */
export type Resource = ContentNode & DatabaseIdentifier & MenuItemLinkable & Node & NodeWithFeaturedImage & NodeWithTemplate & NodeWithTitle & UniformResourceIdentifiable & {
  __typename?: 'Resource';
  /** Connection between the ContentNode type and the ContentType type */
  contentType?: Maybe<ContentNodeToContentTypeConnectionEdge>;
  /** The name of the Content Type the node belongs to */
  contentTypeName: Scalars['String'];
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** Post publishing date. */
  date?: Maybe<Scalars['String']>;
  /** The publishing date set in GMT. */
  dateGmt?: Maybe<Scalars['String']>;
  /** The desired slug of the post */
  desiredSlug?: Maybe<Scalars['String']>;
  /** If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds */
  editingLockedBy?: Maybe<ContentNodeToEditLockConnectionEdge>;
  /** The RSS enclosure for the object */
  enclosure?: Maybe<Scalars['String']>;
  /** Connection between the ContentNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<ContentNodeToEnqueuedScriptConnection>;
  /** Connection between the ContentNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<ContentNodeToEnqueuedStylesheetConnection>;
  /** Connection between the NodeWithFeaturedImage type and the MediaItem type */
  featuredImage?: Maybe<NodeWithFeaturedImageToMediaItemConnectionEdge>;
  /** The database identifier for the featured image node assigned to the content node */
  featuredImageDatabaseId?: Maybe<Scalars['Int']>;
  /** Globally unique ID of the featured image assigned to the node */
  featuredImageId?: Maybe<Scalars['ID']>;
  /** The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table. */
  guid?: Maybe<Scalars['String']>;
  /** The globally unique identifier of the resource object. */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is a node in the preview state */
  isPreview?: Maybe<Scalars['Boolean']>;
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The user that most recently edited the node */
  lastEditedBy?: Maybe<ContentNodeToEditLastConnectionEdge>;
  /** The permalink of the post */
  link?: Maybe<Scalars['String']>;
  /** The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time. */
  modified?: Maybe<Scalars['String']>;
  /** The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT. */
  modifiedGmt?: Maybe<Scalars['String']>;
  /** Connection between the Resource type and the Resource type */
  preview?: Maybe<ResourceToPreviewConnectionEdge>;
  /** The database id of the preview node */
  previewRevisionDatabaseId?: Maybe<Scalars['Int']>;
  /** Whether the object is a node in the preview state */
  previewRevisionId?: Maybe<Scalars['ID']>;
  /** Added to the GraphQL Schema because the ACF Field Group &quot;Resource Attachment&quot; was set to Show in GraphQL. */
  resourceAttachment?: Maybe<Resource_Resourceattachment>;
  /** Connection between the Resource type and the ResourceCategory type */
  resourceCategories?: Maybe<ResourceToResourceCategoryConnection>;
  /** The id field matches the WP_Post-&gt;ID field. */
  resourceId: Scalars['Int'];
  /** The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table. */
  slug?: Maybe<Scalars['String']>;
  /** The current status of the object */
  status?: Maybe<Scalars['String']>;
  /** The template assigned to a node of content */
  template?: Maybe<ContentTemplate>;
  /** Connection between the Resource type and the TermNode type */
  terms?: Maybe<ResourceToTermNodeConnection>;
  /** The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made. */
  title?: Maybe<Scalars['String']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** The Resource type */
export type ResourceEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The Resource type */
export type ResourceEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The Resource type */
export type ResourceResourceCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ResourceToResourceCategoryConnectionWhereArgs>;
};


/** The Resource type */
export type ResourceTermsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ResourceToTermNodeConnectionWhereArgs>;
};


/** The Resource type */
export type ResourceTitleArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};

/** The ResourceCategory type */
export type ResourceCategory = DatabaseIdentifier & HierarchicalTermNode & MenuItemLinkable & Node & TermNode & UniformResourceIdentifiable & {
  __typename?: 'ResourceCategory';
  /** The ancestors of the node. Default ordered as lowest (closest to the child) to highest (closest to the root). */
  ancestors?: Maybe<ResourceCategoryToAncestorsResourceCategoryConnection>;
  /** Connection between the ResourceCategory type and the ResourceCategory type */
  children?: Maybe<ResourceCategoryToResourceCategoryConnection>;
  /** Connection between the ResourceCategory type and the ContentNode type */
  contentNodes?: Maybe<ResourceCategoryToContentNodeConnection>;
  /** The number of objects connected to the object */
  count?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** The description of the object */
  description?: Maybe<Scalars['String']>;
  /** Connection between the TermNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<TermNodeToEnqueuedScriptConnection>;
  /** Connection between the TermNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<TermNodeToEnqueuedStylesheetConnection>;
  /** The unique resource identifier path */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The link to the term */
  link?: Maybe<Scalars['String']>;
  /** The human friendly name of the object. */
  name?: Maybe<Scalars['String']>;
  /** Connection between the ResourceCategory type and the ResourceCategory type */
  parent?: Maybe<ResourceCategoryToParentResourceCategoryConnectionEdge>;
  /** Database id of the parent node */
  parentDatabaseId?: Maybe<Scalars['Int']>;
  /** The globally unique identifier of the parent node. */
  parentId?: Maybe<Scalars['ID']>;
  /** Added to the GraphQL Schema because the ACF Field Group &quot;Resouce icon&quot; was set to Show in GraphQL. */
  resouceIcon?: Maybe<ResourceCategory_Resouceicon>;
  /** Added to the GraphQL Schema because the ACF Field Group &quot;Resource area&quot; was set to Show in GraphQL. */
  resourceArea?: Maybe<ResourceCategory_Resourcearea>;
  /** The id field matches the WP_Post-&gt;ID field. */
  resourceCategoryId?: Maybe<Scalars['Int']>;
  /** Connection between the ResourceCategory type and the Resource type */
  resources?: Maybe<ResourceCategoryToResourceConnection>;
  /** An alphanumeric identifier for the object unique to its type. */
  slug?: Maybe<Scalars['String']>;
  /** Connection between the ResourceCategory type and the Taxonomy type */
  taxonomy?: Maybe<ResourceCategoryToTaxonomyConnectionEdge>;
  /** The name of the taxonomy that the object is associated with */
  taxonomyName?: Maybe<Scalars['String']>;
  /** The ID of the term group that this term object belongs to */
  termGroupId?: Maybe<Scalars['Int']>;
  /** The taxonomy ID that the object is associated with */
  termTaxonomyId?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** The ResourceCategory type */
export type ResourceCategoryAncestorsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The ResourceCategory type */
export type ResourceCategoryChildrenArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ResourceCategoryToResourceCategoryConnectionWhereArgs>;
};


/** The ResourceCategory type */
export type ResourceCategoryContentNodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ResourceCategoryToContentNodeConnectionWhereArgs>;
};


/** The ResourceCategory type */
export type ResourceCategoryEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The ResourceCategory type */
export type ResourceCategoryEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The ResourceCategory type */
export type ResourceCategoryResourcesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ResourceCategoryToResourceConnectionWhereArgs>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum ResourceCategoryIdType {
  /** The Database ID for the node */
  DatabaseId = 'DATABASE_ID',
  /** The hashed Global ID */
  Id = 'ID',
  /** The name of the node */
  Name = 'NAME',
  /** Url friendly name of the node */
  Slug = 'SLUG',
  /** The URI for the node */
  Uri = 'URI'
}

/** Connection between the ResourceCategory type and the ResourceCategory type */
export type ResourceCategoryToAncestorsResourceCategoryConnection = {
  __typename?: 'ResourceCategoryToAncestorsResourceCategoryConnection';
  /** Edges for the ResourceCategoryToAncestorsResourceCategoryConnection connection */
  edges?: Maybe<Array<Maybe<ResourceCategoryToAncestorsResourceCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ResourceCategory>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ResourceCategoryToAncestorsResourceCategoryConnectionEdge = {
  __typename?: 'ResourceCategoryToAncestorsResourceCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ResourceCategory>;
};

/** Connection between the ResourceCategory type and the ContentNode type */
export type ResourceCategoryToContentNodeConnection = {
  __typename?: 'ResourceCategoryToContentNodeConnection';
  /** Edges for the ResourceCategoryToContentNodeConnection connection */
  edges?: Maybe<Array<Maybe<ResourceCategoryToContentNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ResourceCategoryToContentNodeConnectionEdge = {
  __typename?: 'ResourceCategoryToContentNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentNode>;
};

/** Arguments for filtering the ResourceCategoryToContentNodeConnection connection */
export type ResourceCategoryToContentNodeConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfResourceCategoryEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the ResourceCategory type and the ResourceCategory type */
export type ResourceCategoryToParentResourceCategoryConnectionEdge = {
  __typename?: 'ResourceCategoryToParentResourceCategoryConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<ResourceCategory>;
};

/** Connection between the ResourceCategory type and the ResourceCategory type */
export type ResourceCategoryToResourceCategoryConnection = {
  __typename?: 'ResourceCategoryToResourceCategoryConnection';
  /** Edges for the ResourceCategoryToResourceCategoryConnection connection */
  edges?: Maybe<Array<Maybe<ResourceCategoryToResourceCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ResourceCategory>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ResourceCategoryToResourceCategoryConnectionEdge = {
  __typename?: 'ResourceCategoryToResourceCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ResourceCategory>;
};

/** Arguments for filtering the ResourceCategoryToResourceCategoryConnection connection */
export type ResourceCategoryToResourceCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the ResourceCategory type and the Resource type */
export type ResourceCategoryToResourceConnection = {
  __typename?: 'ResourceCategoryToResourceConnection';
  /** Edges for the ResourceCategoryToResourceConnection connection */
  edges?: Maybe<Array<Maybe<ResourceCategoryToResourceConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Resource>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ResourceCategoryToResourceConnectionEdge = {
  __typename?: 'ResourceCategoryToResourceConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Resource>;
};

/** Arguments for filtering the ResourceCategoryToResourceConnection connection */
export type ResourceCategoryToResourceConnectionWhereArgs = {
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the ResourceCategory type and the Taxonomy type */
export type ResourceCategoryToTaxonomyConnectionEdge = {
  __typename?: 'ResourceCategoryToTaxonomyConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Taxonomy>;
};

/** Field Group */
export type ResourceCategory_Resouceicon = AcfFieldGroup & {
  __typename?: 'ResourceCategory_Resouceicon';
  /** The name of the ACF Field Group */
  fieldGroupName?: Maybe<Scalars['String']>;
  resourceicon?: Maybe<Scalars['String']>;
};

/** Field Group */
export type ResourceCategory_Resourcearea = AcfFieldGroup & {
  __typename?: 'ResourceCategory_Resourcearea';
  /** The name of the ACF Field Group */
  fieldGroupName?: Maybe<Scalars['String']>;
  /** Whether it will appear on Resources main page as a basic Resource or an Additional Resource */
  resourcearea?: Maybe<Scalars['String']>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum ResourceIdType {
  /** Identify a resource by the Database ID. */
  DatabaseId = 'DATABASE_ID',
  /** Identify a resource by the (hashed) Global ID. */
  Id = 'ID',
  /** Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier. */
  Slug = 'SLUG',
  /** Identify a resource by the URI. */
  Uri = 'URI'
}

/** Set relationships between the Resource to ResourceCategories */
export type ResourceResourceCategoriesInput = {
  /** If true, this will append the ResourceCategory to existing related ResourceCategories. If false, this will replace existing relationships. Default true. */
  append?: InputMaybe<Scalars['Boolean']>;
  /** The input list of items to set. */
  nodes?: InputMaybe<Array<InputMaybe<ResourceResourceCategoriesNodeInput>>>;
};

/** List of ResourceCategories to connect the Resource to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */
export type ResourceResourceCategoriesNodeInput = {
  /** The description of the ResourceCategory. This field is used to set a description of the ResourceCategory if a new one is created during the mutation. */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the ResourceCategory. If present, this will be used to connect to the Resource. If no existing ResourceCategory exists with this ID, no connection will be made. */
  id?: InputMaybe<Scalars['ID']>;
  /** The name of the ResourceCategory. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */
  name?: InputMaybe<Scalars['String']>;
  /** The slug of the ResourceCategory. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */
  slug?: InputMaybe<Scalars['String']>;
};

/** Connection between the Resource type and the Resource type */
export type ResourceToPreviewConnectionEdge = {
  __typename?: 'ResourceToPreviewConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Resource>;
};

/** Connection between the Resource type and the ResourceCategory type */
export type ResourceToResourceCategoryConnection = {
  __typename?: 'ResourceToResourceCategoryConnection';
  /** Edges for the ResourceToResourceCategoryConnection connection */
  edges?: Maybe<Array<Maybe<ResourceToResourceCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ResourceCategory>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ResourceToResourceCategoryConnectionEdge = {
  __typename?: 'ResourceToResourceCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ResourceCategory>;
};

/** Arguments for filtering the ResourceToResourceCategoryConnection connection */
export type ResourceToResourceCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the Resource type and the TermNode type */
export type ResourceToTermNodeConnection = {
  __typename?: 'ResourceToTermNodeConnection';
  /** Edges for the ResourceToTermNodeConnection connection */
  edges?: Maybe<Array<Maybe<ResourceToTermNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<TermNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type ResourceToTermNodeConnectionEdge = {
  __typename?: 'ResourceToTermNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<TermNode>;
};

/** Arguments for filtering the ResourceToTermNodeConnection connection */
export type ResourceToTermNodeConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** The Taxonomy to filter terms by */
  taxonomies?: InputMaybe<Array<InputMaybe<TaxonomyEnum>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Field Group */
export type Resource_Resourceattachment = AcfFieldGroup & {
  __typename?: 'Resource_Resourceattachment';
  /** The name of the ACF Field Group */
  fieldGroupName?: Maybe<Scalars['String']>;
  file?: Maybe<MediaItem>;
  resourcetype?: Maybe<Scalars['String']>;
  videourl?: Maybe<Scalars['String']>;
};

/** Input for the restoreComment mutation */
export type RestoreCommentInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The ID of the comment to be restored */
  id: Scalars['ID'];
};

/** The payload for the restoreComment mutation */
export type RestoreCommentPayload = {
  __typename?: 'RestoreCommentPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The restored comment object */
  comment?: Maybe<Comment>;
  /** The ID of the restored comment */
  restoredId?: Maybe<Scalars['ID']>;
};

export type RootMutation = {
  __typename?: 'RootMutation';
  /** The payload for the createCategory mutation */
  createCategory?: Maybe<CreateCategoryPayload>;
  /** The payload for the createComment mutation */
  createComment?: Maybe<CreateCommentPayload>;
  /** The payload for the createEbook mutation */
  createEbook?: Maybe<CreateEbookPayload>;
  /** The payload for the createEbooksCategory mutation */
  createEbooksCategory?: Maybe<CreateEbooksCategoryPayload>;
  /** The payload for the createMediaItem mutation */
  createMediaItem?: Maybe<CreateMediaItemPayload>;
  /** The payload for the createPage mutation */
  createPage?: Maybe<CreatePagePayload>;
  /** The payload for the createPost mutation */
  createPost?: Maybe<CreatePostPayload>;
  /** The payload for the createPostFormat mutation */
  createPostFormat?: Maybe<CreatePostFormatPayload>;
  /** The payload for the createResearchSummariesCategory mutation */
  createResearchSummariesCategory?: Maybe<CreateResearchSummariesCategoryPayload>;
  /** The payload for the createResearchSummary mutation */
  createResearchSummary?: Maybe<CreateResearchSummaryPayload>;
  /** The payload for the createResource mutation */
  createResource?: Maybe<CreateResourcePayload>;
  /** The payload for the createResourceCategory mutation */
  createResourceCategory?: Maybe<CreateResourceCategoryPayload>;
  /** The payload for the createTag mutation */
  createTag?: Maybe<CreateTagPayload>;
  /** The payload for the createUser mutation */
  createUser?: Maybe<CreateUserPayload>;
  /** The payload for the createVideoSeriesCategory mutation */
  createVideoSeriesCategory?: Maybe<CreateVideoSeriesCategoryPayload>;
  /** The payload for the createVideoSeriesItem mutation */
  createVideoSeriesItem?: Maybe<CreateVideoSeriesItemPayload>;
  /** The payload for the createWebinar mutation */
  createWebinar?: Maybe<CreateWebinarPayload>;
  /** The payload for the createWebinarsCategory mutation */
  createWebinarsCategory?: Maybe<CreateWebinarsCategoryPayload>;
  /** The payload for the deleteCategory mutation */
  deleteCategory?: Maybe<DeleteCategoryPayload>;
  /** The payload for the deleteComment mutation */
  deleteComment?: Maybe<DeleteCommentPayload>;
  /** The payload for the deleteEbook mutation */
  deleteEbook?: Maybe<DeleteEbookPayload>;
  /** The payload for the deleteEbooksCategory mutation */
  deleteEbooksCategory?: Maybe<DeleteEbooksCategoryPayload>;
  /** The payload for the deleteMediaItem mutation */
  deleteMediaItem?: Maybe<DeleteMediaItemPayload>;
  /** The payload for the deletePage mutation */
  deletePage?: Maybe<DeletePagePayload>;
  /** The payload for the deletePost mutation */
  deletePost?: Maybe<DeletePostPayload>;
  /** The payload for the deletePostFormat mutation */
  deletePostFormat?: Maybe<DeletePostFormatPayload>;
  /** The payload for the deleteResearchSummariesCategory mutation */
  deleteResearchSummariesCategory?: Maybe<DeleteResearchSummariesCategoryPayload>;
  /** The payload for the deleteResearchSummary mutation */
  deleteResearchSummary?: Maybe<DeleteResearchSummaryPayload>;
  /** The payload for the deleteResource mutation */
  deleteResource?: Maybe<DeleteResourcePayload>;
  /** The payload for the deleteResourceCategory mutation */
  deleteResourceCategory?: Maybe<DeleteResourceCategoryPayload>;
  /** The payload for the deleteTag mutation */
  deleteTag?: Maybe<DeleteTagPayload>;
  /** The payload for the deleteUser mutation */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** The payload for the deleteVideoSeriesCategory mutation */
  deleteVideoSeriesCategory?: Maybe<DeleteVideoSeriesCategoryPayload>;
  /** The payload for the deleteVideoSeriesItem mutation */
  deleteVideoSeriesItem?: Maybe<DeleteVideoSeriesItemPayload>;
  /** The payload for the deleteWebinar mutation */
  deleteWebinar?: Maybe<DeleteWebinarPayload>;
  /** The payload for the deleteWebinarsCategory mutation */
  deleteWebinarsCategory?: Maybe<DeleteWebinarsCategoryPayload>;
  /** Increase the count. */
  increaseCount?: Maybe<Scalars['Int']>;
  /** The payload for the registerUser mutation */
  registerUser?: Maybe<RegisterUserPayload>;
  /** The payload for the resetUserPassword mutation */
  resetUserPassword?: Maybe<ResetUserPasswordPayload>;
  /** The payload for the restoreComment mutation */
  restoreComment?: Maybe<RestoreCommentPayload>;
  /** The payload for the sendPasswordResetEmail mutation */
  sendPasswordResetEmail?: Maybe<SendPasswordResetEmailPayload>;
  /** The payload for the UpdateCategory mutation */
  updateCategory?: Maybe<UpdateCategoryPayload>;
  /** The payload for the updateComment mutation */
  updateComment?: Maybe<UpdateCommentPayload>;
  /** The payload for the updateEbook mutation */
  updateEbook?: Maybe<UpdateEbookPayload>;
  /** The payload for the UpdateEbooksCategory mutation */
  updateEbooksCategory?: Maybe<UpdateEbooksCategoryPayload>;
  /** The payload for the updateMediaItem mutation */
  updateMediaItem?: Maybe<UpdateMediaItemPayload>;
  /** The payload for the updatePage mutation */
  updatePage?: Maybe<UpdatePagePayload>;
  /** The payload for the updatePost mutation */
  updatePost?: Maybe<UpdatePostPayload>;
  /** The payload for the UpdatePostFormat mutation */
  updatePostFormat?: Maybe<UpdatePostFormatPayload>;
  /** The payload for the UpdateResearchSummariesCategory mutation */
  updateResearchSummariesCategory?: Maybe<UpdateResearchSummariesCategoryPayload>;
  /** The payload for the updateResearchSummary mutation */
  updateResearchSummary?: Maybe<UpdateResearchSummaryPayload>;
  /** The payload for the updateResource mutation */
  updateResource?: Maybe<UpdateResourcePayload>;
  /** The payload for the UpdateResourceCategory mutation */
  updateResourceCategory?: Maybe<UpdateResourceCategoryPayload>;
  /** The payload for the updateSettings mutation */
  updateSettings?: Maybe<UpdateSettingsPayload>;
  /** The payload for the UpdateTag mutation */
  updateTag?: Maybe<UpdateTagPayload>;
  /** The payload for the updateUser mutation */
  updateUser?: Maybe<UpdateUserPayload>;
  /** The payload for the UpdateVideoSeriesCategory mutation */
  updateVideoSeriesCategory?: Maybe<UpdateVideoSeriesCategoryPayload>;
  /** The payload for the updateVideoSeriesItem mutation */
  updateVideoSeriesItem?: Maybe<UpdateVideoSeriesItemPayload>;
  /** The payload for the updateWebinar mutation */
  updateWebinar?: Maybe<UpdateWebinarPayload>;
  /** The payload for the UpdateWebinarsCategory mutation */
  updateWebinarsCategory?: Maybe<UpdateWebinarsCategoryPayload>;
};


export type RootMutationCreateCategoryArgs = {
  input: CreateCategoryInput;
};


export type RootMutationCreateCommentArgs = {
  input: CreateCommentInput;
};


export type RootMutationCreateEbookArgs = {
  input: CreateEbookInput;
};


export type RootMutationCreateEbooksCategoryArgs = {
  input: CreateEbooksCategoryInput;
};


export type RootMutationCreateMediaItemArgs = {
  input: CreateMediaItemInput;
};


export type RootMutationCreatePageArgs = {
  input: CreatePageInput;
};


export type RootMutationCreatePostArgs = {
  input: CreatePostInput;
};


export type RootMutationCreatePostFormatArgs = {
  input: CreatePostFormatInput;
};


export type RootMutationCreateResearchSummariesCategoryArgs = {
  input: CreateResearchSummariesCategoryInput;
};


export type RootMutationCreateResearchSummaryArgs = {
  input: CreateResearchSummaryInput;
};


export type RootMutationCreateResourceArgs = {
  input: CreateResourceInput;
};


export type RootMutationCreateResourceCategoryArgs = {
  input: CreateResourceCategoryInput;
};


export type RootMutationCreateTagArgs = {
  input: CreateTagInput;
};


export type RootMutationCreateUserArgs = {
  input: CreateUserInput;
};


export type RootMutationCreateVideoSeriesCategoryArgs = {
  input: CreateVideoSeriesCategoryInput;
};


export type RootMutationCreateVideoSeriesItemArgs = {
  input: CreateVideoSeriesItemInput;
};


export type RootMutationCreateWebinarArgs = {
  input: CreateWebinarInput;
};


export type RootMutationCreateWebinarsCategoryArgs = {
  input: CreateWebinarsCategoryInput;
};


export type RootMutationDeleteCategoryArgs = {
  input: DeleteCategoryInput;
};


export type RootMutationDeleteCommentArgs = {
  input: DeleteCommentInput;
};


export type RootMutationDeleteEbookArgs = {
  input: DeleteEbookInput;
};


export type RootMutationDeleteEbooksCategoryArgs = {
  input: DeleteEbooksCategoryInput;
};


export type RootMutationDeleteMediaItemArgs = {
  input: DeleteMediaItemInput;
};


export type RootMutationDeletePageArgs = {
  input: DeletePageInput;
};


export type RootMutationDeletePostArgs = {
  input: DeletePostInput;
};


export type RootMutationDeletePostFormatArgs = {
  input: DeletePostFormatInput;
};


export type RootMutationDeleteResearchSummariesCategoryArgs = {
  input: DeleteResearchSummariesCategoryInput;
};


export type RootMutationDeleteResearchSummaryArgs = {
  input: DeleteResearchSummaryInput;
};


export type RootMutationDeleteResourceArgs = {
  input: DeleteResourceInput;
};


export type RootMutationDeleteResourceCategoryArgs = {
  input: DeleteResourceCategoryInput;
};


export type RootMutationDeleteTagArgs = {
  input: DeleteTagInput;
};


export type RootMutationDeleteUserArgs = {
  input: DeleteUserInput;
};


export type RootMutationDeleteVideoSeriesCategoryArgs = {
  input: DeleteVideoSeriesCategoryInput;
};


export type RootMutationDeleteVideoSeriesItemArgs = {
  input: DeleteVideoSeriesItemInput;
};


export type RootMutationDeleteWebinarArgs = {
  input: DeleteWebinarInput;
};


export type RootMutationDeleteWebinarsCategoryArgs = {
  input: DeleteWebinarsCategoryInput;
};


export type RootMutationIncreaseCountArgs = {
  count?: InputMaybe<Scalars['Int']>;
};


export type RootMutationRegisterUserArgs = {
  input: RegisterUserInput;
};


export type RootMutationResetUserPasswordArgs = {
  input: ResetUserPasswordInput;
};


export type RootMutationRestoreCommentArgs = {
  input: RestoreCommentInput;
};


export type RootMutationSendPasswordResetEmailArgs = {
  input: SendPasswordResetEmailInput;
};


export type RootMutationUpdateCategoryArgs = {
  input: UpdateCategoryInput;
};


export type RootMutationUpdateCommentArgs = {
  input: UpdateCommentInput;
};


export type RootMutationUpdateEbookArgs = {
  input: UpdateEbookInput;
};


export type RootMutationUpdateEbooksCategoryArgs = {
  input: UpdateEbooksCategoryInput;
};


export type RootMutationUpdateMediaItemArgs = {
  input: UpdateMediaItemInput;
};


export type RootMutationUpdatePageArgs = {
  input: UpdatePageInput;
};


export type RootMutationUpdatePostArgs = {
  input: UpdatePostInput;
};


export type RootMutationUpdatePostFormatArgs = {
  input: UpdatePostFormatInput;
};


export type RootMutationUpdateResearchSummariesCategoryArgs = {
  input: UpdateResearchSummariesCategoryInput;
};


export type RootMutationUpdateResearchSummaryArgs = {
  input: UpdateResearchSummaryInput;
};


export type RootMutationUpdateResourceArgs = {
  input: UpdateResourceInput;
};


export type RootMutationUpdateResourceCategoryArgs = {
  input: UpdateResourceCategoryInput;
};


export type RootMutationUpdateSettingsArgs = {
  input: UpdateSettingsInput;
};


export type RootMutationUpdateTagArgs = {
  input: UpdateTagInput;
};


export type RootMutationUpdateUserArgs = {
  input: UpdateUserInput;
};


export type RootMutationUpdateVideoSeriesCategoryArgs = {
  input: UpdateVideoSeriesCategoryInput;
};


export type RootMutationUpdateVideoSeriesItemArgs = {
  input: UpdateVideoSeriesItemInput;
};


export type RootMutationUpdateWebinarArgs = {
  input: UpdateWebinarInput;
};


export type RootMutationUpdateWebinarsCategoryArgs = {
  input: UpdateWebinarsCategoryInput;
};

export type RootQuery = {
  __typename?: 'RootQuery';
  /** Entry point to get all settings for the site */
  allSettings?: Maybe<Settings>;
  /** Connection between the RootQuery type and the category type */
  categories?: Maybe<RootQueryToCategoryConnection>;
  /** A 0bject */
  category?: Maybe<Category>;
  /** Returns a Comment */
  comment?: Maybe<Comment>;
  /** Connection between the RootQuery type and the Comment type */
  comments?: Maybe<RootQueryToCommentConnection>;
  /** A node used to manage content */
  contentNode?: Maybe<ContentNode>;
  /** Connection between the RootQuery type and the ContentNode type */
  contentNodes?: Maybe<RootQueryToContentNodeConnection>;
  /** Fetch a Content Type node by unique Identifier */
  contentType?: Maybe<ContentType>;
  /** Connection between the RootQuery type and the ContentType type */
  contentTypes?: Maybe<RootQueryToContentTypeConnection>;
  /** Fields of the &#039;DiscussionSettings&#039; settings group */
  discussionSettings?: Maybe<DiscussionSettings>;
  /** An object of the Ebook Type.  */
  ebook?: Maybe<Ebook>;
  /** A Ebook object */
  ebookBy?: Maybe<Ebook>;
  /** Connection between the RootQuery type and the Ebook type */
  ebooks?: Maybe<RootQueryToEbookConnection>;
  /** Connection between the RootQuery type and the EbooksCategory type */
  ebooksCategories?: Maybe<RootQueryToEbooksCategoryConnection>;
  /** A 0bject */
  ebooksCategory?: Maybe<EbooksCategory>;
  /** Fields of the &#039;GeneralSettings&#039; settings group */
  generalSettings?: Maybe<GeneralSettings>;
  /** An object of the mediaItem Type.  */
  mediaItem?: Maybe<MediaItem>;
  /** A mediaItem object */
  mediaItemBy?: Maybe<MediaItem>;
  /** Connection between the RootQuery type and the mediaItem type */
  mediaItems?: Maybe<RootQueryToMediaItemConnection>;
  /** A WordPress navigation menu */
  menu?: Maybe<Menu>;
  /** A WordPress navigation menu item */
  menuItem?: Maybe<MenuItem>;
  /** Connection between the RootQuery type and the MenuItem type */
  menuItems?: Maybe<RootQueryToMenuItemConnection>;
  /** Connection between the RootQuery type and the Menu type */
  menus?: Maybe<RootQueryToMenuConnection>;
  /** Fetches an object given its ID */
  node?: Maybe<Node>;
  /** Fetches an object given its Unique Resource Identifier */
  nodeByUri?: Maybe<UniformResourceIdentifiable>;
  /** An object of the page Type.  */
  page?: Maybe<Page>;
  /** A page object */
  pageBy?: Maybe<Page>;
  /** Connection between the RootQuery type and the page type */
  pages?: Maybe<RootQueryToPageConnection>;
  /** A WordPress plugin */
  plugin?: Maybe<Plugin>;
  /** Connection between the RootQuery type and the Plugin type */
  plugins?: Maybe<RootQueryToPluginConnection>;
  /** An object of the post Type.  */
  post?: Maybe<Post>;
  /** A post object */
  postBy?: Maybe<Post>;
  /** A 0bject */
  postFormat?: Maybe<PostFormat>;
  /** Connection between the RootQuery type and the postFormat type */
  postFormats?: Maybe<RootQueryToPostFormatConnection>;
  /** Connection between the RootQuery type and the post type */
  posts?: Maybe<RootQueryToPostConnection>;
  /** Fields of the &#039;ReadingSettings&#039; settings group */
  readingSettings?: Maybe<ReadingSettings>;
  /** Connection between the RootQuery type and the EnqueuedScript type */
  registeredScripts?: Maybe<RootQueryToEnqueuedScriptConnection>;
  /** Connection between the RootQuery type and the EnqueuedStylesheet type */
  registeredStylesheets?: Maybe<RootQueryToEnqueuedStylesheetConnection>;
  /** Connection between the RootQuery type and the ResearchSummary type */
  researchSummaries?: Maybe<RootQueryToResearchSummaryConnection>;
  /** Connection between the RootQuery type and the ResearchSummariesCategory type */
  researchSummariesCategories?: Maybe<RootQueryToResearchSummariesCategoryConnection>;
  /** A 0bject */
  researchSummariesCategory?: Maybe<ResearchSummariesCategory>;
  /** An object of the ResearchSummary Type.  */
  researchSummary?: Maybe<ResearchSummary>;
  /** A ResearchSummary object */
  researchSummaryBy?: Maybe<ResearchSummary>;
  /** An object of the Resource Type.  */
  resource?: Maybe<Resource>;
  /** A Resource object */
  resourceBy?: Maybe<Resource>;
  /** Connection between the RootQuery type and the ResourceCategory type */
  resourceCategories?: Maybe<RootQueryToResourceCategoryConnection>;
  /** A 0bject */
  resourceCategory?: Maybe<ResourceCategory>;
  /** Connection between the RootQuery type and the Resource type */
  resources?: Maybe<RootQueryToResourceConnection>;
  /** Connection between the RootQuery type and the ContentRevisionUnion type */
  revisions?: Maybe<RootQueryToContentRevisionUnionConnection>;
  /** A 0bject */
  tag?: Maybe<Tag>;
  /** Connection between the RootQuery type and the tag type */
  tags?: Maybe<RootQueryToTagConnection>;
  /** Connection between the RootQuery type and the Taxonomy type */
  taxonomies?: Maybe<RootQueryToTaxonomyConnection>;
  /** Fetch a Taxonomy node by unique Identifier */
  taxonomy?: Maybe<Taxonomy>;
  /** A node in a taxonomy used to group and relate content nodes */
  termNode?: Maybe<TermNode>;
  /** Connection between the RootQuery type and the TermNode type */
  terms?: Maybe<RootQueryToTermNodeConnection>;
  /** A Theme object */
  theme?: Maybe<Theme>;
  /** Connection between the RootQuery type and the Theme type */
  themes?: Maybe<RootQueryToThemeConnection>;
  /** Returns a user */
  user?: Maybe<User>;
  /** Returns a user role */
  userRole?: Maybe<UserRole>;
  /** Connection between the RootQuery type and the UserRole type */
  userRoles?: Maybe<RootQueryToUserRoleConnection>;
  /** Connection between the RootQuery type and the User type */
  users?: Maybe<RootQueryToUserConnection>;
  /** Connection between the RootQuery type and the VideoSeriesCategory type */
  videoSeriesCategories?: Maybe<RootQueryToVideoSeriesCategoryConnection>;
  /** A 0bject */
  videoSeriesCategory?: Maybe<VideoSeriesCategory>;
  /** An object of the VideoSeriesItem Type.  */
  videoSeriesItem?: Maybe<VideoSeriesItem>;
  /** A VideoSeriesItem object */
  videoSeriesItemBy?: Maybe<VideoSeriesItem>;
  /** Connection between the RootQuery type and the VideoSeriesItem type */
  videoSeriesItems?: Maybe<RootQueryToVideoSeriesItemConnection>;
  /** Returns the current user */
  viewer?: Maybe<User>;
  /** An object of the Webinar Type.  */
  webinar?: Maybe<Webinar>;
  /** A Webinar object */
  webinarBy?: Maybe<Webinar>;
  /** Connection between the RootQuery type and the Webinar type */
  webinars?: Maybe<RootQueryToWebinarConnection>;
  /** Connection between the RootQuery type and the WebinarsCategory type */
  webinarsCategories?: Maybe<RootQueryToWebinarsCategoryConnection>;
  /** A 0bject */
  webinarsCategory?: Maybe<WebinarsCategory>;
  /** Fields of the &#039;WritingSettings&#039; settings group */
  writingSettings?: Maybe<WritingSettings>;
};


export type RootQueryCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToCategoryConnectionWhereArgs>;
};


export type RootQueryCategoryArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<CategoryIdType>;
};


export type RootQueryCommentArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<CommentNodeIdTypeEnum>;
};


export type RootQueryCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToCommentConnectionWhereArgs>;
};


export type RootQueryContentNodeArgs = {
  asPreview?: InputMaybe<Scalars['Boolean']>;
  contentType?: InputMaybe<ContentTypeEnum>;
  id: Scalars['ID'];
  idType?: InputMaybe<ContentNodeIdTypeEnum>;
};


export type RootQueryContentNodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToContentNodeConnectionWhereArgs>;
};


export type RootQueryContentTypeArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<ContentTypeIdTypeEnum>;
};


export type RootQueryContentTypesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type RootQueryEbookArgs = {
  asPreview?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  idType?: InputMaybe<EbookIdType>;
};


export type RootQueryEbookByArgs = {
  ebookId?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['String']>;
  uri?: InputMaybe<Scalars['String']>;
};


export type RootQueryEbooksArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToEbookConnectionWhereArgs>;
};


export type RootQueryEbooksCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToEbooksCategoryConnectionWhereArgs>;
};


export type RootQueryEbooksCategoryArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<EbooksCategoryIdType>;
};


export type RootQueryMediaItemArgs = {
  asPreview?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  idType?: InputMaybe<MediaItemIdType>;
};


export type RootQueryMediaItemByArgs = {
  id?: InputMaybe<Scalars['ID']>;
  mediaItemId?: InputMaybe<Scalars['Int']>;
  slug?: InputMaybe<Scalars['String']>;
  uri?: InputMaybe<Scalars['String']>;
};


export type RootQueryMediaItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToMediaItemConnectionWhereArgs>;
};


export type RootQueryMenuArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<MenuNodeIdTypeEnum>;
};


export type RootQueryMenuItemArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<MenuItemNodeIdTypeEnum>;
};


export type RootQueryMenuItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToMenuItemConnectionWhereArgs>;
};


export type RootQueryMenusArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToMenuConnectionWhereArgs>;
};


export type RootQueryNodeArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type RootQueryNodeByUriArgs = {
  uri: Scalars['String'];
};


export type RootQueryPageArgs = {
  asPreview?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  idType?: InputMaybe<PageIdType>;
};


export type RootQueryPageByArgs = {
  id?: InputMaybe<Scalars['ID']>;
  pageId?: InputMaybe<Scalars['Int']>;
  uri?: InputMaybe<Scalars['String']>;
};


export type RootQueryPagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToPageConnectionWhereArgs>;
};


export type RootQueryPluginArgs = {
  id: Scalars['ID'];
};


export type RootQueryPluginsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToPluginConnectionWhereArgs>;
};


export type RootQueryPostArgs = {
  asPreview?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  idType?: InputMaybe<PostIdType>;
};


export type RootQueryPostByArgs = {
  id?: InputMaybe<Scalars['ID']>;
  postId?: InputMaybe<Scalars['Int']>;
  slug?: InputMaybe<Scalars['String']>;
  uri?: InputMaybe<Scalars['String']>;
};


export type RootQueryPostFormatArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<PostFormatIdType>;
};


export type RootQueryPostFormatsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToPostFormatConnectionWhereArgs>;
};


export type RootQueryPostsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToPostConnectionWhereArgs>;
};


export type RootQueryRegisteredScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type RootQueryRegisteredStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type RootQueryResearchSummariesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToResearchSummaryConnectionWhereArgs>;
};


export type RootQueryResearchSummariesCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToResearchSummariesCategoryConnectionWhereArgs>;
};


export type RootQueryResearchSummariesCategoryArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<ResearchSummariesCategoryIdType>;
};


export type RootQueryResearchSummaryArgs = {
  asPreview?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  idType?: InputMaybe<ResearchSummaryIdType>;
};


export type RootQueryResearchSummaryByArgs = {
  id?: InputMaybe<Scalars['ID']>;
  researchSummaryId?: InputMaybe<Scalars['Int']>;
  slug?: InputMaybe<Scalars['String']>;
  uri?: InputMaybe<Scalars['String']>;
};


export type RootQueryResourceArgs = {
  asPreview?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  idType?: InputMaybe<ResourceIdType>;
};


export type RootQueryResourceByArgs = {
  id?: InputMaybe<Scalars['ID']>;
  resourceId?: InputMaybe<Scalars['Int']>;
  slug?: InputMaybe<Scalars['String']>;
  uri?: InputMaybe<Scalars['String']>;
};


export type RootQueryResourceCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToResourceCategoryConnectionWhereArgs>;
};


export type RootQueryResourceCategoryArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<ResourceCategoryIdType>;
};


export type RootQueryResourcesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToResourceConnectionWhereArgs>;
};


export type RootQueryRevisionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToContentRevisionUnionConnectionWhereArgs>;
};


export type RootQueryTagArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<TagIdType>;
};


export type RootQueryTagsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToTagConnectionWhereArgs>;
};


export type RootQueryTaxonomiesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type RootQueryTaxonomyArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<TaxonomyIdTypeEnum>;
};


export type RootQueryTermNodeArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<TermNodeIdTypeEnum>;
  taxonomy?: InputMaybe<TaxonomyEnum>;
};


export type RootQueryTermsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToTermNodeConnectionWhereArgs>;
};


export type RootQueryThemeArgs = {
  id: Scalars['ID'];
};


export type RootQueryThemesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type RootQueryUserArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<UserNodeIdTypeEnum>;
};


export type RootQueryUserRoleArgs = {
  id: Scalars['ID'];
};


export type RootQueryUserRolesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type RootQueryUsersArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToUserConnectionWhereArgs>;
};


export type RootQueryVideoSeriesCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToVideoSeriesCategoryConnectionWhereArgs>;
};


export type RootQueryVideoSeriesCategoryArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<VideoSeriesCategoryIdType>;
};


export type RootQueryVideoSeriesItemArgs = {
  asPreview?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  idType?: InputMaybe<VideoSeriesItemIdType>;
};


export type RootQueryVideoSeriesItemByArgs = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['String']>;
  uri?: InputMaybe<Scalars['String']>;
  videoSeriesItemId?: InputMaybe<Scalars['Int']>;
};


export type RootQueryVideoSeriesItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToVideoSeriesItemConnectionWhereArgs>;
};


export type RootQueryWebinarArgs = {
  asPreview?: InputMaybe<Scalars['Boolean']>;
  id: Scalars['ID'];
  idType?: InputMaybe<WebinarIdType>;
};


export type RootQueryWebinarByArgs = {
  id?: InputMaybe<Scalars['ID']>;
  slug?: InputMaybe<Scalars['String']>;
  uri?: InputMaybe<Scalars['String']>;
  webinarId?: InputMaybe<Scalars['Int']>;
};


export type RootQueryWebinarsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToWebinarConnectionWhereArgs>;
};


export type RootQueryWebinarsCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<RootQueryToWebinarsCategoryConnectionWhereArgs>;
};


export type RootQueryWebinarsCategoryArgs = {
  id: Scalars['ID'];
  idType?: InputMaybe<WebinarsCategoryIdType>;
};

/** Connection between the RootQuery type and the category type */
export type RootQueryToCategoryConnection = {
  __typename?: 'RootQueryToCategoryConnection';
  /** Edges for the RootQueryToCategoryConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Category>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToCategoryConnectionEdge = {
  __typename?: 'RootQueryToCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Category>;
};

/** Arguments for filtering the RootQueryToCategoryConnection connection */
export type RootQueryToCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the RootQuery type and the Comment type */
export type RootQueryToCommentConnection = {
  __typename?: 'RootQueryToCommentConnection';
  /** Edges for the RootQueryToCommentConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToCommentConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Comment>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToCommentConnectionEdge = {
  __typename?: 'RootQueryToCommentConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Comment>;
};

/** Arguments for filtering the RootQueryToCommentConnection connection */
export type RootQueryToCommentConnectionWhereArgs = {
  /** Comment author email address. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** Array of author IDs to include comments for. */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to exclude comments for. */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Comment author URL. */
  authorUrl?: InputMaybe<Scalars['String']>;
  /** Array of comment IDs to include. */
  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */
  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Include comments of a given type. */
  commentType?: InputMaybe<Scalars['String']>;
  /** Include comments from a given array of comment types. */
  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Exclude comments from a given array of comment types. */
  commentTypeNotIn?: InputMaybe<Scalars['String']>;
  /** Content object author ID to limit results by. */
  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to retrieve comments for. */
  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs *not* to retrieve comments for. */
  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Limit results to those affiliated with a given content object ID. */
  contentId?: InputMaybe<Scalars['ID']>;
  /** Array of content object IDs to include affiliated comments for. */
  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of content object IDs to exclude affiliated comments for. */
  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Content object name to retrieve affiliated comments for. */
  contentName?: InputMaybe<Scalars['String']>;
  /** Content Object parent ID to retrieve affiliated comments for. */
  contentParent?: InputMaybe<Scalars['Int']>;
  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */
  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Karma score to retrieve matching comments for. */
  karma?: InputMaybe<Scalars['Int']>;
  /** The cardinality of the order of the connection */
  order?: InputMaybe<OrderEnum>;
  /** Field to order the comments by. */
  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;
  /** Parent ID of comment to retrieve children of. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Array of parent IDs of comments to retrieve children for. */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of parent IDs of comments *not* to retrieve children for. */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Search term(s) to retrieve matching comments for. */
  search?: InputMaybe<Scalars['String']>;
  /** Comment status to limit results by. */
  status?: InputMaybe<Scalars['String']>;
  /** Include comments for a specific user ID. */
  userId?: InputMaybe<Scalars['ID']>;
};

/** Connection between the RootQuery type and the ContentNode type */
export type RootQueryToContentNodeConnection = {
  __typename?: 'RootQueryToContentNodeConnection';
  /** Edges for the RootQueryToContentNodeConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToContentNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToContentNodeConnectionEdge = {
  __typename?: 'RootQueryToContentNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentNode>;
};

/** Arguments for filtering the RootQueryToContentNodeConnection connection */
export type RootQueryToContentNodeConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the RootQuery type and the ContentRevisionUnion type */
export type RootQueryToContentRevisionUnionConnection = {
  __typename?: 'RootQueryToContentRevisionUnionConnection';
  /** Edges for the RootQueryToContentRevisionUnionConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToContentRevisionUnionConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentRevisionUnion>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToContentRevisionUnionConnectionEdge = {
  __typename?: 'RootQueryToContentRevisionUnionConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentRevisionUnion>;
};

/** Arguments for filtering the RootQueryToContentRevisionUnionConnection connection */
export type RootQueryToContentRevisionUnionConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the RootQuery type and the ContentType type */
export type RootQueryToContentTypeConnection = {
  __typename?: 'RootQueryToContentTypeConnection';
  /** Edges for the RootQueryToContentTypeConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToContentTypeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentType>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToContentTypeConnectionEdge = {
  __typename?: 'RootQueryToContentTypeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentType>;
};

/** Connection between the RootQuery type and the Ebook type */
export type RootQueryToEbookConnection = {
  __typename?: 'RootQueryToEbookConnection';
  /** Edges for the RootQueryToEbookConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToEbookConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Ebook>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToEbookConnectionEdge = {
  __typename?: 'RootQueryToEbookConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Ebook>;
};

/** Arguments for filtering the RootQueryToEbookConnection connection */
export type RootQueryToEbookConnectionWhereArgs = {
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the RootQuery type and the EbooksCategory type */
export type RootQueryToEbooksCategoryConnection = {
  __typename?: 'RootQueryToEbooksCategoryConnection';
  /** Edges for the RootQueryToEbooksCategoryConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToEbooksCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<EbooksCategory>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToEbooksCategoryConnectionEdge = {
  __typename?: 'RootQueryToEbooksCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<EbooksCategory>;
};

/** Arguments for filtering the RootQueryToEbooksCategoryConnection connection */
export type RootQueryToEbooksCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the RootQuery type and the EnqueuedScript type */
export type RootQueryToEnqueuedScriptConnection = {
  __typename?: 'RootQueryToEnqueuedScriptConnection';
  /** Edges for the RootQueryToEnqueuedScriptConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToEnqueuedScriptConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<EnqueuedScript>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToEnqueuedScriptConnectionEdge = {
  __typename?: 'RootQueryToEnqueuedScriptConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<EnqueuedScript>;
};

/** Connection between the RootQuery type and the EnqueuedStylesheet type */
export type RootQueryToEnqueuedStylesheetConnection = {
  __typename?: 'RootQueryToEnqueuedStylesheetConnection';
  /** Edges for the RootQueryToEnqueuedStylesheetConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToEnqueuedStylesheetConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<EnqueuedStylesheet>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToEnqueuedStylesheetConnectionEdge = {
  __typename?: 'RootQueryToEnqueuedStylesheetConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<EnqueuedStylesheet>;
};

/** Connection between the RootQuery type and the mediaItem type */
export type RootQueryToMediaItemConnection = {
  __typename?: 'RootQueryToMediaItemConnection';
  /** Edges for the RootQueryToMediaItemConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToMediaItemConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<MediaItem>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToMediaItemConnectionEdge = {
  __typename?: 'RootQueryToMediaItemConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<MediaItem>;
};

/** Arguments for filtering the RootQueryToMediaItemConnection connection */
export type RootQueryToMediaItemConnectionWhereArgs = {
  /** The user that's connected as the author of the object. Use the userId for the author object. */
  author?: InputMaybe<Scalars['Int']>;
  /** Find objects connected to author(s) in the array of author's userIds */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Find objects connected to the author by the author's nicename */
  authorName?: InputMaybe<Scalars['String']>;
  /** Find objects NOT connected to author(s) in the array of author's userIds */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the RootQuery type and the Menu type */
export type RootQueryToMenuConnection = {
  __typename?: 'RootQueryToMenuConnection';
  /** Edges for the RootQueryToMenuConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToMenuConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Menu>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToMenuConnectionEdge = {
  __typename?: 'RootQueryToMenuConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Menu>;
};

/** Arguments for filtering the RootQueryToMenuConnection connection */
export type RootQueryToMenuConnectionWhereArgs = {
  /** The database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** The menu location for the menu being queried */
  location?: InputMaybe<MenuLocationEnum>;
  /** The slug of the menu to query items for */
  slug?: InputMaybe<Scalars['String']>;
};

/** Connection between the RootQuery type and the MenuItem type */
export type RootQueryToMenuItemConnection = {
  __typename?: 'RootQueryToMenuItemConnection';
  /** Edges for the RootQueryToMenuItemConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToMenuItemConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<MenuItem>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToMenuItemConnectionEdge = {
  __typename?: 'RootQueryToMenuItemConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<MenuItem>;
};

/** Arguments for filtering the RootQueryToMenuItemConnection connection */
export type RootQueryToMenuItemConnectionWhereArgs = {
  /** The database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** The menu location for the menu being queried */
  location?: InputMaybe<MenuLocationEnum>;
  /** The database ID of the parent menu object */
  parentDatabaseId?: InputMaybe<Scalars['Int']>;
  /** The ID of the parent menu object */
  parentId?: InputMaybe<Scalars['ID']>;
};

/** Connection between the RootQuery type and the page type */
export type RootQueryToPageConnection = {
  __typename?: 'RootQueryToPageConnection';
  /** Edges for the RootQueryToPageConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToPageConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Page>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToPageConnectionEdge = {
  __typename?: 'RootQueryToPageConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Page>;
};

/** Arguments for filtering the RootQueryToPageConnection connection */
export type RootQueryToPageConnectionWhereArgs = {
  /** The user that's connected as the author of the object. Use the userId for the author object. */
  author?: InputMaybe<Scalars['Int']>;
  /** Find objects connected to author(s) in the array of author's userIds */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Find objects connected to the author by the author's nicename */
  authorName?: InputMaybe<Scalars['String']>;
  /** Find objects NOT connected to author(s) in the array of author's userIds */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the RootQuery type and the Plugin type */
export type RootQueryToPluginConnection = {
  __typename?: 'RootQueryToPluginConnection';
  /** Edges for the RootQueryToPluginConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToPluginConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Plugin>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToPluginConnectionEdge = {
  __typename?: 'RootQueryToPluginConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Plugin>;
};

/** Arguments for filtering the RootQueryToPluginConnection connection */
export type RootQueryToPluginConnectionWhereArgs = {
  /** Show plugin based on a keyword search. */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve plugins where plugin status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PluginStatusEnum>>>;
  /** Show plugins with a specific status. */
  status?: InputMaybe<PluginStatusEnum>;
};

/** Connection between the RootQuery type and the post type */
export type RootQueryToPostConnection = {
  __typename?: 'RootQueryToPostConnection';
  /** Edges for the RootQueryToPostConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToPostConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Post>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToPostConnectionEdge = {
  __typename?: 'RootQueryToPostConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Post>;
};

/** Arguments for filtering the RootQueryToPostConnection connection */
export type RootQueryToPostConnectionWhereArgs = {
  /** The user that's connected as the author of the object. Use the userId for the author object. */
  author?: InputMaybe<Scalars['Int']>;
  /** Find objects connected to author(s) in the array of author's userIds */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Find objects connected to the author by the author's nicename */
  authorName?: InputMaybe<Scalars['String']>;
  /** Find objects NOT connected to author(s) in the array of author's userIds */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Category ID */
  categoryId?: InputMaybe<Scalars['Int']>;
  /** Array of category IDs, used to display objects from one category OR another */
  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Use Category Slug */
  categoryName?: InputMaybe<Scalars['String']>;
  /** Array of category IDs, used to display objects from one category OR another */
  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Tag Slug */
  tag?: InputMaybe<Scalars['String']>;
  /** Use Tag ID */
  tagId?: InputMaybe<Scalars['String']>;
  /** Array of tag IDs, used to display objects from one tag OR another */
  tagIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of tag IDs, used to display objects from one tag OR another */
  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of tag slugs, used to display objects from one tag OR another */
  tagSlugAnd?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of tag slugs, used to exclude objects in specified tags */
  tagSlugIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the RootQuery type and the postFormat type */
export type RootQueryToPostFormatConnection = {
  __typename?: 'RootQueryToPostFormatConnection';
  /** Edges for the RootQueryToPostFormatConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToPostFormatConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<PostFormat>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToPostFormatConnectionEdge = {
  __typename?: 'RootQueryToPostFormatConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<PostFormat>;
};

/** Arguments for filtering the RootQueryToPostFormatConnection connection */
export type RootQueryToPostFormatConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the RootQuery type and the ResearchSummariesCategory type */
export type RootQueryToResearchSummariesCategoryConnection = {
  __typename?: 'RootQueryToResearchSummariesCategoryConnection';
  /** Edges for the RootQueryToResearchSummariesCategoryConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToResearchSummariesCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ResearchSummariesCategory>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToResearchSummariesCategoryConnectionEdge = {
  __typename?: 'RootQueryToResearchSummariesCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ResearchSummariesCategory>;
};

/** Arguments for filtering the RootQueryToResearchSummariesCategoryConnection connection */
export type RootQueryToResearchSummariesCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the RootQuery type and the ResearchSummary type */
export type RootQueryToResearchSummaryConnection = {
  __typename?: 'RootQueryToResearchSummaryConnection';
  /** Edges for the RootQueryToResearchSummaryConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToResearchSummaryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ResearchSummary>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToResearchSummaryConnectionEdge = {
  __typename?: 'RootQueryToResearchSummaryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ResearchSummary>;
};

/** Arguments for filtering the RootQueryToResearchSummaryConnection connection */
export type RootQueryToResearchSummaryConnectionWhereArgs = {
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the RootQuery type and the ResourceCategory type */
export type RootQueryToResourceCategoryConnection = {
  __typename?: 'RootQueryToResourceCategoryConnection';
  /** Edges for the RootQueryToResourceCategoryConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToResourceCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ResourceCategory>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToResourceCategoryConnectionEdge = {
  __typename?: 'RootQueryToResourceCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ResourceCategory>;
};

/** Arguments for filtering the RootQueryToResourceCategoryConnection connection */
export type RootQueryToResourceCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the RootQuery type and the Resource type */
export type RootQueryToResourceConnection = {
  __typename?: 'RootQueryToResourceConnection';
  /** Edges for the RootQueryToResourceConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToResourceConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Resource>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToResourceConnectionEdge = {
  __typename?: 'RootQueryToResourceConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Resource>;
};

/** Arguments for filtering the RootQueryToResourceConnection connection */
export type RootQueryToResourceConnectionWhereArgs = {
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the RootQuery type and the tag type */
export type RootQueryToTagConnection = {
  __typename?: 'RootQueryToTagConnection';
  /** Edges for the RootQueryToTagConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToTagConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Tag>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToTagConnectionEdge = {
  __typename?: 'RootQueryToTagConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Tag>;
};

/** Arguments for filtering the RootQueryToTagConnection connection */
export type RootQueryToTagConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the RootQuery type and the Taxonomy type */
export type RootQueryToTaxonomyConnection = {
  __typename?: 'RootQueryToTaxonomyConnection';
  /** Edges for the RootQueryToTaxonomyConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToTaxonomyConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Taxonomy>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToTaxonomyConnectionEdge = {
  __typename?: 'RootQueryToTaxonomyConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Taxonomy>;
};

/** Connection between the RootQuery type and the TermNode type */
export type RootQueryToTermNodeConnection = {
  __typename?: 'RootQueryToTermNodeConnection';
  /** Edges for the RootQueryToTermNodeConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToTermNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<TermNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToTermNodeConnectionEdge = {
  __typename?: 'RootQueryToTermNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<TermNode>;
};

/** Arguments for filtering the RootQueryToTermNodeConnection connection */
export type RootQueryToTermNodeConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** The Taxonomy to filter terms by */
  taxonomies?: InputMaybe<Array<InputMaybe<TaxonomyEnum>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the RootQuery type and the Theme type */
export type RootQueryToThemeConnection = {
  __typename?: 'RootQueryToThemeConnection';
  /** Edges for the RootQueryToThemeConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToThemeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Theme>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToThemeConnectionEdge = {
  __typename?: 'RootQueryToThemeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Theme>;
};

/** Connection between the RootQuery type and the User type */
export type RootQueryToUserConnection = {
  __typename?: 'RootQueryToUserConnection';
  /** Edges for the RootQueryToUserConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToUserConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<User>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToUserConnectionEdge = {
  __typename?: 'RootQueryToUserConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<User>;
};

/** Arguments for filtering the RootQueryToUserConnection connection */
export type RootQueryToUserConnectionWhereArgs = {
  /** Array of userIds to exclude. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** Pass an array of post types to filter results to users who have published posts in those post types. */
  hasPublishedPosts?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Array of userIds to include. */
  include?: InputMaybe<Array<InputMaybe<Scalars['Int']>>>;
  /** The user login. */
  login?: InputMaybe<Scalars['String']>;
  /** An array of logins to include. Users matching one of these logins will be included in results. */
  loginIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** An array of logins to exclude. Users matching one of these logins will not be included in results. */
  loginNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** The user nicename. */
  nicename?: InputMaybe<Scalars['String']>;
  /** An array of nicenames to include. Users matching one of these nicenames will be included in results. */
  nicenameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** An array of nicenames to exclude. Users matching one of these nicenames will not be included in results. */
  nicenameNotIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<UsersConnectionOrderbyInput>>>;
  /** An array of role names that users must match to be included in results. Note that this is an inclusive list: users must match *each* role. */
  role?: InputMaybe<UserRoleEnum>;
  /** An array of role names. Matched users must have at least one of these roles. */
  roleIn?: InputMaybe<Array<InputMaybe<UserRoleEnum>>>;
  /** An array of role names to exclude. Users matching one or more of these roles will not be included in results. */
  roleNotIn?: InputMaybe<Array<InputMaybe<UserRoleEnum>>>;
  /** Search keyword. Searches for possible string matches on columns. When "searchColumns" is left empty, it tries to determine which column to search in based on search string. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of column names to be searched. Accepts 'ID', 'login', 'nicename', 'email', 'url'. */
  searchColumns?: InputMaybe<Array<InputMaybe<UsersConnectionSearchColumnEnum>>>;
};

/** Connection between the RootQuery type and the UserRole type */
export type RootQueryToUserRoleConnection = {
  __typename?: 'RootQueryToUserRoleConnection';
  /** Edges for the RootQueryToUserRoleConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToUserRoleConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<UserRole>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToUserRoleConnectionEdge = {
  __typename?: 'RootQueryToUserRoleConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<UserRole>;
};

/** Connection between the RootQuery type and the VideoSeriesCategory type */
export type RootQueryToVideoSeriesCategoryConnection = {
  __typename?: 'RootQueryToVideoSeriesCategoryConnection';
  /** Edges for the RootQueryToVideoSeriesCategoryConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToVideoSeriesCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<VideoSeriesCategory>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToVideoSeriesCategoryConnectionEdge = {
  __typename?: 'RootQueryToVideoSeriesCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<VideoSeriesCategory>;
};

/** Arguments for filtering the RootQueryToVideoSeriesCategoryConnection connection */
export type RootQueryToVideoSeriesCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the RootQuery type and the VideoSeriesItem type */
export type RootQueryToVideoSeriesItemConnection = {
  __typename?: 'RootQueryToVideoSeriesItemConnection';
  /** Edges for the RootQueryToVideoSeriesItemConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToVideoSeriesItemConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<VideoSeriesItem>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToVideoSeriesItemConnectionEdge = {
  __typename?: 'RootQueryToVideoSeriesItemConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<VideoSeriesItem>;
};

/** Arguments for filtering the RootQueryToVideoSeriesItemConnection connection */
export type RootQueryToVideoSeriesItemConnectionWhereArgs = {
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the RootQuery type and the Webinar type */
export type RootQueryToWebinarConnection = {
  __typename?: 'RootQueryToWebinarConnection';
  /** Edges for the RootQueryToWebinarConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToWebinarConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Webinar>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToWebinarConnectionEdge = {
  __typename?: 'RootQueryToWebinarConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Webinar>;
};

/** Arguments for filtering the RootQueryToWebinarConnection connection */
export type RootQueryToWebinarConnectionWhereArgs = {
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the RootQuery type and the WebinarsCategory type */
export type RootQueryToWebinarsCategoryConnection = {
  __typename?: 'RootQueryToWebinarsCategoryConnection';
  /** Edges for the RootQueryToWebinarsCategoryConnection connection */
  edges?: Maybe<Array<Maybe<RootQueryToWebinarsCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<WebinarsCategory>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type RootQueryToWebinarsCategoryConnectionEdge = {
  __typename?: 'RootQueryToWebinarsCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<WebinarsCategory>;
};

/** Arguments for filtering the RootQueryToWebinarsCategoryConnection connection */
export type RootQueryToWebinarsCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

export type SearchTrainer = {
  __typename?: 'SearchTrainer';
  availability?: Maybe<SearchTrainerAvailability>;
  avatar?: Maybe<Scalars['String']>;
  fullName: Scalars['String'];
  id: Scalars['uuid'];
  levels: Array<CourseCertificateLevel>;
  trainer_role_types: Array<TrainerRoleType>;
};

export enum SearchTrainerAvailability {
  Available = 'AVAILABLE',
  Expired = 'EXPIRED',
  Pending = 'PENDING',
  Unavailable = 'UNAVAILABLE'
}

export type SearchTrainersInput = {
  courseEnd?: InputMaybe<Scalars['date']>;
  courseLevel?: InputMaybe<CourseLevel>;
  courseStart?: InputMaybe<Scalars['date']>;
  query?: InputMaybe<Scalars['String']>;
  trainerType?: InputMaybe<CourseTrainerType>;
};

/** Input for the sendPasswordResetEmail mutation */
export type SendPasswordResetEmailInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A string that contains the user's username or email address. */
  username: Scalars['String'];
};

/** The payload for the sendPasswordResetEmail mutation */
export type SendPasswordResetEmailPayload = {
  __typename?: 'SendPasswordResetEmailPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The user that the password reset email was sent to */
  user?: Maybe<User>;
};

/** All of the registered settings */
export type Settings = {
  __typename?: 'Settings';
  /** Settings of the the string Settings Group */
  discussionSettingsDefaultCommentStatus?: Maybe<Scalars['String']>;
  /** Settings of the the string Settings Group */
  discussionSettingsDefaultPingStatus?: Maybe<Scalars['String']>;
  /** Settings of the the string Settings Group */
  generalSettingsDateFormat?: Maybe<Scalars['String']>;
  /** Settings of the the string Settings Group */
  generalSettingsDescription?: Maybe<Scalars['String']>;
  /** Settings of the the string Settings Group */
  generalSettingsEmail?: Maybe<Scalars['String']>;
  /** Settings of the the string Settings Group */
  generalSettingsLanguage?: Maybe<Scalars['String']>;
  /** Settings of the the integer Settings Group */
  generalSettingsStartOfWeek?: Maybe<Scalars['Int']>;
  /** Settings of the the string Settings Group */
  generalSettingsTimeFormat?: Maybe<Scalars['String']>;
  /** Settings of the the string Settings Group */
  generalSettingsTimezone?: Maybe<Scalars['String']>;
  /** Settings of the the string Settings Group */
  generalSettingsTitle?: Maybe<Scalars['String']>;
  /** Settings of the the string Settings Group */
  generalSettingsUrl?: Maybe<Scalars['String']>;
  /** Settings of the the integer Settings Group */
  readingSettingsPageForPosts?: Maybe<Scalars['Int']>;
  /** Settings of the the integer Settings Group */
  readingSettingsPageOnFront?: Maybe<Scalars['Int']>;
  /** Settings of the the integer Settings Group */
  readingSettingsPostsPerPage?: Maybe<Scalars['Int']>;
  /** Settings of the the string Settings Group */
  readingSettingsShowOnFront?: Maybe<Scalars['String']>;
  /** Settings of the the integer Settings Group */
  writingSettingsDefaultCategory?: Maybe<Scalars['Int']>;
  /** Settings of the the string Settings Group */
  writingSettingsDefaultPostFormat?: Maybe<Scalars['String']>;
  /** Settings of the the boolean Settings Group */
  writingSettingsUseSmilies?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['String']>;
  _gt?: InputMaybe<Scalars['String']>;
  _gte?: InputMaybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']>;
  _in?: InputMaybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']>;
  _lt?: InputMaybe<Scalars['String']>;
  _lte?: InputMaybe<Scalars['String']>;
  _neq?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']>;
  _nin?: InputMaybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']>;
};

export type StripeCreatePaymentIntentInput = {
  orderId: Scalars['String'];
};

export type StripeCreatePaymentIntentOutput = {
  __typename?: 'StripeCreatePaymentIntentOutput';
  amount: Scalars['Float'];
  clientSecret: Scalars['String'];
  currency: Currency;
};

/** The tag type */
export type Tag = DatabaseIdentifier & MenuItemLinkable & Node & TermNode & UniformResourceIdentifiable & {
  __typename?: 'Tag';
  /** Connection between the tag type and the ContentNode type */
  contentNodes?: Maybe<TagToContentNodeConnection>;
  /** The number of objects connected to the object */
  count?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** The description of the object */
  description?: Maybe<Scalars['String']>;
  /** Connection between the TermNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<TermNodeToEnqueuedScriptConnection>;
  /** Connection between the TermNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<TermNodeToEnqueuedStylesheetConnection>;
  /** The unique resource identifier path */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The link to the term */
  link?: Maybe<Scalars['String']>;
  /** The human friendly name of the object. */
  name?: Maybe<Scalars['String']>;
  /** Connection between the tag type and the post type */
  posts?: Maybe<TagToPostConnection>;
  /** An alphanumeric identifier for the object unique to its type. */
  slug?: Maybe<Scalars['String']>;
  /** The id field matches the WP_Post-&gt;ID field. */
  tagId?: Maybe<Scalars['Int']>;
  /** Connection between the tag type and the Taxonomy type */
  taxonomy?: Maybe<TagToTaxonomyConnectionEdge>;
  /** The name of the taxonomy that the object is associated with */
  taxonomyName?: Maybe<Scalars['String']>;
  /** The ID of the term group that this term object belongs to */
  termGroupId?: Maybe<Scalars['Int']>;
  /** The taxonomy ID that the object is associated with */
  termTaxonomyId?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** The tag type */
export type TagContentNodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TagToContentNodeConnectionWhereArgs>;
};


/** The tag type */
export type TagEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The tag type */
export type TagEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The tag type */
export type TagPostsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TagToPostConnectionWhereArgs>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum TagIdType {
  /** The Database ID for the node */
  DatabaseId = 'DATABASE_ID',
  /** The hashed Global ID */
  Id = 'ID',
  /** The name of the node */
  Name = 'NAME',
  /** Url friendly name of the node */
  Slug = 'SLUG',
  /** The URI for the node */
  Uri = 'URI'
}

/** Connection between the tag type and the ContentNode type */
export type TagToContentNodeConnection = {
  __typename?: 'TagToContentNodeConnection';
  /** Edges for the TagToContentNodeConnection connection */
  edges?: Maybe<Array<Maybe<TagToContentNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type TagToContentNodeConnectionEdge = {
  __typename?: 'TagToContentNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentNode>;
};

/** Arguments for filtering the TagToContentNodeConnection connection */
export type TagToContentNodeConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfTagEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the tag type and the post type */
export type TagToPostConnection = {
  __typename?: 'TagToPostConnection';
  /** Edges for the TagToPostConnection connection */
  edges?: Maybe<Array<Maybe<TagToPostConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Post>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type TagToPostConnectionEdge = {
  __typename?: 'TagToPostConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Post>;
};

/** Arguments for filtering the TagToPostConnection connection */
export type TagToPostConnectionWhereArgs = {
  /** The user that's connected as the author of the object. Use the userId for the author object. */
  author?: InputMaybe<Scalars['Int']>;
  /** Find objects connected to author(s) in the array of author's userIds */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Find objects connected to the author by the author's nicename */
  authorName?: InputMaybe<Scalars['String']>;
  /** Find objects NOT connected to author(s) in the array of author's userIds */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Category ID */
  categoryId?: InputMaybe<Scalars['Int']>;
  /** Array of category IDs, used to display objects from one category OR another */
  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Use Category Slug */
  categoryName?: InputMaybe<Scalars['String']>;
  /** Array of category IDs, used to display objects from one category OR another */
  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Tag Slug */
  tag?: InputMaybe<Scalars['String']>;
  /** Use Tag ID */
  tagId?: InputMaybe<Scalars['String']>;
  /** Array of tag IDs, used to display objects from one tag OR another */
  tagIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of tag IDs, used to display objects from one tag OR another */
  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of tag slugs, used to display objects from one tag OR another */
  tagSlugAnd?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of tag slugs, used to exclude objects in specified tags */
  tagSlugIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the tag type and the Taxonomy type */
export type TagToTaxonomyConnectionEdge = {
  __typename?: 'TagToTaxonomyConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Taxonomy>;
};

/** A taxonomy object */
export type Taxonomy = Node & {
  __typename?: 'Taxonomy';
  /** List of Content Types associated with the Taxonomy */
  connectedContentTypes?: Maybe<TaxonomyToContentTypeConnection>;
  /** Description of the taxonomy. This field is equivalent to WP_Taxonomy-&gt;description */
  description?: Maybe<Scalars['String']>;
  /** The plural name of the post type within the GraphQL Schema. */
  graphqlPluralName?: Maybe<Scalars['String']>;
  /** The singular name of the post type within the GraphQL Schema. */
  graphqlSingleName?: Maybe<Scalars['String']>;
  /** Whether the taxonomy is hierarchical */
  hierarchical?: Maybe<Scalars['Boolean']>;
  /** The globally unique identifier of the taxonomy object. */
  id: Scalars['ID'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Name of the taxonomy shown in the menu. Usually plural. */
  label?: Maybe<Scalars['String']>;
  /** The display name of the taxonomy. This field is equivalent to WP_Taxonomy-&gt;label */
  name?: Maybe<Scalars['String']>;
  /** Whether the taxonomy is publicly queryable */
  public?: Maybe<Scalars['Boolean']>;
  /** Name of content type to diplay in REST API &quot;wp/v2&quot; namespace. */
  restBase?: Maybe<Scalars['String']>;
  /** The REST Controller class assigned to handling this content type. */
  restControllerClass?: Maybe<Scalars['String']>;
  /** Whether to show the taxonomy as part of a tag cloud widget. This field is equivalent to WP_Taxonomy-&gt;show_tagcloud */
  showCloud?: Maybe<Scalars['Boolean']>;
  /** Whether to display a column for the taxonomy on its post type listing screens. */
  showInAdminColumn?: Maybe<Scalars['Boolean']>;
  /** Whether to add the post type to the GraphQL Schema. */
  showInGraphql?: Maybe<Scalars['Boolean']>;
  /** Whether to show the taxonomy in the admin menu */
  showInMenu?: Maybe<Scalars['Boolean']>;
  /** Whether the taxonomy is available for selection in navigation menus. */
  showInNavMenus?: Maybe<Scalars['Boolean']>;
  /** Whether to show the taxonomy in the quick/bulk edit panel. */
  showInQuickEdit?: Maybe<Scalars['Boolean']>;
  /** Whether to add the post type route in the REST API &quot;wp/v2&quot; namespace. */
  showInRest?: Maybe<Scalars['Boolean']>;
  /** Whether to generate and allow a UI for managing terms in this taxonomy in the admin */
  showUi?: Maybe<Scalars['Boolean']>;
};


/** A taxonomy object */
export type TaxonomyConnectedContentTypesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** Allowed taxonomies */
export enum TaxonomyEnum {
  /** Taxonomy enum category */
  Category = 'CATEGORY',
  /** Taxonomy enum ebooks_category */
  Ebookscategory = 'EBOOKSCATEGORY',
  /** Taxonomy enum post_format */
  Postformat = 'POSTFORMAT',
  /** Taxonomy enum research_summaries_category */
  Researchsummariescategory = 'RESEARCHSUMMARIESCATEGORY',
  /** Taxonomy enum resource_category */
  Resourcecategory = 'RESOURCECATEGORY',
  /** Taxonomy enum post_tag */
  Tag = 'TAG',
  /** Taxonomy enum video_series_category */
  Videoseriescategory = 'VIDEOSERIESCATEGORY',
  /** Taxonomy enum webinars_category */
  Webinarscategory = 'WEBINARSCATEGORY'
}

/** The Type of Identifier used to fetch a single Taxonomy node. To be used along with the "id" field. Default is "ID". */
export enum TaxonomyIdTypeEnum {
  /** The globally unique ID */
  Id = 'ID',
  /** The name of the taxonomy */
  Name = 'NAME'
}

/** Connection between the Taxonomy type and the ContentType type */
export type TaxonomyToContentTypeConnection = {
  __typename?: 'TaxonomyToContentTypeConnection';
  /** Edges for the TaxonomyToContentTypeConnection connection */
  edges?: Maybe<Array<Maybe<TaxonomyToContentTypeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentType>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type TaxonomyToContentTypeConnectionEdge = {
  __typename?: 'TaxonomyToContentTypeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentType>;
};

/** The template assigned to the node */
export type Template_100Width = ContentTemplate & {
  __typename?: 'Template_100Width';
  /** The name of the template */
  templateName?: Maybe<Scalars['String']>;
};

/** The template assigned to the node */
export type Template_BlankPage = ContentTemplate & {
  __typename?: 'Template_BlankPage';
  /** The name of the template */
  templateName?: Maybe<Scalars['String']>;
};

/** The template assigned to the node */
export type Template_Contact = ContentTemplate & {
  __typename?: 'Template_Contact';
  /** The name of the template */
  templateName?: Maybe<Scalars['String']>;
};

/** The template assigned to the node */
export type Template_SideNavigation = ContentTemplate & {
  __typename?: 'Template_SideNavigation';
  /** The name of the template */
  templateName?: Maybe<Scalars['String']>;
};

/** Terms are nodes within a Taxonomy, used to group and relate other nodes. */
export type TermNode = {
  /** The number of objects connected to the object */
  count?: Maybe<Scalars['Int']>;
  /** Identifies the primary key from the database. */
  databaseId: Scalars['Int'];
  /** The description of the object */
  description?: Maybe<Scalars['String']>;
  /** Connection between the TermNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<TermNodeToEnqueuedScriptConnection>;
  /** Connection between the TermNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<TermNodeToEnqueuedStylesheetConnection>;
  /** The unique resource identifier path */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The link to the term */
  link?: Maybe<Scalars['String']>;
  /** The human friendly name of the object. */
  name?: Maybe<Scalars['String']>;
  /** An alphanumeric identifier for the object unique to its type. */
  slug?: Maybe<Scalars['String']>;
  /** The name of the taxonomy that the object is associated with */
  taxonomyName?: Maybe<Scalars['String']>;
  /** The ID of the term group that this term object belongs to */
  termGroupId?: Maybe<Scalars['Int']>;
  /** The taxonomy ID that the object is associated with */
  termTaxonomyId?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};


/** Terms are nodes within a Taxonomy, used to group and relate other nodes. */
export type TermNodeEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** Terms are nodes within a Taxonomy, used to group and relate other nodes. */
export type TermNodeEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The Type of Identifier used to fetch a single resource. Default is "ID". To be used along with the "id" field. */
export enum TermNodeIdTypeEnum {
  /** The Database ID for the node */
  DatabaseId = 'DATABASE_ID',
  /** The hashed Global ID */
  Id = 'ID',
  /** The name of the node */
  Name = 'NAME',
  /** Url friendly name of the node */
  Slug = 'SLUG',
  /** The URI for the node */
  Uri = 'URI'
}

/** Connection between the TermNode type and the EnqueuedScript type */
export type TermNodeToEnqueuedScriptConnection = {
  __typename?: 'TermNodeToEnqueuedScriptConnection';
  /** Edges for the TermNodeToEnqueuedScriptConnection connection */
  edges?: Maybe<Array<Maybe<TermNodeToEnqueuedScriptConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<EnqueuedScript>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type TermNodeToEnqueuedScriptConnectionEdge = {
  __typename?: 'TermNodeToEnqueuedScriptConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<EnqueuedScript>;
};

/** Connection between the TermNode type and the EnqueuedStylesheet type */
export type TermNodeToEnqueuedStylesheetConnection = {
  __typename?: 'TermNodeToEnqueuedStylesheetConnection';
  /** Edges for the TermNodeToEnqueuedStylesheetConnection connection */
  edges?: Maybe<Array<Maybe<TermNodeToEnqueuedStylesheetConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<EnqueuedStylesheet>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type TermNodeToEnqueuedStylesheetConnectionEdge = {
  __typename?: 'TermNodeToEnqueuedStylesheetConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<EnqueuedStylesheet>;
};

/** Options for ordering the connection by */
export enum TermObjectsConnectionOrderbyEnum {
  /** Order the connection by item count. */
  Count = 'COUNT',
  /** Order the connection by description. */
  Description = 'DESCRIPTION',
  /** Order the connection by name. */
  Name = 'NAME',
  /** Order the connection by slug. */
  Slug = 'SLUG',
  /** Order the connection by term group. */
  TermGroup = 'TERM_GROUP',
  /** Order the connection by term id. */
  TermId = 'TERM_ID',
  /** Order the connection by term order. */
  TermOrder = 'TERM_ORDER'
}

/** A theme object */
export type Theme = Node & {
  __typename?: 'Theme';
  /** Name of the theme author(s), could also be a company name. This field is equivalent to WP_Theme-&gt;get( &quot;Author&quot; ). */
  author?: Maybe<Scalars['String']>;
  /** URI for the author/company website. This field is equivalent to WP_Theme-&gt;get( &quot;AuthorURI&quot; ). */
  authorUri?: Maybe<Scalars['String']>;
  /** The description of the theme. This field is equivalent to WP_Theme-&gt;get( &quot;Description&quot; ). */
  description?: Maybe<Scalars['String']>;
  /** The globally unique identifier of the theme object. */
  id: Scalars['ID'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Display name of the theme. This field is equivalent to WP_Theme-&gt;get( &quot;Name&quot; ). */
  name?: Maybe<Scalars['String']>;
  /** The URL of the screenshot for the theme. The screenshot is intended to give an overview of what the theme looks like. This field is equivalent to WP_Theme-&gt;get_screenshot(). */
  screenshot?: Maybe<Scalars['String']>;
  /** The theme slug is used to internally match themes. Theme slugs can have subdirectories like: my-theme/sub-theme. This field is equivalent to WP_Theme-&gt;get_stylesheet(). */
  slug?: Maybe<Scalars['String']>;
  /** URI for the author/company website. This field is equivalent to WP_Theme-&gt;get( &quot;Tags&quot; ). */
  tags?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** A URI if the theme has a website associated with it. The Theme URI is handy for directing users to a theme site for support etc. This field is equivalent to WP_Theme-&gt;get( &quot;ThemeURI&quot; ). */
  themeUri?: Maybe<Scalars['String']>;
  /** The current version of the theme. This field is equivalent to WP_Theme-&gt;get( &quot;Version&quot; ). */
  version?: Maybe<Scalars['String']>;
};

export type TrainerLevels = {
  __typename?: 'TrainerLevels';
  availability: SearchTrainerAvailability;
  levels: Array<CourseLevel>;
  profile_id: Scalars['uuid'];
};

export type TrainerRoleType = {
  __typename?: 'TrainerRoleType';
  trainerRoleType?: Maybe<TrainerRoleTypeObj>;
};

export type TrainerRoleTypeObj = {
  __typename?: 'TrainerRoleTypeObj';
  id: Scalars['String'];
  name: Scalars['String'];
};

export type TransferCourse = {
  __typename?: 'TransferCourse';
  courseCode: Scalars['String'];
  endDate: Scalars['String'];
  id: Scalars['Int'];
  startDate: Scalars['String'];
  venue?: Maybe<Scalars['String']>;
  venueCity?: Maybe<Scalars['String']>;
  venueName?: Maybe<Scalars['String']>;
  virtualLink?: Maybe<Scalars['String']>;
};

export type TransferFee = {
  customFee?: InputMaybe<Scalars['Int']>;
  type: TransferFeeType;
};

export enum TransferFeeType {
  ApplyTerms = 'APPLY_TERMS',
  CustomFee = 'CUSTOM_FEE',
  Free = 'FREE'
}

export type TransferInput = {
  fee: TransferFee;
  participantId: Scalars['uuid'];
  toCourseId: Scalars['Int'];
};

export type TransferParticipantOutput = {
  __typename?: 'TransferParticipantOutput';
  error?: Maybe<Scalars['String']>;
  success: Scalars['Boolean'];
};

/** Any node that has a URI */
export type UniformResourceIdentifiable = {
  /** The unique resource identifier path */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
};

export type UpdateAvatarResponse = {
  __typename?: 'UpdateAvatarResponse';
  avatar: Scalars['String'];
};

/** Input for the UpdateCategory mutation */
export type UpdateCategoryInput = {
  /** The slug that the category will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the category object */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the category object to update */
  id: Scalars['ID'];
  /** The name of the category object to mutate */
  name?: InputMaybe<Scalars['String']>;
  /** The ID of the category that should be set as the parent */
  parentId?: InputMaybe<Scalars['ID']>;
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the UpdateCategory mutation */
export type UpdateCategoryPayload = {
  __typename?: 'UpdateCategoryPayload';
  /** The created category */
  category?: Maybe<Category>;
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Input for the updateComment mutation */
export type UpdateCommentInput = {
  /** The approval status of the comment. */
  approved?: InputMaybe<Scalars['String']>;
  /** The name of the comment's author. */
  author?: InputMaybe<Scalars['String']>;
  /** The email of the comment's author. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** The url of the comment's author. */
  authorUrl?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The database ID of the post object the comment belongs to. */
  commentOn?: InputMaybe<Scalars['Int']>;
  /** Content of the comment. */
  content?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day ( e.g. 01/31/2017 ) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** The ID of the comment being updated. */
  id: Scalars['ID'];
  /** Parent comment ID of current comment. */
  parent?: InputMaybe<Scalars['ID']>;
  /** Type of comment. */
  type?: InputMaybe<Scalars['String']>;
};

/** The payload for the updateComment mutation */
export type UpdateCommentPayload = {
  __typename?: 'UpdateCommentPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The comment that was created */
  comment?: Maybe<Comment>;
  /** Whether the mutation succeeded. If the comment is not approved, the server will not return the comment to a non authenticated user, but a success message can be returned if the create succeeded, and the client can optimistically add the comment to the client cache */
  success?: Maybe<Scalars['Boolean']>;
};

/** Input for the updateEbook mutation */
export type UpdateEbookInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** Set connections between the Ebook and EbooksCategories */
  ebooksCategories?: InputMaybe<EbookEbooksCategoriesInput>;
  /** The excerpt of the object */
  excerpt?: InputMaybe<Scalars['String']>;
  /** The ID of the Ebook object */
  id: Scalars['ID'];
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** The payload for the updateEbook mutation */
export type UpdateEbookPayload = {
  __typename?: 'UpdateEbookPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  ebook?: Maybe<Ebook>;
};

/** Input for the UpdateEbooksCategory mutation */
export type UpdateEbooksCategoryInput = {
  /** The slug that the ebooks_category will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the ebooks_category object */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the EbooksCategory object to update */
  id: Scalars['ID'];
  /** The name of the ebooks_category object to mutate */
  name?: InputMaybe<Scalars['String']>;
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the UpdateEbooksCategory mutation */
export type UpdateEbooksCategoryPayload = {
  __typename?: 'UpdateEbooksCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created ebooks_category */
  ebooksCategory?: Maybe<EbooksCategory>;
};

/** Input for the updateMediaItem mutation */
export type UpdateMediaItemInput = {
  /** Alternative text to display when mediaItem is not displayed */
  altText?: InputMaybe<Scalars['String']>;
  /** The userId to assign as the author of the mediaItem */
  authorId?: InputMaybe<Scalars['ID']>;
  /** The caption for the mediaItem */
  caption?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The comment status for the mediaItem */
  commentStatus?: InputMaybe<Scalars['String']>;
  /** The date of the mediaItem */
  date?: InputMaybe<Scalars['String']>;
  /** The date (in GMT zone) of the mediaItem */
  dateGmt?: InputMaybe<Scalars['String']>;
  /** Description of the mediaItem */
  description?: InputMaybe<Scalars['String']>;
  /** The file name of the mediaItem */
  filePath?: InputMaybe<Scalars['String']>;
  /** The file type of the mediaItem */
  fileType?: InputMaybe<MimeTypeEnum>;
  /** The ID of the mediaItem object */
  id: Scalars['ID'];
  /** The ID of the parent object */
  parentId?: InputMaybe<Scalars['ID']>;
  /** The ping status for the mediaItem */
  pingStatus?: InputMaybe<Scalars['String']>;
  /** The slug of the mediaItem */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the mediaItem */
  status?: InputMaybe<MediaItemStatusEnum>;
  /** The title of the mediaItem */
  title?: InputMaybe<Scalars['String']>;
};

/** The payload for the updateMediaItem mutation */
export type UpdateMediaItemPayload = {
  __typename?: 'UpdateMediaItemPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The MediaItem object mutation type. */
  mediaItem?: Maybe<MediaItem>;
};

/** Input for the updatePage mutation */
export type UpdatePageInput = {
  /** The userId to assign as the author of the object */
  authorId?: InputMaybe<Scalars['ID']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The comment status for the object */
  commentStatus?: InputMaybe<Scalars['String']>;
  /** The content of the object */
  content?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** The ID of the page object */
  id: Scalars['ID'];
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The ID of the parent object */
  parentId?: InputMaybe<Scalars['ID']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** The payload for the updatePage mutation */
export type UpdatePagePayload = {
  __typename?: 'UpdatePagePayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  page?: Maybe<Page>;
};

/** Input for the UpdatePostFormat mutation */
export type UpdatePostFormatInput = {
  /** The slug that the post_format will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the post_format object */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the postFormat object to update */
  id: Scalars['ID'];
  /** The name of the post_format object to mutate */
  name?: InputMaybe<Scalars['String']>;
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the UpdatePostFormat mutation */
export type UpdatePostFormatPayload = {
  __typename?: 'UpdatePostFormatPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created post_format */
  postFormat?: Maybe<PostFormat>;
};

/** Input for the updatePost mutation */
export type UpdatePostInput = {
  /** The userId to assign as the author of the object */
  authorId?: InputMaybe<Scalars['ID']>;
  /** Set connections between the post and categories */
  categories?: InputMaybe<PostCategoriesInput>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The comment status for the object */
  commentStatus?: InputMaybe<Scalars['String']>;
  /** The content of the object */
  content?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** The excerpt of the object */
  excerpt?: InputMaybe<Scalars['String']>;
  /** The ID of the post object */
  id: Scalars['ID'];
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** The ping status for the object */
  pingStatus?: InputMaybe<Scalars['String']>;
  /** URLs that have been pinged. */
  pinged?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Set connections between the post and postFormats */
  postFormats?: InputMaybe<PostPostFormatsInput>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** Set connections between the post and tags */
  tags?: InputMaybe<PostTagsInput>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
  /** URLs queued to be pinged. */
  toPing?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
};

/** The payload for the updatePost mutation */
export type UpdatePostPayload = {
  __typename?: 'UpdatePostPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  post?: Maybe<Post>;
};

/** Input for the UpdateResearchSummariesCategory mutation */
export type UpdateResearchSummariesCategoryInput = {
  /** The slug that the research_summaries_category will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the research_summaries_category object */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the ResearchSummariesCategory object to update */
  id: Scalars['ID'];
  /** The name of the research_summaries_category object to mutate */
  name?: InputMaybe<Scalars['String']>;
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the UpdateResearchSummariesCategory mutation */
export type UpdateResearchSummariesCategoryPayload = {
  __typename?: 'UpdateResearchSummariesCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created research_summaries_category */
  researchSummariesCategory?: Maybe<ResearchSummariesCategory>;
};

/** Input for the updateResearchSummary mutation */
export type UpdateResearchSummaryInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** The excerpt of the object */
  excerpt?: InputMaybe<Scalars['String']>;
  /** The ID of the ResearchSummary object */
  id: Scalars['ID'];
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** Set connections between the ResearchSummary and ResearchSummariesCategories */
  researchSummariesCategories?: InputMaybe<ResearchSummaryResearchSummariesCategoriesInput>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** The payload for the updateResearchSummary mutation */
export type UpdateResearchSummaryPayload = {
  __typename?: 'UpdateResearchSummaryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  researchSummary?: Maybe<ResearchSummary>;
};

/** Input for the UpdateResourceCategory mutation */
export type UpdateResourceCategoryInput = {
  /** The slug that the resource_category will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the resource_category object */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the ResourceCategory object to update */
  id: Scalars['ID'];
  /** The name of the resource_category object to mutate */
  name?: InputMaybe<Scalars['String']>;
  /** The ID of the resource_category that should be set as the parent */
  parentId?: InputMaybe<Scalars['ID']>;
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the UpdateResourceCategory mutation */
export type UpdateResourceCategoryPayload = {
  __typename?: 'UpdateResourceCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created resource_category */
  resourceCategory?: Maybe<ResourceCategory>;
};

/** Input for the updateResource mutation */
export type UpdateResourceInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** The ID of the Resource object */
  id: Scalars['ID'];
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** Set connections between the Resource and ResourceCategories */
  resourceCategories?: InputMaybe<ResourceResourceCategoriesInput>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** The payload for the updateResource mutation */
export type UpdateResourcePayload = {
  __typename?: 'UpdateResourcePayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  resource?: Maybe<Resource>;
};

/** Input for the updateSettings mutation */
export type UpdateSettingsInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** Allow people to submit comments on new posts. */
  discussionSettingsDefaultCommentStatus?: InputMaybe<Scalars['String']>;
  /** Allow link notifications from other blogs (pingbacks and trackbacks) on new articles. */
  discussionSettingsDefaultPingStatus?: InputMaybe<Scalars['String']>;
  /** A date format for all date strings. */
  generalSettingsDateFormat?: InputMaybe<Scalars['String']>;
  /** Site tagline. */
  generalSettingsDescription?: InputMaybe<Scalars['String']>;
  /** This address is used for admin purposes, like new user notification. */
  generalSettingsEmail?: InputMaybe<Scalars['String']>;
  /** WordPress locale code. */
  generalSettingsLanguage?: InputMaybe<Scalars['String']>;
  /** A day number of the week that the week should start on. */
  generalSettingsStartOfWeek?: InputMaybe<Scalars['Int']>;
  /** A time format for all time strings. */
  generalSettingsTimeFormat?: InputMaybe<Scalars['String']>;
  /** A city in the same timezone as you. */
  generalSettingsTimezone?: InputMaybe<Scalars['String']>;
  /** Site title. */
  generalSettingsTitle?: InputMaybe<Scalars['String']>;
  /** Site URL. */
  generalSettingsUrl?: InputMaybe<Scalars['String']>;
  /** The ID of the page that should display the latest posts */
  readingSettingsPageForPosts?: InputMaybe<Scalars['Int']>;
  /** The ID of the page that should be displayed on the front page */
  readingSettingsPageOnFront?: InputMaybe<Scalars['Int']>;
  /** Blog pages show at most. */
  readingSettingsPostsPerPage?: InputMaybe<Scalars['Int']>;
  /** What to show on the front page */
  readingSettingsShowOnFront?: InputMaybe<Scalars['String']>;
  /** Default post category. */
  writingSettingsDefaultCategory?: InputMaybe<Scalars['Int']>;
  /** Default post format. */
  writingSettingsDefaultPostFormat?: InputMaybe<Scalars['String']>;
  /** Convert emoticons like :-) and :-P to graphics on display. */
  writingSettingsUseSmilies?: InputMaybe<Scalars['Boolean']>;
};

/** The payload for the updateSettings mutation */
export type UpdateSettingsPayload = {
  __typename?: 'UpdateSettingsPayload';
  /** Update all settings. */
  allSettings?: Maybe<Settings>;
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** Update the DiscussionSettings setting. */
  discussionSettings?: Maybe<DiscussionSettings>;
  /** Update the GeneralSettings setting. */
  generalSettings?: Maybe<GeneralSettings>;
  /** Update the ReadingSettings setting. */
  readingSettings?: Maybe<ReadingSettings>;
  /** Update the WritingSettings setting. */
  writingSettings?: Maybe<WritingSettings>;
};

/** Input for the UpdateTag mutation */
export type UpdateTagInput = {
  /** The slug that the post_tag will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the post_tag object */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the tag object to update */
  id: Scalars['ID'];
  /** The name of the post_tag object to mutate */
  name?: InputMaybe<Scalars['String']>;
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the UpdateTag mutation */
export type UpdateTagPayload = {
  __typename?: 'UpdateTagPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created post_tag */
  tag?: Maybe<Tag>;
};

/** Input for the updateUser mutation */
export type UpdateUserInput = {
  /** User's AOL IM account. */
  aim?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** A string containing content about the user. */
  description?: InputMaybe<Scalars['String']>;
  /** A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user). */
  displayName?: InputMaybe<Scalars['String']>;
  /** A string containing the user's email address. */
  email?: InputMaybe<Scalars['String']>;
  /** 	The user's first name. */
  firstName?: InputMaybe<Scalars['String']>;
  /** The ID of the user */
  id: Scalars['ID'];
  /** User's Jabber account. */
  jabber?: InputMaybe<Scalars['String']>;
  /** The user's last name. */
  lastName?: InputMaybe<Scalars['String']>;
  /** User's locale. */
  locale?: InputMaybe<Scalars['String']>;
  /** A string that contains a URL-friendly name for the user. The default is the user's username. */
  nicename?: InputMaybe<Scalars['String']>;
  /** The user's nickname, defaults to the user's username. */
  nickname?: InputMaybe<Scalars['String']>;
  /** A string that contains the plain text password for the user. */
  password?: InputMaybe<Scalars['String']>;
  /** The date the user registered. Format is Y-m-d H:i:s. */
  registered?: InputMaybe<Scalars['String']>;
  /** A string for whether to enable the rich editor or not. False if not empty. */
  richEditing?: InputMaybe<Scalars['String']>;
  /** An array of roles to be assigned to the user. */
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** A string containing the user's URL for the user's web site. */
  websiteUrl?: InputMaybe<Scalars['String']>;
  /** User's Yahoo IM account. */
  yim?: InputMaybe<Scalars['String']>;
};

/** The payload for the updateUser mutation */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The User object mutation type. */
  user?: Maybe<User>;
};

/** Input for the UpdateVideoSeriesCategory mutation */
export type UpdateVideoSeriesCategoryInput = {
  /** The slug that the video_series_category will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the video_series_category object */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the VideoSeriesCategory object to update */
  id: Scalars['ID'];
  /** The name of the video_series_category object to mutate */
  name?: InputMaybe<Scalars['String']>;
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the UpdateVideoSeriesCategory mutation */
export type UpdateVideoSeriesCategoryPayload = {
  __typename?: 'UpdateVideoSeriesCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created video_series_category */
  videoSeriesCategory?: Maybe<VideoSeriesCategory>;
};

/** Input for the updateVideoSeriesItem mutation */
export type UpdateVideoSeriesItemInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** The excerpt of the object */
  excerpt?: InputMaybe<Scalars['String']>;
  /** The ID of the VideoSeriesItem object */
  id: Scalars['ID'];
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
  /** Set connections between the VideoSeriesItem and VideoSeriesCategories */
  videoSeriesCategories?: InputMaybe<VideoSeriesItemVideoSeriesCategoriesInput>;
};

/** The payload for the updateVideoSeriesItem mutation */
export type UpdateVideoSeriesItemPayload = {
  __typename?: 'UpdateVideoSeriesItemPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  videoSeriesItem?: Maybe<VideoSeriesItem>;
};

/** Input for the updateWebinar mutation */
export type UpdateWebinarInput = {
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, "2017" as the input will use current date with timestamp 20:17  */
  date?: InputMaybe<Scalars['String']>;
  /** The excerpt of the object */
  excerpt?: InputMaybe<Scalars['String']>;
  /** The ID of the Webinar object */
  id: Scalars['ID'];
  /** A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types. */
  menuOrder?: InputMaybe<Scalars['Int']>;
  /** The password used to protect the content of the object */
  password?: InputMaybe<Scalars['String']>;
  /** The slug of the object */
  slug?: InputMaybe<Scalars['String']>;
  /** The status of the object */
  status?: InputMaybe<PostStatusEnum>;
  /** The title of the object */
  title?: InputMaybe<Scalars['String']>;
  /** Set connections between the Webinar and WebinarsCategories */
  webinarsCategories?: InputMaybe<WebinarWebinarsCategoriesInput>;
};

/** The payload for the updateWebinar mutation */
export type UpdateWebinarPayload = {
  __typename?: 'UpdateWebinarPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The Post object mutation type. */
  webinar?: Maybe<Webinar>;
};

/** Input for the UpdateWebinarsCategory mutation */
export type UpdateWebinarsCategoryInput = {
  /** The slug that the webinars_category will be an alias of */
  aliasOf?: InputMaybe<Scalars['String']>;
  /** This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  /** The description of the webinars_category object */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the WebinarsCategory object to update */
  id: Scalars['ID'];
  /** The name of the webinars_category object to mutate */
  name?: InputMaybe<Scalars['String']>;
  /** If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name. */
  slug?: InputMaybe<Scalars['String']>;
};

/** The payload for the UpdateWebinarsCategory mutation */
export type UpdateWebinarsCategoryPayload = {
  __typename?: 'UpdateWebinarsCategoryPayload';
  /** If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The created webinars_category */
  webinarsCategory?: Maybe<WebinarsCategory>;
};

export type UpsertZoomMeetingInput = {
  id?: InputMaybe<Scalars['Float']>;
  /** ISO 8601 date string, e.g. '2022-04-18T16:48:04.836Z' */
  startTime?: InputMaybe<Scalars['String']>;
  /** Timezone string, e.g. Europe/London */
  timezone?: InputMaybe<Scalars['String']>;
};

export type UpsertZoomMeetingPayload = {
  __typename?: 'UpsertZoomMeetingPayload';
  meeting?: Maybe<ZoomMeeting>;
  success: Scalars['Boolean'];
  userError?: Maybe<ZoomMeetingNotFoundError>;
};

/** A User object */
export type User = Commenter & DatabaseIdentifier & Node & UniformResourceIdentifiable & {
  __typename?: 'User';
  /** Avatar object for user. The avatar object can be retrieved in different sizes by specifying the size argument. */
  avatar?: Maybe<Avatar>;
  /** User metadata option name. Usually it will be &quot;wp_capabilities&quot;. */
  capKey?: Maybe<Scalars['String']>;
  /** A list of capabilities (permissions) granted to the user */
  capabilities?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Connection between the User type and the Comment type */
  comments?: Maybe<UserToCommentConnection>;
  /** Identifies the primary key from the database. */
  databaseId: Scalars['Int'];
  /** Description of the user. */
  description?: Maybe<Scalars['String']>;
  /** Email address of the user. This is equivalent to the WP_User-&gt;user_email property. */
  email?: Maybe<Scalars['String']>;
  /** Connection between the User type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<UserToEnqueuedScriptConnection>;
  /** Connection between the User type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<UserToEnqueuedStylesheetConnection>;
  /** A complete list of capabilities including capabilities inherited from a role. This is equivalent to the array keys of WP_User-&gt;allcaps. */
  extraCapabilities?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** First name of the user. This is equivalent to the WP_User-&gt;user_first_name property. */
  firstName?: Maybe<Scalars['String']>;
  /** The globally unique identifier for the user object. */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** Last name of the user. This is equivalent to the WP_User-&gt;user_last_name property. */
  lastName?: Maybe<Scalars['String']>;
  /** The preferred language locale set for the user. Value derived from get_user_locale(). */
  locale?: Maybe<Scalars['String']>;
  /** Connection between the User type and the mediaItem type */
  mediaItems?: Maybe<UserToMediaItemConnection>;
  /** Display name of the user. This is equivalent to the WP_User-&gt;dispaly_name property. */
  name?: Maybe<Scalars['String']>;
  /** The nicename for the user. This field is equivalent to WP_User-&gt;user_nicename */
  nicename?: Maybe<Scalars['String']>;
  /** Nickname of the user. */
  nickname?: Maybe<Scalars['String']>;
  /** Connection between the User type and the page type */
  pages?: Maybe<UserToPageConnection>;
  /** Connection between the User type and the post type */
  posts?: Maybe<UserToPostConnection>;
  /** The date the user registered or was created. The field follows a full ISO8601 date string format. */
  registeredDate?: Maybe<Scalars['String']>;
  /** Connection between the User and Revisions authored by the user */
  revisions?: Maybe<UserToContentRevisionUnionConnection>;
  /** Connection between the User type and the UserRole type */
  roles?: Maybe<UserToUserRoleConnection>;
  /** The slug for the user. This field is equivalent to WP_User-&gt;user_nicename */
  slug?: Maybe<Scalars['String']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
  /** A website url that is associated with the user. */
  url?: Maybe<Scalars['String']>;
  /** The Id of the user. Equivalent to WP_User-&gt;ID */
  userId?: Maybe<Scalars['Int']>;
  /** Username for the user. This field is equivalent to WP_User-&gt;user_login. */
  username?: Maybe<Scalars['String']>;
};


/** A User object */
export type UserAvatarArgs = {
  forceDefault?: InputMaybe<Scalars['Boolean']>;
  rating?: InputMaybe<AvatarRatingEnum>;
  size?: InputMaybe<Scalars['Int']>;
};


/** A User object */
export type UserCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<UserToCommentConnectionWhereArgs>;
};


/** A User object */
export type UserEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A User object */
export type UserEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** A User object */
export type UserMediaItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<UserToMediaItemConnectionWhereArgs>;
};


/** A User object */
export type UserPagesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<UserToPageConnectionWhereArgs>;
};


/** A User object */
export type UserPostsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<UserToPostConnectionWhereArgs>;
};


/** A User object */
export type UserRevisionsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<UserToContentRevisionUnionConnectionWhereArgs>;
};


/** A User object */
export type UserRolesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The Type of Identifier used to fetch a single User node. To be used along with the "id" field. Default is "ID". */
export enum UserNodeIdTypeEnum {
  /** The Database ID for the node */
  DatabaseId = 'DATABASE_ID',
  /** The Email of the User */
  Email = 'EMAIL',
  /** The hashed Global ID */
  Id = 'ID',
  /** The slug of the User */
  Slug = 'SLUG',
  /** The URI for the node */
  Uri = 'URI',
  /** The username the User uses to login with */
  Username = 'USERNAME'
}

/** A user role object */
export type UserRole = Node & {
  __typename?: 'UserRole';
  /** The capabilities that belong to this role */
  capabilities?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** The display name of the role */
  displayName?: Maybe<Scalars['String']>;
  /** The globally unique identifier for the user role object. */
  id: Scalars['ID'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** The registered name of the role */
  name?: Maybe<Scalars['String']>;
};

/** Names of available user roles */
export enum UserRoleEnum {
  /** User role with specific capabilities */
  Administrator = 'ADMINISTRATOR',
  /** User role with specific capabilities */
  Author = 'AUTHOR',
  /** User role with specific capabilities */
  Contributor = 'CONTRIBUTOR',
  /** User role with specific capabilities */
  Editor = 'EDITOR',
  /** User role with specific capabilities */
  Subscriber = 'SUBSCRIBER'
}

/** Connection between the User type and the Comment type */
export type UserToCommentConnection = {
  __typename?: 'UserToCommentConnection';
  /** Edges for the UserToCommentConnection connection */
  edges?: Maybe<Array<Maybe<UserToCommentConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Comment>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type UserToCommentConnectionEdge = {
  __typename?: 'UserToCommentConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Comment>;
};

/** Arguments for filtering the UserToCommentConnection connection */
export type UserToCommentConnectionWhereArgs = {
  /** Comment author email address. */
  authorEmail?: InputMaybe<Scalars['String']>;
  /** Array of author IDs to include comments for. */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to exclude comments for. */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Comment author URL. */
  authorUrl?: InputMaybe<Scalars['String']>;
  /** Array of comment IDs to include. */
  commentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of IDs of users whose unapproved comments will be returned by the query regardless of status. */
  commentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Include comments of a given type. */
  commentType?: InputMaybe<Scalars['String']>;
  /** Include comments from a given array of comment types. */
  commentTypeIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Exclude comments from a given array of comment types. */
  commentTypeNotIn?: InputMaybe<Scalars['String']>;
  /** Content object author ID to limit results by. */
  contentAuthor?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs to retrieve comments for. */
  contentAuthorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of author IDs *not* to retrieve comments for. */
  contentAuthorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Limit results to those affiliated with a given content object ID. */
  contentId?: InputMaybe<Scalars['ID']>;
  /** Array of content object IDs to include affiliated comments for. */
  contentIdIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of content object IDs to exclude affiliated comments for. */
  contentIdNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Content object name to retrieve affiliated comments for. */
  contentName?: InputMaybe<Scalars['String']>;
  /** Content Object parent ID to retrieve affiliated comments for. */
  contentParent?: InputMaybe<Scalars['Int']>;
  /** Array of content object statuses to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentStatus?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value. */
  contentType?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty */
  includeUnapproved?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Karma score to retrieve matching comments for. */
  karma?: InputMaybe<Scalars['Int']>;
  /** The cardinality of the order of the connection */
  order?: InputMaybe<OrderEnum>;
  /** Field to order the comments by. */
  orderby?: InputMaybe<CommentsConnectionOrderbyEnum>;
  /** Parent ID of comment to retrieve children of. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Array of parent IDs of comments to retrieve children for. */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of parent IDs of comments *not* to retrieve children for. */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Search term(s) to retrieve matching comments for. */
  search?: InputMaybe<Scalars['String']>;
  /** Comment status to limit results by. */
  status?: InputMaybe<Scalars['String']>;
  /** Include comments for a specific user ID. */
  userId?: InputMaybe<Scalars['ID']>;
};

/** Connection between the User type and the ContentRevisionUnion type */
export type UserToContentRevisionUnionConnection = {
  __typename?: 'UserToContentRevisionUnionConnection';
  /** Edges for the UserToContentRevisionUnionConnection connection */
  edges?: Maybe<Array<Maybe<UserToContentRevisionUnionConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentRevisionUnion>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type UserToContentRevisionUnionConnectionEdge = {
  __typename?: 'UserToContentRevisionUnionConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentRevisionUnion>;
};

/** Arguments for filtering the UserToContentRevisionUnionConnection connection */
export type UserToContentRevisionUnionConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypeEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the User type and the EnqueuedScript type */
export type UserToEnqueuedScriptConnection = {
  __typename?: 'UserToEnqueuedScriptConnection';
  /** Edges for the UserToEnqueuedScriptConnection connection */
  edges?: Maybe<Array<Maybe<UserToEnqueuedScriptConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<EnqueuedScript>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type UserToEnqueuedScriptConnectionEdge = {
  __typename?: 'UserToEnqueuedScriptConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<EnqueuedScript>;
};

/** Connection between the User type and the EnqueuedStylesheet type */
export type UserToEnqueuedStylesheetConnection = {
  __typename?: 'UserToEnqueuedStylesheetConnection';
  /** Edges for the UserToEnqueuedStylesheetConnection connection */
  edges?: Maybe<Array<Maybe<UserToEnqueuedStylesheetConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<EnqueuedStylesheet>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type UserToEnqueuedStylesheetConnectionEdge = {
  __typename?: 'UserToEnqueuedStylesheetConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<EnqueuedStylesheet>;
};

/** Connection between the User type and the mediaItem type */
export type UserToMediaItemConnection = {
  __typename?: 'UserToMediaItemConnection';
  /** Edges for the UserToMediaItemConnection connection */
  edges?: Maybe<Array<Maybe<UserToMediaItemConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<MediaItem>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type UserToMediaItemConnectionEdge = {
  __typename?: 'UserToMediaItemConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<MediaItem>;
};

/** Arguments for filtering the UserToMediaItemConnection connection */
export type UserToMediaItemConnectionWhereArgs = {
  /** The user that's connected as the author of the object. Use the userId for the author object. */
  author?: InputMaybe<Scalars['Int']>;
  /** Find objects connected to author(s) in the array of author's userIds */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Find objects connected to the author by the author's nicename */
  authorName?: InputMaybe<Scalars['String']>;
  /** Find objects NOT connected to author(s) in the array of author's userIds */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the User type and the page type */
export type UserToPageConnection = {
  __typename?: 'UserToPageConnection';
  /** Edges for the UserToPageConnection connection */
  edges?: Maybe<Array<Maybe<UserToPageConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Page>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type UserToPageConnectionEdge = {
  __typename?: 'UserToPageConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Page>;
};

/** Arguments for filtering the UserToPageConnection connection */
export type UserToPageConnectionWhereArgs = {
  /** The user that's connected as the author of the object. Use the userId for the author object. */
  author?: InputMaybe<Scalars['Int']>;
  /** Find objects connected to author(s) in the array of author's userIds */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Find objects connected to the author by the author's nicename */
  authorName?: InputMaybe<Scalars['String']>;
  /** Find objects NOT connected to author(s) in the array of author's userIds */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the User type and the post type */
export type UserToPostConnection = {
  __typename?: 'UserToPostConnection';
  /** Edges for the UserToPostConnection connection */
  edges?: Maybe<Array<Maybe<UserToPostConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Post>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type UserToPostConnectionEdge = {
  __typename?: 'UserToPostConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Post>;
};

/** Arguments for filtering the UserToPostConnection connection */
export type UserToPostConnectionWhereArgs = {
  /** The user that's connected as the author of the object. Use the userId for the author object. */
  author?: InputMaybe<Scalars['Int']>;
  /** Find objects connected to author(s) in the array of author's userIds */
  authorIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Find objects connected to the author by the author's nicename */
  authorName?: InputMaybe<Scalars['String']>;
  /** Find objects NOT connected to author(s) in the array of author's userIds */
  authorNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Category ID */
  categoryId?: InputMaybe<Scalars['Int']>;
  /** Array of category IDs, used to display objects from one category OR another */
  categoryIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Use Category Slug */
  categoryName?: InputMaybe<Scalars['String']>;
  /** Array of category IDs, used to display objects from one category OR another */
  categoryNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Tag Slug */
  tag?: InputMaybe<Scalars['String']>;
  /** Use Tag ID */
  tagId?: InputMaybe<Scalars['String']>;
  /** Array of tag IDs, used to display objects from one tag OR another */
  tagIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of tag IDs, used to display objects from one tag OR another */
  tagNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of tag slugs, used to display objects from one tag OR another */
  tagSlugAnd?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of tag slugs, used to exclude objects in specified tags */
  tagSlugIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the User type and the UserRole type */
export type UserToUserRoleConnection = {
  __typename?: 'UserToUserRoleConnection';
  /** Edges for the UserToUserRoleConnection connection */
  edges?: Maybe<Array<Maybe<UserToUserRoleConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<UserRole>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type UserToUserRoleConnectionEdge = {
  __typename?: 'UserToUserRoleConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<UserRole>;
};

/** Field to order the connection by */
export enum UsersConnectionOrderbyEnum {
  /** Order by display name */
  DisplayName = 'DISPLAY_NAME',
  /** Order by email address */
  Email = 'EMAIL',
  /** Order by login */
  Login = 'LOGIN',
  /** Preserve the login order given in the LOGIN_IN array */
  LoginIn = 'LOGIN_IN',
  /** Order by nice name */
  NiceName = 'NICE_NAME',
  /** Preserve the nice name order given in the NICE_NAME_IN array */
  NiceNameIn = 'NICE_NAME_IN',
  /** Order by registration date */
  Registered = 'REGISTERED',
  /** Order by URL */
  Url = 'URL'
}

/** Options for ordering the connection */
export type UsersConnectionOrderbyInput = {
  /** The field name used to sort the results. */
  field: UsersConnectionOrderbyEnum;
  /** The cardinality of the order of the connection */
  order?: InputMaybe<OrderEnum>;
};

/** Column used for searching for users. */
export enum UsersConnectionSearchColumnEnum {
  /** The user's email address. */
  Email = 'EMAIL',
  /** The globally unique ID. */
  Id = 'ID',
  /** The username the User uses to login with. */
  Login = 'LOGIN',
  /** A URL-friendly name for the user. The default is the user's username. */
  Nicename = 'NICENAME',
  /** The URL of the user\s website. */
  Url = 'URL'
}

/** The VideoSeriesCategory type */
export type VideoSeriesCategory = DatabaseIdentifier & MenuItemLinkable & Node & TermNode & UniformResourceIdentifiable & {
  __typename?: 'VideoSeriesCategory';
  /** Connection between the VideoSeriesCategory type and the ContentNode type */
  contentNodes?: Maybe<VideoSeriesCategoryToContentNodeConnection>;
  /** The number of objects connected to the object */
  count?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** The description of the object */
  description?: Maybe<Scalars['String']>;
  /** Connection between the TermNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<TermNodeToEnqueuedScriptConnection>;
  /** Connection between the TermNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<TermNodeToEnqueuedStylesheetConnection>;
  /** The unique resource identifier path */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The link to the term */
  link?: Maybe<Scalars['String']>;
  /** The human friendly name of the object. */
  name?: Maybe<Scalars['String']>;
  /** An alphanumeric identifier for the object unique to its type. */
  slug?: Maybe<Scalars['String']>;
  /** Connection between the VideoSeriesCategory type and the Taxonomy type */
  taxonomy?: Maybe<VideoSeriesCategoryToTaxonomyConnectionEdge>;
  /** The name of the taxonomy that the object is associated with */
  taxonomyName?: Maybe<Scalars['String']>;
  /** The ID of the term group that this term object belongs to */
  termGroupId?: Maybe<Scalars['Int']>;
  /** The taxonomy ID that the object is associated with */
  termTaxonomyId?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
  /** The id field matches the WP_Post-&gt;ID field. */
  videoSeriesCategoryId?: Maybe<Scalars['Int']>;
  /** Connection between the VideoSeriesCategory type and the VideoSeriesItem type */
  videoSeriesItems?: Maybe<VideoSeriesCategoryToVideoSeriesItemConnection>;
};


/** The VideoSeriesCategory type */
export type VideoSeriesCategoryContentNodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<VideoSeriesCategoryToContentNodeConnectionWhereArgs>;
};


/** The VideoSeriesCategory type */
export type VideoSeriesCategoryEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The VideoSeriesCategory type */
export type VideoSeriesCategoryEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The VideoSeriesCategory type */
export type VideoSeriesCategoryVideoSeriesItemsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<VideoSeriesCategoryToVideoSeriesItemConnectionWhereArgs>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum VideoSeriesCategoryIdType {
  /** The Database ID for the node */
  DatabaseId = 'DATABASE_ID',
  /** The hashed Global ID */
  Id = 'ID',
  /** The name of the node */
  Name = 'NAME',
  /** Url friendly name of the node */
  Slug = 'SLUG',
  /** The URI for the node */
  Uri = 'URI'
}

/** Connection between the VideoSeriesCategory type and the ContentNode type */
export type VideoSeriesCategoryToContentNodeConnection = {
  __typename?: 'VideoSeriesCategoryToContentNodeConnection';
  /** Edges for the VideoSeriesCategoryToContentNodeConnection connection */
  edges?: Maybe<Array<Maybe<VideoSeriesCategoryToContentNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type VideoSeriesCategoryToContentNodeConnectionEdge = {
  __typename?: 'VideoSeriesCategoryToContentNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentNode>;
};

/** Arguments for filtering the VideoSeriesCategoryToContentNodeConnection connection */
export type VideoSeriesCategoryToContentNodeConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfVideoSeriesCategoryEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the VideoSeriesCategory type and the Taxonomy type */
export type VideoSeriesCategoryToTaxonomyConnectionEdge = {
  __typename?: 'VideoSeriesCategoryToTaxonomyConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Taxonomy>;
};

/** Connection between the VideoSeriesCategory type and the VideoSeriesItem type */
export type VideoSeriesCategoryToVideoSeriesItemConnection = {
  __typename?: 'VideoSeriesCategoryToVideoSeriesItemConnection';
  /** Edges for the VideoSeriesCategoryToVideoSeriesItemConnection connection */
  edges?: Maybe<Array<Maybe<VideoSeriesCategoryToVideoSeriesItemConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<VideoSeriesItem>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type VideoSeriesCategoryToVideoSeriesItemConnectionEdge = {
  __typename?: 'VideoSeriesCategoryToVideoSeriesItemConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<VideoSeriesItem>;
};

/** Arguments for filtering the VideoSeriesCategoryToVideoSeriesItemConnection connection */
export type VideoSeriesCategoryToVideoSeriesItemConnectionWhereArgs = {
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** The VideoSeriesItem type */
export type VideoSeriesItem = ContentNode & DatabaseIdentifier & MenuItemLinkable & Node & NodeWithExcerpt & NodeWithFeaturedImage & NodeWithTemplate & NodeWithTitle & UniformResourceIdentifiable & {
  __typename?: 'VideoSeriesItem';
  /** Connection between the ContentNode type and the ContentType type */
  contentType?: Maybe<ContentNodeToContentTypeConnectionEdge>;
  /** The name of the Content Type the node belongs to */
  contentTypeName: Scalars['String'];
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** Post publishing date. */
  date?: Maybe<Scalars['String']>;
  /** The publishing date set in GMT. */
  dateGmt?: Maybe<Scalars['String']>;
  /** The desired slug of the post */
  desiredSlug?: Maybe<Scalars['String']>;
  /** Added to the GraphQL Schema because the ACF Field Group &quot;Downloads&quot; was set to Show in GraphQL. */
  downloads?: Maybe<VideoSeriesItem_Downloads>;
  /** If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds */
  editingLockedBy?: Maybe<ContentNodeToEditLockConnectionEdge>;
  /** The RSS enclosure for the object */
  enclosure?: Maybe<Scalars['String']>;
  /** Connection between the ContentNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<ContentNodeToEnqueuedScriptConnection>;
  /** Connection between the ContentNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<ContentNodeToEnqueuedStylesheetConnection>;
  /** The excerpt of the post. */
  excerpt?: Maybe<Scalars['String']>;
  /** Connection between the NodeWithFeaturedImage type and the MediaItem type */
  featuredImage?: Maybe<NodeWithFeaturedImageToMediaItemConnectionEdge>;
  /** The database identifier for the featured image node assigned to the content node */
  featuredImageDatabaseId?: Maybe<Scalars['Int']>;
  /** Globally unique ID of the featured image assigned to the node */
  featuredImageId?: Maybe<Scalars['ID']>;
  /** The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table. */
  guid?: Maybe<Scalars['String']>;
  /** The globally unique identifier of the video-series object. */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is a node in the preview state */
  isPreview?: Maybe<Scalars['Boolean']>;
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The user that most recently edited the node */
  lastEditedBy?: Maybe<ContentNodeToEditLastConnectionEdge>;
  /** The permalink of the post */
  link?: Maybe<Scalars['String']>;
  /** The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time. */
  modified?: Maybe<Scalars['String']>;
  /** The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT. */
  modifiedGmt?: Maybe<Scalars['String']>;
  /** Connection between the VideoSeriesItem type and the VideoSeriesItem type */
  preview?: Maybe<VideoSeriesItemToPreviewConnectionEdge>;
  /** The database id of the preview node */
  previewRevisionDatabaseId?: Maybe<Scalars['Int']>;
  /** Whether the object is a node in the preview state */
  previewRevisionId?: Maybe<Scalars['ID']>;
  /** The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table. */
  slug?: Maybe<Scalars['String']>;
  /** The current status of the object */
  status?: Maybe<Scalars['String']>;
  /** The template assigned to a node of content */
  template?: Maybe<ContentTemplate>;
  /** Connection between the VideoSeriesItem type and the TermNode type */
  terms?: Maybe<VideoSeriesItemToTermNodeConnection>;
  /** The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made. */
  title?: Maybe<Scalars['String']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
  /** Connection between the VideoSeriesItem type and the VideoSeriesCategory type */
  videoSeriesCategories?: Maybe<VideoSeriesItemToVideoSeriesCategoryConnection>;
  /** The id field matches the WP_Post-&gt;ID field. */
  videoSeriesItemId: Scalars['Int'];
  /** Added to the GraphQL Schema because the ACF Field Group &quot;YouTube&quot; was set to Show in GraphQL. */
  youtube?: Maybe<VideoSeriesItem_Youtube>;
};


/** The VideoSeriesItem type */
export type VideoSeriesItemEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The VideoSeriesItem type */
export type VideoSeriesItemEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The VideoSeriesItem type */
export type VideoSeriesItemExcerptArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};


/** The VideoSeriesItem type */
export type VideoSeriesItemTermsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<VideoSeriesItemToTermNodeConnectionWhereArgs>;
};


/** The VideoSeriesItem type */
export type VideoSeriesItemTitleArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};


/** The VideoSeriesItem type */
export type VideoSeriesItemVideoSeriesCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<VideoSeriesItemToVideoSeriesCategoryConnectionWhereArgs>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum VideoSeriesItemIdType {
  /** Identify a resource by the Database ID. */
  DatabaseId = 'DATABASE_ID',
  /** Identify a resource by the (hashed) Global ID. */
  Id = 'ID',
  /** Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier. */
  Slug = 'SLUG',
  /** Identify a resource by the URI. */
  Uri = 'URI'
}

/** Connection between the VideoSeriesItem type and the VideoSeriesItem type */
export type VideoSeriesItemToPreviewConnectionEdge = {
  __typename?: 'VideoSeriesItemToPreviewConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<VideoSeriesItem>;
};

/** Connection between the VideoSeriesItem type and the TermNode type */
export type VideoSeriesItemToTermNodeConnection = {
  __typename?: 'VideoSeriesItemToTermNodeConnection';
  /** Edges for the VideoSeriesItemToTermNodeConnection connection */
  edges?: Maybe<Array<Maybe<VideoSeriesItemToTermNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<TermNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type VideoSeriesItemToTermNodeConnectionEdge = {
  __typename?: 'VideoSeriesItemToTermNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<TermNode>;
};

/** Arguments for filtering the VideoSeriesItemToTermNodeConnection connection */
export type VideoSeriesItemToTermNodeConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** The Taxonomy to filter terms by */
  taxonomies?: InputMaybe<Array<InputMaybe<TaxonomyEnum>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the VideoSeriesItem type and the VideoSeriesCategory type */
export type VideoSeriesItemToVideoSeriesCategoryConnection = {
  __typename?: 'VideoSeriesItemToVideoSeriesCategoryConnection';
  /** Edges for the VideoSeriesItemToVideoSeriesCategoryConnection connection */
  edges?: Maybe<Array<Maybe<VideoSeriesItemToVideoSeriesCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<VideoSeriesCategory>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type VideoSeriesItemToVideoSeriesCategoryConnectionEdge = {
  __typename?: 'VideoSeriesItemToVideoSeriesCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<VideoSeriesCategory>;
};

/** Arguments for filtering the VideoSeriesItemToVideoSeriesCategoryConnection connection */
export type VideoSeriesItemToVideoSeriesCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Set relationships between the VideoSeriesItem to VideoSeriesCategories */
export type VideoSeriesItemVideoSeriesCategoriesInput = {
  /** If true, this will append the VideoSeriesCategory to existing related VideoSeriesCategories. If false, this will replace existing relationships. Default true. */
  append?: InputMaybe<Scalars['Boolean']>;
  /** The input list of items to set. */
  nodes?: InputMaybe<Array<InputMaybe<VideoSeriesItemVideoSeriesCategoriesNodeInput>>>;
};

/** List of VideoSeriesCategories to connect the VideoSeriesItem to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */
export type VideoSeriesItemVideoSeriesCategoriesNodeInput = {
  /** The description of the VideoSeriesCategory. This field is used to set a description of the VideoSeriesCategory if a new one is created during the mutation. */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the VideoSeriesCategory. If present, this will be used to connect to the VideoSeriesItem. If no existing VideoSeriesCategory exists with this ID, no connection will be made. */
  id?: InputMaybe<Scalars['ID']>;
  /** The name of the VideoSeriesCategory. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */
  name?: InputMaybe<Scalars['String']>;
  /** The slug of the VideoSeriesCategory. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */
  slug?: InputMaybe<Scalars['String']>;
};

/** Field Group */
export type VideoSeriesItem_Downloads = AcfFieldGroup & {
  __typename?: 'VideoSeriesItem_Downloads';
  /** The name of the ACF Field Group */
  fieldGroupName?: Maybe<Scalars['String']>;
  file?: Maybe<MediaItem>;
};

/** Field Group */
export type VideoSeriesItem_Youtube = AcfFieldGroup & {
  __typename?: 'VideoSeriesItem_Youtube';
  /** Duration of the video in seconds */
  duration?: Maybe<Scalars['Float']>;
  /** The name of the ACF Field Group */
  fieldGroupName?: Maybe<Scalars['String']>;
  /** A link to the YouTube video */
  url?: Maybe<Scalars['String']>;
};

/** Information about pagination in a connection. */
export type WpPageInfo = {
  __typename?: 'WPPageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

/** The Webinar type */
export type Webinar = ContentNode & DatabaseIdentifier & MenuItemLinkable & Node & NodeWithExcerpt & NodeWithFeaturedImage & NodeWithTemplate & NodeWithTitle & UniformResourceIdentifiable & {
  __typename?: 'Webinar';
  /** Connection between the ContentNode type and the ContentType type */
  contentType?: Maybe<ContentNodeToContentTypeConnectionEdge>;
  /** The name of the Content Type the node belongs to */
  contentTypeName: Scalars['String'];
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** Post publishing date. */
  date?: Maybe<Scalars['String']>;
  /** The publishing date set in GMT. */
  dateGmt?: Maybe<Scalars['String']>;
  /** The desired slug of the post */
  desiredSlug?: Maybe<Scalars['String']>;
  /** If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds */
  editingLockedBy?: Maybe<ContentNodeToEditLockConnectionEdge>;
  /** The RSS enclosure for the object */
  enclosure?: Maybe<Scalars['String']>;
  /** Connection between the ContentNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<ContentNodeToEnqueuedScriptConnection>;
  /** Connection between the ContentNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<ContentNodeToEnqueuedStylesheetConnection>;
  /** The excerpt of the post. */
  excerpt?: Maybe<Scalars['String']>;
  /** Connection between the NodeWithFeaturedImage type and the MediaItem type */
  featuredImage?: Maybe<NodeWithFeaturedImageToMediaItemConnectionEdge>;
  /** The database identifier for the featured image node assigned to the content node */
  featuredImageDatabaseId?: Maybe<Scalars['Int']>;
  /** Globally unique ID of the featured image assigned to the node */
  featuredImageId?: Maybe<Scalars['ID']>;
  /** The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table. */
  guid?: Maybe<Scalars['String']>;
  /** The globally unique identifier of the webinar object. */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is a node in the preview state */
  isPreview?: Maybe<Scalars['Boolean']>;
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The user that most recently edited the node */
  lastEditedBy?: Maybe<ContentNodeToEditLastConnectionEdge>;
  /** The permalink of the post */
  link?: Maybe<Scalars['String']>;
  /** The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time. */
  modified?: Maybe<Scalars['String']>;
  /** The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT. */
  modifiedGmt?: Maybe<Scalars['String']>;
  /** Connection between the Webinar type and the Webinar type */
  preview?: Maybe<WebinarToPreviewConnectionEdge>;
  /** The database id of the preview node */
  previewRevisionDatabaseId?: Maybe<Scalars['Int']>;
  /** Whether the object is a node in the preview state */
  previewRevisionId?: Maybe<Scalars['ID']>;
  /** The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table. */
  slug?: Maybe<Scalars['String']>;
  /** The current status of the object */
  status?: Maybe<Scalars['String']>;
  /** The template assigned to a node of content */
  template?: Maybe<ContentTemplate>;
  /** Connection between the Webinar type and the TermNode type */
  terms?: Maybe<WebinarToTermNodeConnection>;
  /** The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made. */
  title?: Maybe<Scalars['String']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
  /** The id field matches the WP_Post-&gt;ID field. */
  webinarId: Scalars['Int'];
  /** Connection between the Webinar type and the WebinarsCategory type */
  webinarsCategories?: Maybe<WebinarToWebinarsCategoryConnection>;
  /** Added to the GraphQL Schema because the ACF Field Group &quot;YouTube&quot; was set to Show in GraphQL. */
  youtube?: Maybe<Webinar_Youtube>;
};


/** The Webinar type */
export type WebinarEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The Webinar type */
export type WebinarEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The Webinar type */
export type WebinarExcerptArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};


/** The Webinar type */
export type WebinarTermsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WebinarToTermNodeConnectionWhereArgs>;
};


/** The Webinar type */
export type WebinarTitleArgs = {
  format?: InputMaybe<PostObjectFieldFormatEnum>;
};


/** The Webinar type */
export type WebinarWebinarsCategoriesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WebinarToWebinarsCategoryConnectionWhereArgs>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum WebinarIdType {
  /** Identify a resource by the Database ID. */
  DatabaseId = 'DATABASE_ID',
  /** Identify a resource by the (hashed) Global ID. */
  Id = 'ID',
  /** Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier. */
  Slug = 'SLUG',
  /** Identify a resource by the URI. */
  Uri = 'URI'
}

/** Connection between the Webinar type and the Webinar type */
export type WebinarToPreviewConnectionEdge = {
  __typename?: 'WebinarToPreviewConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Webinar>;
};

/** Connection between the Webinar type and the TermNode type */
export type WebinarToTermNodeConnection = {
  __typename?: 'WebinarToTermNodeConnection';
  /** Edges for the WebinarToTermNodeConnection connection */
  edges?: Maybe<Array<Maybe<WebinarToTermNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<TermNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type WebinarToTermNodeConnectionEdge = {
  __typename?: 'WebinarToTermNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<TermNode>;
};

/** Arguments for filtering the WebinarToTermNodeConnection connection */
export type WebinarToTermNodeConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** The Taxonomy to filter terms by */
  taxonomies?: InputMaybe<Array<InputMaybe<TaxonomyEnum>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Connection between the Webinar type and the WebinarsCategory type */
export type WebinarToWebinarsCategoryConnection = {
  __typename?: 'WebinarToWebinarsCategoryConnection';
  /** Edges for the WebinarToWebinarsCategoryConnection connection */
  edges?: Maybe<Array<Maybe<WebinarToWebinarsCategoryConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<WebinarsCategory>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type WebinarToWebinarsCategoryConnectionEdge = {
  __typename?: 'WebinarToWebinarsCategoryConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<WebinarsCategory>;
};

/** Arguments for filtering the WebinarToWebinarsCategoryConnection connection */
export type WebinarToWebinarsCategoryConnectionWhereArgs = {
  /** Unique cache key to be produced when this query is stored in an object cache. Default is 'core'. */
  cacheDomain?: InputMaybe<Scalars['String']>;
  /** Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0. */
  childOf?: InputMaybe<Scalars['Int']>;
  /** True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false. */
  childless?: InputMaybe<Scalars['Boolean']>;
  /** Retrieve terms where the description is LIKE the input value. Default empty. */
  descriptionLike?: InputMaybe<Scalars['String']>;
  /** Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array. */
  exclude?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array. */
  excludeTree?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to hide terms not assigned to any posts. Accepts true or false. Default false */
  hideEmpty?: InputMaybe<Scalars['Boolean']>;
  /** Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true. */
  hierarchical?: InputMaybe<Scalars['Boolean']>;
  /** Array of term ids to include. Default empty array. */
  include?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Array of names to return term(s) for. Default empty. */
  name?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Retrieve terms where the name is LIKE the input value. Default empty. */
  nameLike?: InputMaybe<Scalars['String']>;
  /** Array of object IDs. Results will be limited to terms associated with these objects. */
  objectIds?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Direction the connection should be ordered in */
  order?: InputMaybe<OrderEnum>;
  /** Field(s) to order terms by. Defaults to 'name'. */
  orderby?: InputMaybe<TermObjectsConnectionOrderbyEnum>;
  /** Whether to pad the quantity of a term's children in the quantity of each term's "count" object variable. Default false. */
  padCounts?: InputMaybe<Scalars['Boolean']>;
  /** Parent term ID to retrieve direct-child terms of. Default empty. */
  parent?: InputMaybe<Scalars['Int']>;
  /** Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty. */
  search?: InputMaybe<Scalars['String']>;
  /** Array of slugs to return term(s) for. Default empty. */
  slug?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Array of term taxonomy IDs, to match when querying terms. */
  termTaxonomId?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Whether to prime meta caches for matched terms. Default true. */
  updateTermMetaCache?: InputMaybe<Scalars['Boolean']>;
};

/** Set relationships between the Webinar to WebinarsCategories */
export type WebinarWebinarsCategoriesInput = {
  /** If true, this will append the WebinarsCategory to existing related WebinarsCategories. If false, this will replace existing relationships. Default true. */
  append?: InputMaybe<Scalars['Boolean']>;
  /** The input list of items to set. */
  nodes?: InputMaybe<Array<InputMaybe<WebinarWebinarsCategoriesNodeInput>>>;
};

/** List of WebinarsCategories to connect the Webinar to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists. */
export type WebinarWebinarsCategoriesNodeInput = {
  /** The description of the WebinarsCategory. This field is used to set a description of the WebinarsCategory if a new one is created during the mutation. */
  description?: InputMaybe<Scalars['String']>;
  /** The ID of the WebinarsCategory. If present, this will be used to connect to the Webinar. If no existing WebinarsCategory exists with this ID, no connection will be made. */
  id?: InputMaybe<Scalars['ID']>;
  /** The name of the WebinarsCategory. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field. */
  name?: InputMaybe<Scalars['String']>;
  /** The slug of the WebinarsCategory. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation. */
  slug?: InputMaybe<Scalars['String']>;
};

/** Field Group */
export type Webinar_Youtube = AcfFieldGroup & {
  __typename?: 'Webinar_Youtube';
  /** Duration of the video in seconds */
  duration?: Maybe<Scalars['Float']>;
  /** The name of the ACF Field Group */
  fieldGroupName?: Maybe<Scalars['String']>;
  /** A link to the YouTube video */
  url?: Maybe<Scalars['String']>;
};

/** The WebinarsCategory type */
export type WebinarsCategory = DatabaseIdentifier & MenuItemLinkable & Node & TermNode & UniformResourceIdentifiable & {
  __typename?: 'WebinarsCategory';
  /** Connection between the WebinarsCategory type and the ContentNode type */
  contentNodes?: Maybe<WebinarsCategoryToContentNodeConnection>;
  /** The number of objects connected to the object */
  count?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  databaseId: Scalars['Int'];
  /** The description of the object */
  description?: Maybe<Scalars['String']>;
  /** Connection between the TermNode type and the EnqueuedScript type */
  enqueuedScripts?: Maybe<TermNodeToEnqueuedScriptConnection>;
  /** Connection between the TermNode type and the EnqueuedStylesheet type */
  enqueuedStylesheets?: Maybe<TermNodeToEnqueuedStylesheetConnection>;
  /** The unique resource identifier path */
  id: Scalars['ID'];
  /** Whether the node is a Content Node */
  isContentNode: Scalars['Boolean'];
  /** Whether the object is restricted from the current viewer */
  isRestricted?: Maybe<Scalars['Boolean']>;
  /** Whether the node is a Term */
  isTermNode: Scalars['Boolean'];
  /** The link to the term */
  link?: Maybe<Scalars['String']>;
  /** The human friendly name of the object. */
  name?: Maybe<Scalars['String']>;
  /** An alphanumeric identifier for the object unique to its type. */
  slug?: Maybe<Scalars['String']>;
  /** Connection between the WebinarsCategory type and the Taxonomy type */
  taxonomy?: Maybe<WebinarsCategoryToTaxonomyConnectionEdge>;
  /** The name of the taxonomy that the object is associated with */
  taxonomyName?: Maybe<Scalars['String']>;
  /** The ID of the term group that this term object belongs to */
  termGroupId?: Maybe<Scalars['Int']>;
  /** The taxonomy ID that the object is associated with */
  termTaxonomyId?: Maybe<Scalars['Int']>;
  /** The unique resource identifier path */
  uri?: Maybe<Scalars['String']>;
  /** Connection between the WebinarsCategory type and the Webinar type */
  webinars?: Maybe<WebinarsCategoryToWebinarConnection>;
  /** The id field matches the WP_Post-&gt;ID field. */
  webinarsCategoryId?: Maybe<Scalars['Int']>;
};


/** The WebinarsCategory type */
export type WebinarsCategoryContentNodesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WebinarsCategoryToContentNodeConnectionWhereArgs>;
};


/** The WebinarsCategory type */
export type WebinarsCategoryEnqueuedScriptsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The WebinarsCategory type */
export type WebinarsCategoryEnqueuedStylesheetsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


/** The WebinarsCategory type */
export type WebinarsCategoryWebinarsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WebinarsCategoryToWebinarConnectionWhereArgs>;
};

/** The Type of Identifier used to fetch a single resource. Default is ID. */
export enum WebinarsCategoryIdType {
  /** The Database ID for the node */
  DatabaseId = 'DATABASE_ID',
  /** The hashed Global ID */
  Id = 'ID',
  /** The name of the node */
  Name = 'NAME',
  /** Url friendly name of the node */
  Slug = 'SLUG',
  /** The URI for the node */
  Uri = 'URI'
}

/** Connection between the WebinarsCategory type and the ContentNode type */
export type WebinarsCategoryToContentNodeConnection = {
  __typename?: 'WebinarsCategoryToContentNodeConnection';
  /** Edges for the WebinarsCategoryToContentNodeConnection connection */
  edges?: Maybe<Array<Maybe<WebinarsCategoryToContentNodeConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<ContentNode>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type WebinarsCategoryToContentNodeConnectionEdge = {
  __typename?: 'WebinarsCategoryToContentNodeConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<ContentNode>;
};

/** Arguments for filtering the WebinarsCategoryToContentNodeConnection connection */
export type WebinarsCategoryToContentNodeConnectionWhereArgs = {
  /** The Types of content to filter */
  contentTypes?: InputMaybe<Array<InputMaybe<ContentTypesOfWebinarsCategoryEnum>>>;
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** Connection between the WebinarsCategory type and the Taxonomy type */
export type WebinarsCategoryToTaxonomyConnectionEdge = {
  __typename?: 'WebinarsCategoryToTaxonomyConnectionEdge';
  /** The node of the connection, without the edges */
  node?: Maybe<Taxonomy>;
};

/** Connection between the WebinarsCategory type and the Webinar type */
export type WebinarsCategoryToWebinarConnection = {
  __typename?: 'WebinarsCategoryToWebinarConnection';
  /** Edges for the WebinarsCategoryToWebinarConnection connection */
  edges?: Maybe<Array<Maybe<WebinarsCategoryToWebinarConnectionEdge>>>;
  /** The nodes of the connection, without the edges */
  nodes?: Maybe<Array<Maybe<Webinar>>>;
  /** Information about pagination in a connection. */
  pageInfo?: Maybe<WpPageInfo>;
};

/** An edge in a connection */
export type WebinarsCategoryToWebinarConnectionEdge = {
  __typename?: 'WebinarsCategoryToWebinarConnectionEdge';
  /** A cursor for use in pagination */
  cursor?: Maybe<Scalars['String']>;
  /** The item at the end of the edge */
  node?: Maybe<Webinar>;
};

/** Arguments for filtering the WebinarsCategoryToWebinarConnection connection */
export type WebinarsCategoryToWebinarConnectionWhereArgs = {
  /** Filter the connection based on dates */
  dateQuery?: InputMaybe<DateQueryInput>;
  /** True for objects with passwords; False for objects without passwords; null for all objects with or without passwords */
  hasPassword?: InputMaybe<Scalars['Boolean']>;
  /** Specific database ID of the object */
  id?: InputMaybe<Scalars['Int']>;
  /** Array of IDs for the objects to retrieve */
  in?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Get objects with a specific mimeType property */
  mimeType?: InputMaybe<MimeTypeEnum>;
  /** Slug / post_name of the object */
  name?: InputMaybe<Scalars['String']>;
  /** Specify objects to retrieve. Use slugs */
  nameIn?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;
  /** Specify IDs NOT to retrieve. If this is used in the same query as "in", it will be ignored */
  notIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** What paramater to use to order the objects by. */
  orderby?: InputMaybe<Array<InputMaybe<PostObjectsConnectionOrderbyInput>>>;
  /** Use ID to return only children. Use 0 to return only top-level items */
  parent?: InputMaybe<Scalars['ID']>;
  /** Specify objects whose parent is in an array */
  parentIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Specify posts whose parent is not in an array */
  parentNotIn?: InputMaybe<Array<InputMaybe<Scalars['ID']>>>;
  /** Show posts with a specific password. */
  password?: InputMaybe<Scalars['String']>;
  /** Show Posts based on a keyword search */
  search?: InputMaybe<Scalars['String']>;
  /** Retrieve posts where post status is in an array. */
  stati?: InputMaybe<Array<InputMaybe<PostStatusEnum>>>;
  /** Show posts with a specific status. */
  status?: InputMaybe<PostStatusEnum>;
  /** Title of the object */
  title?: InputMaybe<Scalars['String']>;
};

/** The writing setting type */
export type WritingSettings = {
  __typename?: 'WritingSettings';
  /** Default post category. */
  defaultCategory?: Maybe<Scalars['Int']>;
  /** Default post format. */
  defaultPostFormat?: Maybe<Scalars['String']>;
  /** Convert emoticons like :-) and :-P to graphics on display. */
  useSmilies?: Maybe<Scalars['Boolean']>;
};

export type XeroAddress = {
  __typename?: 'XeroAddress';
  addressLine1?: Maybe<Scalars['String']>;
  addressLine2?: Maybe<Scalars['String']>;
  addressType?: Maybe<XeroAddressType>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  postalCode?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
};

export enum XeroAddressType {
  Pobox = 'POBOX',
  Street = 'STREET'
}

export type XeroCallbackInput = {
  url: Scalars['String'];
};

export type XeroCallbackOutput = {
  __typename?: 'XeroCallbackOutput';
  status: Scalars['Boolean'];
};

export type XeroConnectOutput = {
  __typename?: 'XeroConnectOutput';
  consentUrl?: Maybe<Scalars['String']>;
};

export type XeroContact = {
  __typename?: 'XeroContact';
  addresses?: Maybe<Array<Maybe<XeroAddress>>>;
  contactID: Scalars['ID'];
  contactStatus: XeroContactStatus;
  emailAddress?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  isCustomer?: Maybe<Scalars['Boolean']>;
  lastName?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  phones?: Maybe<Array<Maybe<XeroPhone>>>;
  updatedDateUTC?: Maybe<Scalars['date']>;
};

export type XeroContactSearchInput = {
  searchTerm: Scalars['String'];
};

export type XeroContactSearchOutput = {
  __typename?: 'XeroContactSearchOutput';
  contacts: Array<XeroContact>;
};

export enum XeroContactStatus {
  Active = 'ACTIVE',
  Archived = 'ARCHIVED',
  Gdprrequest = 'GDPRREQUEST'
}

export type XeroDisconnectOutput = {
  __typename?: 'XeroDisconnectOutput';
  connected: Scalars['Boolean'];
};

export type XeroInvoice = {
  __typename?: 'XeroInvoice';
  amountDue?: Maybe<Scalars['String']>;
  amountPaid?: Maybe<Scalars['String']>;
  contact: XeroContact;
  currencyCode: Currency;
  date: Scalars['String'];
  dueDate?: Maybe<Scalars['String']>;
  fullyPaidOnDate?: Maybe<Scalars['String']>;
  invoiceID: Scalars['ID'];
  invoiceNumber?: Maybe<Scalars['String']>;
  lineItems: Array<Maybe<XeroLineItem>>;
  reference?: Maybe<Scalars['String']>;
  status: XeroInvoiceStatus;
  subTotal?: Maybe<Scalars['Float']>;
  total: Scalars['Float'];
  totalTax?: Maybe<Scalars['Float']>;
  type: Scalars['String'];
};

export enum XeroInvoiceStatus {
  Authorised = 'AUTHORISED',
  Deleted = 'DELETED',
  Draft = 'DRAFT',
  Overdue = 'OVERDUE',
  Paid = 'PAID',
  Submitted = 'SUBMITTED',
  Unknown = 'UNKNOWN',
  Voided = 'VOIDED'
}

export type XeroInvoiceStatusKv = {
  __typename?: 'XeroInvoiceStatusKV';
  invoiceNumber: Scalars['String'];
  status: XeroInvoiceStatus;
};

export type XeroInvoicesStatusInput = {
  invoiceNumberContains?: InputMaybe<Scalars['String']>;
  invoiceNumbers: Array<InputMaybe<Scalars['String']>>;
  statuses?: InputMaybe<Array<InputMaybe<XeroInvoiceStatus>>>;
};

export type XeroInvoicesStatusOutput = {
  __typename?: 'XeroInvoicesStatusOutput';
  invoices: Array<Maybe<XeroInvoiceStatusKv>>;
};

export type XeroItem = {
  __typename?: 'XeroItem';
  code: Scalars['String'];
  itemID: Scalars['String'];
};

export type XeroLineItem = {
  __typename?: 'XeroLineItem';
  accountCode?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  item?: Maybe<XeroItem>;
  itemCode: Scalars['String'];
  lineAmount: Scalars['Float'];
  quantity: Scalars['Int'];
  taxAmount: Scalars['Float'];
  taxType: Scalars['String'];
  tracking?: Maybe<Array<XeroTrackingCategory>>;
  unitAmount: Scalars['Float'];
};

export type XeroPhone = {
  __typename?: 'XeroPhone';
  phoneAreaCode?: Maybe<Scalars['String']>;
  phoneCountryCode?: Maybe<Scalars['String']>;
  phoneNumber?: Maybe<Scalars['String']>;
  phoneType: XeroPhoneType;
};

export enum XeroPhoneType {
  Ddi = 'DDI',
  Default = 'DEFAULT',
  Fax = 'FAX',
  Mobile = 'MOBILE'
}

export type XeroTrackingCategory = {
  __typename?: 'XeroTrackingCategory';
  name: Scalars['String'];
  option: Scalars['String'];
  trackingCategoryID: Scalars['String'];
};

export type ZoomMeeting = {
  __typename?: 'ZoomMeeting';
  id: Scalars['Int'];
  joinUrl: Scalars['String'];
};

export type ZoomMeetingNotFoundError = {
  __typename?: 'ZoomMeetingNotFoundError';
  id: Scalars['String'];
};

/** columns and relationships of "availability" */
export type Availability = {
  __typename?: 'availability';
  createdAt: Scalars['timestamptz'];
  description?: Maybe<Scalars['String']>;
  end: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  profile: Profile;
  profileId: Scalars['uuid'];
  start: Scalars['timestamptz'];
  type: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "availability" */
export type Availability_Aggregate = {
  __typename?: 'availability_aggregate';
  aggregate?: Maybe<Availability_Aggregate_Fields>;
  nodes: Array<Availability>;
};

/** aggregate fields of "availability" */
export type Availability_Aggregate_Fields = {
  __typename?: 'availability_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Availability_Max_Fields>;
  min?: Maybe<Availability_Min_Fields>;
};


/** aggregate fields of "availability" */
export type Availability_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Availability_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "availability". All fields are combined with a logical 'AND'. */
export type Availability_Bool_Exp = {
  _and?: InputMaybe<Array<Availability_Bool_Exp>>;
  _not?: InputMaybe<Availability_Bool_Exp>;
  _or?: InputMaybe<Array<Availability_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  end?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profileId?: InputMaybe<Uuid_Comparison_Exp>;
  start?: InputMaybe<Timestamptz_Comparison_Exp>;
  type?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "availability" */
export enum Availability_Constraint {
  /** unique or primary key constraint */
  AvailabilityPkey = 'availability_pkey'
}

/** input type for inserting data into table "availability" */
export type Availability_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  end?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profileId?: InputMaybe<Scalars['uuid']>;
  start?: InputMaybe<Scalars['timestamptz']>;
  type?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Availability_Max_Fields = {
  __typename?: 'availability_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  end?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  profileId?: Maybe<Scalars['uuid']>;
  start?: Maybe<Scalars['timestamptz']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Availability_Min_Fields = {
  __typename?: 'availability_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  end?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  profileId?: Maybe<Scalars['uuid']>;
  start?: Maybe<Scalars['timestamptz']>;
  type?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "availability" */
export type Availability_Mutation_Response = {
  __typename?: 'availability_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Availability>;
};

/** on_conflict condition type for table "availability" */
export type Availability_On_Conflict = {
  constraint: Availability_Constraint;
  update_columns?: Array<Availability_Update_Column>;
  where?: InputMaybe<Availability_Bool_Exp>;
};

/** Ordering options when selecting data from "availability". */
export type Availability_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  end?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profileId?: InputMaybe<Order_By>;
  start?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: availability */
export type Availability_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "availability" */
export enum Availability_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  End = 'end',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profileId',
  /** column name */
  Start = 'start',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "availability" */
export type Availability_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  end?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  profileId?: InputMaybe<Scalars['uuid']>;
  start?: InputMaybe<Scalars['timestamptz']>;
  type?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "availability" */
export enum Availability_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  End = 'end',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profileId',
  /** column name */
  Start = 'start',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** status enum for go1 course/module */
export type Blended_Learning_Status = {
  __typename?: 'blended_learning_status';
  name: Scalars['String'];
};

/** aggregated selection of "blended_learning_status" */
export type Blended_Learning_Status_Aggregate = {
  __typename?: 'blended_learning_status_aggregate';
  aggregate?: Maybe<Blended_Learning_Status_Aggregate_Fields>;
  nodes: Array<Blended_Learning_Status>;
};

/** aggregate fields of "blended_learning_status" */
export type Blended_Learning_Status_Aggregate_Fields = {
  __typename?: 'blended_learning_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Blended_Learning_Status_Max_Fields>;
  min?: Maybe<Blended_Learning_Status_Min_Fields>;
};


/** aggregate fields of "blended_learning_status" */
export type Blended_Learning_Status_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Blended_Learning_Status_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "blended_learning_status". All fields are combined with a logical 'AND'. */
export type Blended_Learning_Status_Bool_Exp = {
  _and?: InputMaybe<Array<Blended_Learning_Status_Bool_Exp>>;
  _not?: InputMaybe<Blended_Learning_Status_Bool_Exp>;
  _or?: InputMaybe<Array<Blended_Learning_Status_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "blended_learning_status" */
export enum Blended_Learning_Status_Constraint {
  /** unique or primary key constraint */
  BlendedLearningStatusPkey = 'blended_learning_status_pkey'
}

export enum Blended_Learning_Status_Enum {
  Assigned = 'ASSIGNED',
  Completed = 'COMPLETED',
  InProgress = 'IN_PROGRESS',
  NotStarted = 'NOT_STARTED'
}

/** Boolean expression to compare columns of type "blended_learning_status_enum". All fields are combined with logical 'AND'. */
export type Blended_Learning_Status_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Blended_Learning_Status_Enum>;
  _in?: InputMaybe<Array<Blended_Learning_Status_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Blended_Learning_Status_Enum>;
  _nin?: InputMaybe<Array<Blended_Learning_Status_Enum>>;
};

/** input type for inserting data into table "blended_learning_status" */
export type Blended_Learning_Status_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Blended_Learning_Status_Max_Fields = {
  __typename?: 'blended_learning_status_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Blended_Learning_Status_Min_Fields = {
  __typename?: 'blended_learning_status_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "blended_learning_status" */
export type Blended_Learning_Status_Mutation_Response = {
  __typename?: 'blended_learning_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Blended_Learning_Status>;
};

/** on_conflict condition type for table "blended_learning_status" */
export type Blended_Learning_Status_On_Conflict = {
  constraint: Blended_Learning_Status_Constraint;
  update_columns?: Array<Blended_Learning_Status_Update_Column>;
  where?: InputMaybe<Blended_Learning_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "blended_learning_status". */
export type Blended_Learning_Status_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: blended_learning_status */
export type Blended_Learning_Status_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "blended_learning_status" */
export enum Blended_Learning_Status_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "blended_learning_status" */
export type Blended_Learning_Status_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "blended_learning_status" */
export enum Blended_Learning_Status_Update_Column {
  /** column name */
  Name = 'name'
}

/** columns and relationships of "certificate_status" */
export type Certificate_Status = {
  __typename?: 'certificate_status';
  name: Scalars['String'];
};

/** aggregated selection of "certificate_status" */
export type Certificate_Status_Aggregate = {
  __typename?: 'certificate_status_aggregate';
  aggregate?: Maybe<Certificate_Status_Aggregate_Fields>;
  nodes: Array<Certificate_Status>;
};

/** aggregate fields of "certificate_status" */
export type Certificate_Status_Aggregate_Fields = {
  __typename?: 'certificate_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Certificate_Status_Max_Fields>;
  min?: Maybe<Certificate_Status_Min_Fields>;
};


/** aggregate fields of "certificate_status" */
export type Certificate_Status_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Certificate_Status_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "certificate_status". All fields are combined with a logical 'AND'. */
export type Certificate_Status_Bool_Exp = {
  _and?: InputMaybe<Array<Certificate_Status_Bool_Exp>>;
  _not?: InputMaybe<Certificate_Status_Bool_Exp>;
  _or?: InputMaybe<Array<Certificate_Status_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "certificate_status" */
export enum Certificate_Status_Constraint {
  /** unique or primary key constraint */
  CertificateStatusPkey = 'certificate_status_pkey'
}

/** input type for inserting data into table "certificate_status" */
export type Certificate_Status_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Certificate_Status_Max_Fields = {
  __typename?: 'certificate_status_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Certificate_Status_Min_Fields = {
  __typename?: 'certificate_status_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "certificate_status" */
export type Certificate_Status_Mutation_Response = {
  __typename?: 'certificate_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Certificate_Status>;
};

/** on_conflict condition type for table "certificate_status" */
export type Certificate_Status_On_Conflict = {
  constraint: Certificate_Status_Constraint;
  update_columns?: Array<Certificate_Status_Update_Column>;
  where?: InputMaybe<Certificate_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "certificate_status". */
export type Certificate_Status_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: certificate_status */
export type Certificate_Status_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "certificate_status" */
export enum Certificate_Status_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "certificate_status" */
export type Certificate_Status_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "certificate_status" */
export enum Certificate_Status_Update_Column {
  /** column name */
  Name = 'name'
}

/** columns and relationships of "color" */
export type Color = {
  __typename?: 'color';
  name: Scalars['String'];
};

/** aggregated selection of "color" */
export type Color_Aggregate = {
  __typename?: 'color_aggregate';
  aggregate?: Maybe<Color_Aggregate_Fields>;
  nodes: Array<Color>;
};

/** aggregate fields of "color" */
export type Color_Aggregate_Fields = {
  __typename?: 'color_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Color_Max_Fields>;
  min?: Maybe<Color_Min_Fields>;
};


/** aggregate fields of "color" */
export type Color_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Color_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "color". All fields are combined with a logical 'AND'. */
export type Color_Bool_Exp = {
  _and?: InputMaybe<Array<Color_Bool_Exp>>;
  _not?: InputMaybe<Color_Bool_Exp>;
  _or?: InputMaybe<Array<Color_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "color" */
export enum Color_Constraint {
  /** unique or primary key constraint */
  ColorPkey = 'color_pkey'
}

export enum Color_Enum {
  Fuschia = 'fuschia',
  Grey = 'grey',
  Lime = 'lime',
  Navy = 'navy',
  Purple = 'purple',
  Teal = 'teal',
  Yellow = 'yellow'
}

/** Boolean expression to compare columns of type "color_enum". All fields are combined with logical 'AND'. */
export type Color_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Color_Enum>;
  _in?: InputMaybe<Array<Color_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Color_Enum>;
  _nin?: InputMaybe<Array<Color_Enum>>;
};

/** input type for inserting data into table "color" */
export type Color_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Color_Max_Fields = {
  __typename?: 'color_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Color_Min_Fields = {
  __typename?: 'color_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "color" */
export type Color_Mutation_Response = {
  __typename?: 'color_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Color>;
};

/** on_conflict condition type for table "color" */
export type Color_On_Conflict = {
  constraint: Color_Constraint;
  update_columns?: Array<Color_Update_Column>;
  where?: InputMaybe<Color_Bool_Exp>;
};

/** Ordering options when selecting data from "color". */
export type Color_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: color */
export type Color_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "color" */
export enum Color_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "color" */
export type Color_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "color" */
export enum Color_Update_Column {
  /** column name */
  Name = 'name'
}

/** columns and relationships of "course" */
export type Course = {
  __typename?: 'course';
  accountCode?: Maybe<Scalars['String']>;
  aolCostOfCourse?: Maybe<Scalars['numeric']>;
  aolCountry?: Maybe<Scalars['String']>;
  aolRegion?: Maybe<Scalars['String']>;
  cancellationFeePercent?: Maybe<Scalars['Int']>;
  cancellationReason?: Maybe<Scalars['String']>;
  /** An object relationship */
  cancellationRequest?: Maybe<Course_Cancellation_Request>;
  /** An object relationship */
  contactProfile?: Maybe<Profile>;
  contactProfileId?: Maybe<Scalars['uuid']>;
  /** A computed field, executes function "course_code" */
  course_code?: Maybe<Scalars['String']>;
  createdAt: Scalars['timestamptz'];
  deliveryType: Course_Delivery_Type_Enum;
  description?: Maybe<Scalars['String']>;
  /** A computed field, executes function "course_end_date" */
  end?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  evaluation_answers: Array<Course_Evaluation_Answers>;
  /** An aggregate relationship */
  evaluation_answers_aggregate: Course_Evaluation_Answers_Aggregate;
  /** An array relationship */
  expenses: Array<Course_Expenses>;
  /** An aggregate relationship */
  expenses_aggregate: Course_Expenses_Aggregate;
  freeSpaces?: Maybe<Scalars['Int']>;
  go1Integration: Scalars['Boolean'];
  gradingConfirmed: Scalars['Boolean'];
  gradingStarted: Scalars['Boolean'];
  id: Scalars['Int'];
  level: Course_Level_Enum;
  max_participants: Scalars['Int'];
  min_participants: Scalars['Int'];
  /** An array relationship */
  modules: Array<Course_Module>;
  modulesDuration: Scalars['Int'];
  /** An aggregate relationship */
  modules_aggregate: Course_Module_Aggregate;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  /** An array relationship */
  orders: Array<Order>;
  /** An aggregate relationship */
  orders_aggregate: Order_Aggregate;
  /** An object relationship */
  organization?: Maybe<Organization>;
  organization_id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  participants: Array<Course_Participant>;
  /** An aggregate relationship */
  participants_aggregate: Course_Participant_Aggregate;
  /** An array relationship */
  promo_codes: Array<Course_Promo_Code>;
  /** An aggregate relationship */
  promo_codes_aggregate: Course_Promo_Code_Aggregate;
  reaccreditation?: Maybe<Scalars['Boolean']>;
  /** An object relationship */
  salesRepresentative?: Maybe<Profile>;
  salesRepresentativeId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  schedule: Array<Course_Schedule>;
  /** An aggregate relationship */
  schedule_aggregate: Course_Schedule_Aggregate;
  /** A computed field, executes function "course_start_date" */
  start?: Maybe<Scalars['timestamptz']>;
  status?: Maybe<Course_Status_Enum>;
  /** An array relationship */
  trainers: Array<Course_Trainer>;
  /** An aggregate relationship */
  trainers_aggregate: Course_Trainer_Aggregate;
  type: Course_Type_Enum;
  updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  waitlists: Array<Waitlist>;
  /** An aggregate relationship */
  waitlists_aggregate: Waitlist_Aggregate;
};


/** columns and relationships of "course" */
export type CourseEvaluation_AnswersArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Answers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Answers_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Answers_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseEvaluation_Answers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Answers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Answers_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Answers_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseExpensesArgs = {
  distinct_on?: InputMaybe<Array<Course_Expenses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Expenses_Order_By>>;
  where?: InputMaybe<Course_Expenses_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseExpenses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Expenses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Expenses_Order_By>>;
  where?: InputMaybe<Course_Expenses_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseModulesArgs = {
  distinct_on?: InputMaybe<Array<Course_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Module_Order_By>>;
  where?: InputMaybe<Course_Module_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseModules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Module_Order_By>>;
  where?: InputMaybe<Course_Module_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseOrdersArgs = {
  distinct_on?: InputMaybe<Array<Order_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Order_Order_By>>;
  where?: InputMaybe<Order_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseOrders_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Order_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Order_Order_By>>;
  where?: InputMaybe<Order_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseParticipantsArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Order_By>>;
  where?: InputMaybe<Course_Participant_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseParticipants_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Order_By>>;
  where?: InputMaybe<Course_Participant_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CoursePromo_CodesArgs = {
  distinct_on?: InputMaybe<Array<Course_Promo_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Promo_Code_Order_By>>;
  where?: InputMaybe<Course_Promo_Code_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CoursePromo_Codes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Promo_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Promo_Code_Order_By>>;
  where?: InputMaybe<Course_Promo_Code_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseScheduleArgs = {
  distinct_on?: InputMaybe<Array<Course_Schedule_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Schedule_Order_By>>;
  where?: InputMaybe<Course_Schedule_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseSchedule_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Schedule_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Schedule_Order_By>>;
  where?: InputMaybe<Course_Schedule_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseTrainersArgs = {
  distinct_on?: InputMaybe<Array<Course_Trainer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Trainer_Order_By>>;
  where?: InputMaybe<Course_Trainer_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseTrainers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Trainer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Trainer_Order_By>>;
  where?: InputMaybe<Course_Trainer_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseWaitlistsArgs = {
  distinct_on?: InputMaybe<Array<Waitlist_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Waitlist_Order_By>>;
  where?: InputMaybe<Waitlist_Bool_Exp>;
};


/** columns and relationships of "course" */
export type CourseWaitlists_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Waitlist_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Waitlist_Order_By>>;
  where?: InputMaybe<Waitlist_Bool_Exp>;
};

/** aggregated selection of "course" */
export type Course_Aggregate = {
  __typename?: 'course_aggregate';
  aggregate?: Maybe<Course_Aggregate_Fields>;
  nodes: Array<Course>;
};

/** aggregate fields of "course" */
export type Course_Aggregate_Fields = {
  __typename?: 'course_aggregate_fields';
  avg?: Maybe<Course_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Max_Fields>;
  min?: Maybe<Course_Min_Fields>;
  stddev?: Maybe<Course_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Sum_Fields>;
  var_pop?: Maybe<Course_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Var_Samp_Fields>;
  variance?: Maybe<Course_Variance_Fields>;
};


/** aggregate fields of "course" */
export type Course_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "course" */
export type Course_Aggregate_Order_By = {
  avg?: InputMaybe<Course_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Course_Max_Order_By>;
  min?: InputMaybe<Course_Min_Order_By>;
  stddev?: InputMaybe<Course_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Course_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Course_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Course_Sum_Order_By>;
  var_pop?: InputMaybe<Course_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Course_Var_Samp_Order_By>;
  variance?: InputMaybe<Course_Variance_Order_By>;
};

/** columns and relationships of "course_audit" */
export type Course_Audit = {
  __typename?: 'course_audit';
  /** An object relationship */
  authorizedBy: Profile;
  authorized_by: Scalars['uuid'];
  /** An object relationship */
  course: Course;
  course_id: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  payload: Scalars['jsonb'];
  type: Course_Audit_Type_Enum;
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "course_audit" */
export type Course_AuditPayloadArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "course_audit" */
export type Course_Audit_Aggregate = {
  __typename?: 'course_audit_aggregate';
  aggregate?: Maybe<Course_Audit_Aggregate_Fields>;
  nodes: Array<Course_Audit>;
};

/** aggregate fields of "course_audit" */
export type Course_Audit_Aggregate_Fields = {
  __typename?: 'course_audit_aggregate_fields';
  avg?: Maybe<Course_Audit_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Audit_Max_Fields>;
  min?: Maybe<Course_Audit_Min_Fields>;
  stddev?: Maybe<Course_Audit_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Audit_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Audit_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Audit_Sum_Fields>;
  var_pop?: Maybe<Course_Audit_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Audit_Var_Samp_Fields>;
  variance?: Maybe<Course_Audit_Variance_Fields>;
};


/** aggregate fields of "course_audit" */
export type Course_Audit_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Audit_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Course_Audit_Append_Input = {
  payload?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Course_Audit_Avg_Fields = {
  __typename?: 'course_audit_avg_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "course_audit". All fields are combined with a logical 'AND'. */
export type Course_Audit_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Audit_Bool_Exp>>;
  _not?: InputMaybe<Course_Audit_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Audit_Bool_Exp>>;
  authorizedBy?: InputMaybe<Profile_Bool_Exp>;
  authorized_by?: InputMaybe<Uuid_Comparison_Exp>;
  course?: InputMaybe<Course_Bool_Exp>;
  course_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  payload?: InputMaybe<Jsonb_Comparison_Exp>;
  type?: InputMaybe<Course_Audit_Type_Enum_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_audit" */
export enum Course_Audit_Constraint {
  /** unique or primary key constraint */
  CourseAuditPkey = 'course_audit_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Course_Audit_Delete_At_Path_Input = {
  payload?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Course_Audit_Delete_Elem_Input = {
  payload?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Course_Audit_Delete_Key_Input = {
  payload?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "course_audit" */
export type Course_Audit_Inc_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_audit" */
export type Course_Audit_Insert_Input = {
  authorizedBy?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  authorized_by?: InputMaybe<Scalars['uuid']>;
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  course_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  payload?: InputMaybe<Scalars['jsonb']>;
  type?: InputMaybe<Course_Audit_Type_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Course_Audit_Max_Fields = {
  __typename?: 'course_audit_max_fields';
  authorized_by?: Maybe<Scalars['uuid']>;
  course_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Course_Audit_Min_Fields = {
  __typename?: 'course_audit_min_fields';
  authorized_by?: Maybe<Scalars['uuid']>;
  course_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "course_audit" */
export type Course_Audit_Mutation_Response = {
  __typename?: 'course_audit_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Audit>;
};

/** on_conflict condition type for table "course_audit" */
export type Course_Audit_On_Conflict = {
  constraint: Course_Audit_Constraint;
  update_columns?: Array<Course_Audit_Update_Column>;
  where?: InputMaybe<Course_Audit_Bool_Exp>;
};

/** Ordering options when selecting data from "course_audit". */
export type Course_Audit_Order_By = {
  authorizedBy?: InputMaybe<Profile_Order_By>;
  authorized_by?: InputMaybe<Order_By>;
  course?: InputMaybe<Course_Order_By>;
  course_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  payload?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_audit */
export type Course_Audit_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Course_Audit_Prepend_Input = {
  payload?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "course_audit" */
export enum Course_Audit_Select_Column {
  /** column name */
  AuthorizedBy = 'authorized_by',
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Payload = 'payload',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "course_audit" */
export type Course_Audit_Set_Input = {
  authorized_by?: InputMaybe<Scalars['uuid']>;
  course_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  payload?: InputMaybe<Scalars['jsonb']>;
  type?: InputMaybe<Course_Audit_Type_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Course_Audit_Stddev_Fields = {
  __typename?: 'course_audit_stddev_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Course_Audit_Stddev_Pop_Fields = {
  __typename?: 'course_audit_stddev_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Course_Audit_Stddev_Samp_Fields = {
  __typename?: 'course_audit_stddev_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Course_Audit_Sum_Fields = {
  __typename?: 'course_audit_sum_fields';
  course_id?: Maybe<Scalars['Int']>;
};

/** columns and relationships of "course_audit_type" */
export type Course_Audit_Type = {
  __typename?: 'course_audit_type';
  name: Scalars['String'];
};

/** aggregated selection of "course_audit_type" */
export type Course_Audit_Type_Aggregate = {
  __typename?: 'course_audit_type_aggregate';
  aggregate?: Maybe<Course_Audit_Type_Aggregate_Fields>;
  nodes: Array<Course_Audit_Type>;
};

/** aggregate fields of "course_audit_type" */
export type Course_Audit_Type_Aggregate_Fields = {
  __typename?: 'course_audit_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Audit_Type_Max_Fields>;
  min?: Maybe<Course_Audit_Type_Min_Fields>;
};


/** aggregate fields of "course_audit_type" */
export type Course_Audit_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Audit_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "course_audit_type". All fields are combined with a logical 'AND'. */
export type Course_Audit_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Audit_Type_Bool_Exp>>;
  _not?: InputMaybe<Course_Audit_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Audit_Type_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_audit_type" */
export enum Course_Audit_Type_Constraint {
  /** unique or primary key constraint */
  CourseAuditTypePkey = 'course_audit_type_pkey'
}

export enum Course_Audit_Type_Enum {
  Cancellation = 'CANCELLATION',
  Reschedule = 'RESCHEDULE'
}

/** Boolean expression to compare columns of type "course_audit_type_enum". All fields are combined with logical 'AND'. */
export type Course_Audit_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Course_Audit_Type_Enum>;
  _in?: InputMaybe<Array<Course_Audit_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Course_Audit_Type_Enum>;
  _nin?: InputMaybe<Array<Course_Audit_Type_Enum>>;
};

/** input type for inserting data into table "course_audit_type" */
export type Course_Audit_Type_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Audit_Type_Max_Fields = {
  __typename?: 'course_audit_type_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Audit_Type_Min_Fields = {
  __typename?: 'course_audit_type_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_audit_type" */
export type Course_Audit_Type_Mutation_Response = {
  __typename?: 'course_audit_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Audit_Type>;
};

/** on_conflict condition type for table "course_audit_type" */
export type Course_Audit_Type_On_Conflict = {
  constraint: Course_Audit_Type_Constraint;
  update_columns?: Array<Course_Audit_Type_Update_Column>;
  where?: InputMaybe<Course_Audit_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "course_audit_type". */
export type Course_Audit_Type_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_audit_type */
export type Course_Audit_Type_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "course_audit_type" */
export enum Course_Audit_Type_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "course_audit_type" */
export type Course_Audit_Type_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "course_audit_type" */
export enum Course_Audit_Type_Update_Column {
  /** column name */
  Name = 'name'
}

/** update columns of table "course_audit" */
export enum Course_Audit_Update_Column {
  /** column name */
  AuthorizedBy = 'authorized_by',
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Payload = 'payload',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Course_Audit_Var_Pop_Fields = {
  __typename?: 'course_audit_var_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Course_Audit_Var_Samp_Fields = {
  __typename?: 'course_audit_var_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Course_Audit_Variance_Fields = {
  __typename?: 'course_audit_variance_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate avg on columns */
export type Course_Avg_Fields = {
  __typename?: 'course_avg_fields';
  aolCostOfCourse?: Maybe<Scalars['Float']>;
  cancellationFeePercent?: Maybe<Scalars['Float']>;
  freeSpaces?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_participants?: Maybe<Scalars['Float']>;
  min_participants?: Maybe<Scalars['Float']>;
  modulesDuration?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "course" */
export type Course_Avg_Order_By = {
  aolCostOfCourse?: InputMaybe<Order_By>;
  cancellationFeePercent?: InputMaybe<Order_By>;
  freeSpaces?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  max_participants?: InputMaybe<Order_By>;
  min_participants?: InputMaybe<Order_By>;
  modulesDuration?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "course". All fields are combined with a logical 'AND'. */
export type Course_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Bool_Exp>>;
  _not?: InputMaybe<Course_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Bool_Exp>>;
  accountCode?: InputMaybe<String_Comparison_Exp>;
  aolCostOfCourse?: InputMaybe<Numeric_Comparison_Exp>;
  aolCountry?: InputMaybe<String_Comparison_Exp>;
  aolRegion?: InputMaybe<String_Comparison_Exp>;
  cancellationFeePercent?: InputMaybe<Int_Comparison_Exp>;
  cancellationReason?: InputMaybe<String_Comparison_Exp>;
  cancellationRequest?: InputMaybe<Course_Cancellation_Request_Bool_Exp>;
  contactProfile?: InputMaybe<Profile_Bool_Exp>;
  contactProfileId?: InputMaybe<Uuid_Comparison_Exp>;
  course_code?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deliveryType?: InputMaybe<Course_Delivery_Type_Enum_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  end?: InputMaybe<Timestamptz_Comparison_Exp>;
  evaluation_answers?: InputMaybe<Course_Evaluation_Answers_Bool_Exp>;
  expenses?: InputMaybe<Course_Expenses_Bool_Exp>;
  freeSpaces?: InputMaybe<Int_Comparison_Exp>;
  go1Integration?: InputMaybe<Boolean_Comparison_Exp>;
  gradingConfirmed?: InputMaybe<Boolean_Comparison_Exp>;
  gradingStarted?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  level?: InputMaybe<Course_Level_Enum_Comparison_Exp>;
  max_participants?: InputMaybe<Int_Comparison_Exp>;
  min_participants?: InputMaybe<Int_Comparison_Exp>;
  modules?: InputMaybe<Course_Module_Bool_Exp>;
  modulesDuration?: InputMaybe<Int_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  orders?: InputMaybe<Order_Bool_Exp>;
  organization?: InputMaybe<Organization_Bool_Exp>;
  organization_id?: InputMaybe<Uuid_Comparison_Exp>;
  participants?: InputMaybe<Course_Participant_Bool_Exp>;
  promo_codes?: InputMaybe<Course_Promo_Code_Bool_Exp>;
  reaccreditation?: InputMaybe<Boolean_Comparison_Exp>;
  salesRepresentative?: InputMaybe<Profile_Bool_Exp>;
  salesRepresentativeId?: InputMaybe<Uuid_Comparison_Exp>;
  schedule?: InputMaybe<Course_Schedule_Bool_Exp>;
  start?: InputMaybe<Timestamptz_Comparison_Exp>;
  status?: InputMaybe<Course_Status_Enum_Comparison_Exp>;
  trainers?: InputMaybe<Course_Trainer_Bool_Exp>;
  type?: InputMaybe<Course_Type_Enum_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  waitlists?: InputMaybe<Waitlist_Bool_Exp>;
};

/** columns and relationships of "course_cancellation_request" */
export type Course_Cancellation_Request = {
  __typename?: 'course_cancellation_request';
  /** An object relationship */
  course: Course;
  course_id: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  profile: Profile;
  reason: Scalars['String'];
  requested_by: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "course_cancellation_request" */
export type Course_Cancellation_Request_Aggregate = {
  __typename?: 'course_cancellation_request_aggregate';
  aggregate?: Maybe<Course_Cancellation_Request_Aggregate_Fields>;
  nodes: Array<Course_Cancellation_Request>;
};

/** aggregate fields of "course_cancellation_request" */
export type Course_Cancellation_Request_Aggregate_Fields = {
  __typename?: 'course_cancellation_request_aggregate_fields';
  avg?: Maybe<Course_Cancellation_Request_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Cancellation_Request_Max_Fields>;
  min?: Maybe<Course_Cancellation_Request_Min_Fields>;
  stddev?: Maybe<Course_Cancellation_Request_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Cancellation_Request_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Cancellation_Request_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Cancellation_Request_Sum_Fields>;
  var_pop?: Maybe<Course_Cancellation_Request_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Cancellation_Request_Var_Samp_Fields>;
  variance?: Maybe<Course_Cancellation_Request_Variance_Fields>;
};


/** aggregate fields of "course_cancellation_request" */
export type Course_Cancellation_Request_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Cancellation_Request_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Course_Cancellation_Request_Avg_Fields = {
  __typename?: 'course_cancellation_request_avg_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "course_cancellation_request". All fields are combined with a logical 'AND'. */
export type Course_Cancellation_Request_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Cancellation_Request_Bool_Exp>>;
  _not?: InputMaybe<Course_Cancellation_Request_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Cancellation_Request_Bool_Exp>>;
  course?: InputMaybe<Course_Bool_Exp>;
  course_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  reason?: InputMaybe<String_Comparison_Exp>;
  requested_by?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_cancellation_request" */
export enum Course_Cancellation_Request_Constraint {
  /** unique or primary key constraint */
  CourseCancellationRequestCourseIdKey = 'course_cancellation_request_course_id_key',
  /** unique or primary key constraint */
  CourseCancellationRequestPkey = 'course_cancellation_request_pkey'
}

/** input type for incrementing numeric columns in table "course_cancellation_request" */
export type Course_Cancellation_Request_Inc_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_cancellation_request" */
export type Course_Cancellation_Request_Insert_Input = {
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  course_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  reason?: InputMaybe<Scalars['String']>;
  requested_by?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Course_Cancellation_Request_Max_Fields = {
  __typename?: 'course_cancellation_request_max_fields';
  course_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  reason?: Maybe<Scalars['String']>;
  requested_by?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Course_Cancellation_Request_Min_Fields = {
  __typename?: 'course_cancellation_request_min_fields';
  course_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  reason?: Maybe<Scalars['String']>;
  requested_by?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "course_cancellation_request" */
export type Course_Cancellation_Request_Mutation_Response = {
  __typename?: 'course_cancellation_request_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Cancellation_Request>;
};

/** input type for inserting object relation for remote table "course_cancellation_request" */
export type Course_Cancellation_Request_Obj_Rel_Insert_Input = {
  data: Course_Cancellation_Request_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Cancellation_Request_On_Conflict>;
};

/** on_conflict condition type for table "course_cancellation_request" */
export type Course_Cancellation_Request_On_Conflict = {
  constraint: Course_Cancellation_Request_Constraint;
  update_columns?: Array<Course_Cancellation_Request_Update_Column>;
  where?: InputMaybe<Course_Cancellation_Request_Bool_Exp>;
};

/** Ordering options when selecting data from "course_cancellation_request". */
export type Course_Cancellation_Request_Order_By = {
  course?: InputMaybe<Course_Order_By>;
  course_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  reason?: InputMaybe<Order_By>;
  requested_by?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_cancellation_request */
export type Course_Cancellation_Request_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_cancellation_request" */
export enum Course_Cancellation_Request_Select_Column {
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Reason = 'reason',
  /** column name */
  RequestedBy = 'requested_by',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "course_cancellation_request" */
export type Course_Cancellation_Request_Set_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  reason?: InputMaybe<Scalars['String']>;
  requested_by?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Course_Cancellation_Request_Stddev_Fields = {
  __typename?: 'course_cancellation_request_stddev_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Course_Cancellation_Request_Stddev_Pop_Fields = {
  __typename?: 'course_cancellation_request_stddev_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Course_Cancellation_Request_Stddev_Samp_Fields = {
  __typename?: 'course_cancellation_request_stddev_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Course_Cancellation_Request_Sum_Fields = {
  __typename?: 'course_cancellation_request_sum_fields';
  course_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "course_cancellation_request" */
export enum Course_Cancellation_Request_Update_Column {
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Reason = 'reason',
  /** column name */
  RequestedBy = 'requested_by',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Course_Cancellation_Request_Var_Pop_Fields = {
  __typename?: 'course_cancellation_request_var_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Course_Cancellation_Request_Var_Samp_Fields = {
  __typename?: 'course_cancellation_request_var_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Course_Cancellation_Request_Variance_Fields = {
  __typename?: 'course_cancellation_request_variance_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "course_certificate" */
export type Course_Certificate = {
  __typename?: 'course_certificate';
  certificationDate: Scalars['date'];
  /** An object relationship */
  course?: Maybe<Course>;
  courseId?: Maybe<Scalars['Int']>;
  courseLevel: Scalars['String'];
  courseName: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  expiryDate: Scalars['date'];
  id: Scalars['uuid'];
  number: Scalars['String'];
  /** An object relationship */
  participant?: Maybe<Course_Participant>;
  /** An object relationship */
  profile?: Maybe<Profile>;
  profileId: Scalars['uuid'];
  /** A computed field, executes function "course_certificate_status" */
  status?: Maybe<Scalars['String']>;
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "course_certificate" */
export type Course_Certificate_Aggregate = {
  __typename?: 'course_certificate_aggregate';
  aggregate?: Maybe<Course_Certificate_Aggregate_Fields>;
  nodes: Array<Course_Certificate>;
};

/** aggregate fields of "course_certificate" */
export type Course_Certificate_Aggregate_Fields = {
  __typename?: 'course_certificate_aggregate_fields';
  avg?: Maybe<Course_Certificate_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Certificate_Max_Fields>;
  min?: Maybe<Course_Certificate_Min_Fields>;
  stddev?: Maybe<Course_Certificate_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Certificate_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Certificate_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Certificate_Sum_Fields>;
  var_pop?: Maybe<Course_Certificate_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Certificate_Var_Samp_Fields>;
  variance?: Maybe<Course_Certificate_Variance_Fields>;
};


/** aggregate fields of "course_certificate" */
export type Course_Certificate_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Certificate_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "course_certificate" */
export type Course_Certificate_Aggregate_Order_By = {
  avg?: InputMaybe<Course_Certificate_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Course_Certificate_Max_Order_By>;
  min?: InputMaybe<Course_Certificate_Min_Order_By>;
  stddev?: InputMaybe<Course_Certificate_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Course_Certificate_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Course_Certificate_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Course_Certificate_Sum_Order_By>;
  var_pop?: InputMaybe<Course_Certificate_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Course_Certificate_Var_Samp_Order_By>;
  variance?: InputMaybe<Course_Certificate_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "course_certificate" */
export type Course_Certificate_Arr_Rel_Insert_Input = {
  data: Array<Course_Certificate_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Certificate_On_Conflict>;
};

/** aggregate avg on columns */
export type Course_Certificate_Avg_Fields = {
  __typename?: 'course_certificate_avg_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "course_certificate" */
export type Course_Certificate_Avg_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "course_certificate". All fields are combined with a logical 'AND'. */
export type Course_Certificate_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Certificate_Bool_Exp>>;
  _not?: InputMaybe<Course_Certificate_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Certificate_Bool_Exp>>;
  certificationDate?: InputMaybe<Date_Comparison_Exp>;
  course?: InputMaybe<Course_Bool_Exp>;
  courseId?: InputMaybe<Int_Comparison_Exp>;
  courseLevel?: InputMaybe<String_Comparison_Exp>;
  courseName?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  expiryDate?: InputMaybe<Date_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  number?: InputMaybe<String_Comparison_Exp>;
  participant?: InputMaybe<Course_Participant_Bool_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profileId?: InputMaybe<Uuid_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** columns and relationships of "course_certificate_changelog" */
export type Course_Certificate_Changelog = {
  __typename?: 'course_certificate_changelog';
  /** An object relationship */
  author: Profile;
  authorId: Scalars['uuid'];
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  newGrade: Grade_Enum;
  notes: Scalars['String'];
  oldGrade: Grade_Enum;
  /** An object relationship */
  participant: Course_Participant;
  participantId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "course_certificate_changelog" */
export type Course_Certificate_Changelog_Aggregate = {
  __typename?: 'course_certificate_changelog_aggregate';
  aggregate?: Maybe<Course_Certificate_Changelog_Aggregate_Fields>;
  nodes: Array<Course_Certificate_Changelog>;
};

/** aggregate fields of "course_certificate_changelog" */
export type Course_Certificate_Changelog_Aggregate_Fields = {
  __typename?: 'course_certificate_changelog_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Certificate_Changelog_Max_Fields>;
  min?: Maybe<Course_Certificate_Changelog_Min_Fields>;
};


/** aggregate fields of "course_certificate_changelog" */
export type Course_Certificate_Changelog_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Certificate_Changelog_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "course_certificate_changelog" */
export type Course_Certificate_Changelog_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Course_Certificate_Changelog_Max_Order_By>;
  min?: InputMaybe<Course_Certificate_Changelog_Min_Order_By>;
};

/** input type for inserting array relation for remote table "course_certificate_changelog" */
export type Course_Certificate_Changelog_Arr_Rel_Insert_Input = {
  data: Array<Course_Certificate_Changelog_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Certificate_Changelog_On_Conflict>;
};

/** Boolean expression to filter rows from the table "course_certificate_changelog". All fields are combined with a logical 'AND'. */
export type Course_Certificate_Changelog_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Certificate_Changelog_Bool_Exp>>;
  _not?: InputMaybe<Course_Certificate_Changelog_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Certificate_Changelog_Bool_Exp>>;
  author?: InputMaybe<Profile_Bool_Exp>;
  authorId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  newGrade?: InputMaybe<Grade_Enum_Comparison_Exp>;
  notes?: InputMaybe<String_Comparison_Exp>;
  oldGrade?: InputMaybe<Grade_Enum_Comparison_Exp>;
  participant?: InputMaybe<Course_Participant_Bool_Exp>;
  participantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_certificate_changelog" */
export enum Course_Certificate_Changelog_Constraint {
  /** unique or primary key constraint */
  CourseCertificateChangelogPkey = 'course_certificate_changelog_pkey'
}

/** input type for inserting data into table "course_certificate_changelog" */
export type Course_Certificate_Changelog_Insert_Input = {
  author?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  authorId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  newGrade?: InputMaybe<Grade_Enum>;
  notes?: InputMaybe<Scalars['String']>;
  oldGrade?: InputMaybe<Grade_Enum>;
  participant?: InputMaybe<Course_Participant_Obj_Rel_Insert_Input>;
  participantId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Course_Certificate_Changelog_Max_Fields = {
  __typename?: 'course_certificate_changelog_max_fields';
  authorId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  notes?: Maybe<Scalars['String']>;
  participantId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "course_certificate_changelog" */
export type Course_Certificate_Changelog_Max_Order_By = {
  authorId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  participantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Course_Certificate_Changelog_Min_Fields = {
  __typename?: 'course_certificate_changelog_min_fields';
  authorId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  notes?: Maybe<Scalars['String']>;
  participantId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "course_certificate_changelog" */
export type Course_Certificate_Changelog_Min_Order_By = {
  authorId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  participantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "course_certificate_changelog" */
export type Course_Certificate_Changelog_Mutation_Response = {
  __typename?: 'course_certificate_changelog_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Certificate_Changelog>;
};

/** on_conflict condition type for table "course_certificate_changelog" */
export type Course_Certificate_Changelog_On_Conflict = {
  constraint: Course_Certificate_Changelog_Constraint;
  update_columns?: Array<Course_Certificate_Changelog_Update_Column>;
  where?: InputMaybe<Course_Certificate_Changelog_Bool_Exp>;
};

/** Ordering options when selecting data from "course_certificate_changelog". */
export type Course_Certificate_Changelog_Order_By = {
  author?: InputMaybe<Profile_Order_By>;
  authorId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  newGrade?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  oldGrade?: InputMaybe<Order_By>;
  participant?: InputMaybe<Course_Participant_Order_By>;
  participantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_certificate_changelog */
export type Course_Certificate_Changelog_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_certificate_changelog" */
export enum Course_Certificate_Changelog_Select_Column {
  /** column name */
  AuthorId = 'authorId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  NewGrade = 'newGrade',
  /** column name */
  Notes = 'notes',
  /** column name */
  OldGrade = 'oldGrade',
  /** column name */
  ParticipantId = 'participantId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "course_certificate_changelog" */
export type Course_Certificate_Changelog_Set_Input = {
  authorId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  newGrade?: InputMaybe<Grade_Enum>;
  notes?: InputMaybe<Scalars['String']>;
  oldGrade?: InputMaybe<Grade_Enum>;
  participantId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "course_certificate_changelog" */
export enum Course_Certificate_Changelog_Update_Column {
  /** column name */
  AuthorId = 'authorId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  NewGrade = 'newGrade',
  /** column name */
  Notes = 'notes',
  /** column name */
  OldGrade = 'oldGrade',
  /** column name */
  ParticipantId = 'participantId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** unique or primary key constraints on table "course_certificate" */
export enum Course_Certificate_Constraint {
  /** unique or primary key constraint */
  CourseCertificateNumberKey = 'course_certificate_number_key',
  /** unique or primary key constraint */
  CourseCertificatePkey = 'course_certificate_pkey'
}

/** input type for incrementing numeric columns in table "course_certificate" */
export type Course_Certificate_Inc_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_certificate" */
export type Course_Certificate_Insert_Input = {
  certificationDate?: InputMaybe<Scalars['date']>;
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  courseId?: InputMaybe<Scalars['Int']>;
  courseLevel?: InputMaybe<Scalars['String']>;
  courseName?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expiryDate?: InputMaybe<Scalars['date']>;
  id?: InputMaybe<Scalars['uuid']>;
  number?: InputMaybe<Scalars['String']>;
  participant?: InputMaybe<Course_Participant_Obj_Rel_Insert_Input>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profileId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Course_Certificate_Max_Fields = {
  __typename?: 'course_certificate_max_fields';
  certificationDate?: Maybe<Scalars['date']>;
  courseId?: Maybe<Scalars['Int']>;
  courseLevel?: Maybe<Scalars['String']>;
  courseName?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  expiryDate?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  number?: Maybe<Scalars['String']>;
  profileId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "course_certificate" */
export type Course_Certificate_Max_Order_By = {
  certificationDate?: InputMaybe<Order_By>;
  courseId?: InputMaybe<Order_By>;
  courseLevel?: InputMaybe<Order_By>;
  courseName?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  expiryDate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  number?: InputMaybe<Order_By>;
  profileId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Course_Certificate_Min_Fields = {
  __typename?: 'course_certificate_min_fields';
  certificationDate?: Maybe<Scalars['date']>;
  courseId?: Maybe<Scalars['Int']>;
  courseLevel?: Maybe<Scalars['String']>;
  courseName?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  expiryDate?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  number?: Maybe<Scalars['String']>;
  profileId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "course_certificate" */
export type Course_Certificate_Min_Order_By = {
  certificationDate?: InputMaybe<Order_By>;
  courseId?: InputMaybe<Order_By>;
  courseLevel?: InputMaybe<Order_By>;
  courseName?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  expiryDate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  number?: InputMaybe<Order_By>;
  profileId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "course_certificate" */
export type Course_Certificate_Mutation_Response = {
  __typename?: 'course_certificate_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Certificate>;
};

/** input type for inserting object relation for remote table "course_certificate" */
export type Course_Certificate_Obj_Rel_Insert_Input = {
  data: Course_Certificate_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Certificate_On_Conflict>;
};

/** on_conflict condition type for table "course_certificate" */
export type Course_Certificate_On_Conflict = {
  constraint: Course_Certificate_Constraint;
  update_columns?: Array<Course_Certificate_Update_Column>;
  where?: InputMaybe<Course_Certificate_Bool_Exp>;
};

/** Ordering options when selecting data from "course_certificate". */
export type Course_Certificate_Order_By = {
  certificationDate?: InputMaybe<Order_By>;
  course?: InputMaybe<Course_Order_By>;
  courseId?: InputMaybe<Order_By>;
  courseLevel?: InputMaybe<Order_By>;
  courseName?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  expiryDate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  number?: InputMaybe<Order_By>;
  participant?: InputMaybe<Course_Participant_Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profileId?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_certificate */
export type Course_Certificate_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_certificate" */
export enum Course_Certificate_Select_Column {
  /** column name */
  CertificationDate = 'certificationDate',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CourseLevel = 'courseLevel',
  /** column name */
  CourseName = 'courseName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpiryDate = 'expiryDate',
  /** column name */
  Id = 'id',
  /** column name */
  Number = 'number',
  /** column name */
  ProfileId = 'profileId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "course_certificate" */
export type Course_Certificate_Set_Input = {
  certificationDate?: InputMaybe<Scalars['date']>;
  courseId?: InputMaybe<Scalars['Int']>;
  courseLevel?: InputMaybe<Scalars['String']>;
  courseName?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  expiryDate?: InputMaybe<Scalars['date']>;
  id?: InputMaybe<Scalars['uuid']>;
  number?: InputMaybe<Scalars['String']>;
  profileId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Course_Certificate_Stddev_Fields = {
  __typename?: 'course_certificate_stddev_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "course_certificate" */
export type Course_Certificate_Stddev_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Course_Certificate_Stddev_Pop_Fields = {
  __typename?: 'course_certificate_stddev_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "course_certificate" */
export type Course_Certificate_Stddev_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Course_Certificate_Stddev_Samp_Fields = {
  __typename?: 'course_certificate_stddev_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "course_certificate" */
export type Course_Certificate_Stddev_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Course_Certificate_Sum_Fields = {
  __typename?: 'course_certificate_sum_fields';
  courseId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "course_certificate" */
export type Course_Certificate_Sum_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** update columns of table "course_certificate" */
export enum Course_Certificate_Update_Column {
  /** column name */
  CertificationDate = 'certificationDate',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CourseLevel = 'courseLevel',
  /** column name */
  CourseName = 'courseName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ExpiryDate = 'expiryDate',
  /** column name */
  Id = 'id',
  /** column name */
  Number = 'number',
  /** column name */
  ProfileId = 'profileId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Course_Certificate_Var_Pop_Fields = {
  __typename?: 'course_certificate_var_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "course_certificate" */
export type Course_Certificate_Var_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Course_Certificate_Var_Samp_Fields = {
  __typename?: 'course_certificate_var_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "course_certificate" */
export type Course_Certificate_Var_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Course_Certificate_Variance_Fields = {
  __typename?: 'course_certificate_variance_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "course_certificate" */
export type Course_Certificate_Variance_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** unique or primary key constraints on table "course" */
export enum Course_Constraint {
  /** unique or primary key constraint */
  CourseAutoincrementalIdKey = 'course_autoincremental_id_key',
  /** unique or primary key constraint */
  CoursePkey = 'course_pkey'
}

/** columns and relationships of "course_delivery_type" */
export type Course_Delivery_Type = {
  __typename?: 'course_delivery_type';
  name: Scalars['String'];
};

/** aggregated selection of "course_delivery_type" */
export type Course_Delivery_Type_Aggregate = {
  __typename?: 'course_delivery_type_aggregate';
  aggregate?: Maybe<Course_Delivery_Type_Aggregate_Fields>;
  nodes: Array<Course_Delivery_Type>;
};

/** aggregate fields of "course_delivery_type" */
export type Course_Delivery_Type_Aggregate_Fields = {
  __typename?: 'course_delivery_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Delivery_Type_Max_Fields>;
  min?: Maybe<Course_Delivery_Type_Min_Fields>;
};


/** aggregate fields of "course_delivery_type" */
export type Course_Delivery_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Delivery_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "course_delivery_type". All fields are combined with a logical 'AND'. */
export type Course_Delivery_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Delivery_Type_Bool_Exp>>;
  _not?: InputMaybe<Course_Delivery_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Delivery_Type_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_delivery_type" */
export enum Course_Delivery_Type_Constraint {
  /** unique or primary key constraint */
  CourseDeliveryTypePkey = 'course_delivery_type_pkey'
}

export enum Course_Delivery_Type_Enum {
  F2F = 'F2F',
  Mixed = 'MIXED',
  Virtual = 'VIRTUAL'
}

/** Boolean expression to compare columns of type "course_delivery_type_enum". All fields are combined with logical 'AND'. */
export type Course_Delivery_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Course_Delivery_Type_Enum>;
  _in?: InputMaybe<Array<Course_Delivery_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Course_Delivery_Type_Enum>;
  _nin?: InputMaybe<Array<Course_Delivery_Type_Enum>>;
};

/** input type for inserting data into table "course_delivery_type" */
export type Course_Delivery_Type_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Delivery_Type_Max_Fields = {
  __typename?: 'course_delivery_type_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Delivery_Type_Min_Fields = {
  __typename?: 'course_delivery_type_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_delivery_type" */
export type Course_Delivery_Type_Mutation_Response = {
  __typename?: 'course_delivery_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Delivery_Type>;
};

/** on_conflict condition type for table "course_delivery_type" */
export type Course_Delivery_Type_On_Conflict = {
  constraint: Course_Delivery_Type_Constraint;
  update_columns?: Array<Course_Delivery_Type_Update_Column>;
  where?: InputMaybe<Course_Delivery_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "course_delivery_type". */
export type Course_Delivery_Type_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_delivery_type */
export type Course_Delivery_Type_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "course_delivery_type" */
export enum Course_Delivery_Type_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "course_delivery_type" */
export type Course_Delivery_Type_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "course_delivery_type" */
export enum Course_Delivery_Type_Update_Column {
  /** column name */
  Name = 'name'
}

/** Stores course drafts */
export type Course_Draft = {
  __typename?: 'course_draft';
  courseType: Scalars['String'];
  created_at: Scalars['timestamp'];
  data?: Maybe<Scalars['jsonb']>;
  id: Scalars['uuid'];
  profileId: Scalars['uuid'];
  updated_at: Scalars['timestamp'];
};


/** Stores course drafts */
export type Course_DraftDataArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "course_draft" */
export type Course_Draft_Aggregate = {
  __typename?: 'course_draft_aggregate';
  aggregate?: Maybe<Course_Draft_Aggregate_Fields>;
  nodes: Array<Course_Draft>;
};

/** aggregate fields of "course_draft" */
export type Course_Draft_Aggregate_Fields = {
  __typename?: 'course_draft_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Draft_Max_Fields>;
  min?: Maybe<Course_Draft_Min_Fields>;
};


/** aggregate fields of "course_draft" */
export type Course_Draft_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Draft_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Course_Draft_Append_Input = {
  data?: InputMaybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "course_draft". All fields are combined with a logical 'AND'. */
export type Course_Draft_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Draft_Bool_Exp>>;
  _not?: InputMaybe<Course_Draft_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Draft_Bool_Exp>>;
  courseType?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  data?: InputMaybe<Jsonb_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  profileId?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_draft" */
export enum Course_Draft_Constraint {
  /** unique or primary key constraint */
  CourseDraftPkey = 'course_draft_pkey',
  /** unique or primary key constraint */
  CourseDraftProfileIdCourseTypeKey = 'course_draft_profile_id_course_type_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Course_Draft_Delete_At_Path_Input = {
  data?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Course_Draft_Delete_Elem_Input = {
  data?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Course_Draft_Delete_Key_Input = {
  data?: InputMaybe<Scalars['String']>;
};

/** input type for inserting data into table "course_draft" */
export type Course_Draft_Insert_Input = {
  courseType?: InputMaybe<Scalars['String']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  data?: InputMaybe<Scalars['jsonb']>;
  id?: InputMaybe<Scalars['uuid']>;
  profileId?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Course_Draft_Max_Fields = {
  __typename?: 'course_draft_max_fields';
  courseType?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  profileId?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate min on columns */
export type Course_Draft_Min_Fields = {
  __typename?: 'course_draft_min_fields';
  courseType?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  profileId?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** response of any mutation on the table "course_draft" */
export type Course_Draft_Mutation_Response = {
  __typename?: 'course_draft_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Draft>;
};

/** on_conflict condition type for table "course_draft" */
export type Course_Draft_On_Conflict = {
  constraint: Course_Draft_Constraint;
  update_columns?: Array<Course_Draft_Update_Column>;
  where?: InputMaybe<Course_Draft_Bool_Exp>;
};

/** Ordering options when selecting data from "course_draft". */
export type Course_Draft_Order_By = {
  courseType?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  data?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profileId?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_draft */
export type Course_Draft_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Course_Draft_Prepend_Input = {
  data?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "course_draft" */
export enum Course_Draft_Select_Column {
  /** column name */
  CourseType = 'courseType',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profileId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "course_draft" */
export type Course_Draft_Set_Input = {
  courseType?: InputMaybe<Scalars['String']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  data?: InputMaybe<Scalars['jsonb']>;
  id?: InputMaybe<Scalars['uuid']>;
  profileId?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** update columns of table "course_draft" */
export enum Course_Draft_Update_Column {
  /** column name */
  CourseType = 'courseType',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profileId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** Stores scheduled jobs ids for courses */
export type Course_End_Jobs = {
  __typename?: 'course_end_jobs';
  course_id: Scalars['Int'];
  id: Scalars['uuid'];
  job_id: Scalars['uuid'];
};

/** aggregated selection of "course_end_jobs" */
export type Course_End_Jobs_Aggregate = {
  __typename?: 'course_end_jobs_aggregate';
  aggregate?: Maybe<Course_End_Jobs_Aggregate_Fields>;
  nodes: Array<Course_End_Jobs>;
};

/** aggregate fields of "course_end_jobs" */
export type Course_End_Jobs_Aggregate_Fields = {
  __typename?: 'course_end_jobs_aggregate_fields';
  avg?: Maybe<Course_End_Jobs_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_End_Jobs_Max_Fields>;
  min?: Maybe<Course_End_Jobs_Min_Fields>;
  stddev?: Maybe<Course_End_Jobs_Stddev_Fields>;
  stddev_pop?: Maybe<Course_End_Jobs_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_End_Jobs_Stddev_Samp_Fields>;
  sum?: Maybe<Course_End_Jobs_Sum_Fields>;
  var_pop?: Maybe<Course_End_Jobs_Var_Pop_Fields>;
  var_samp?: Maybe<Course_End_Jobs_Var_Samp_Fields>;
  variance?: Maybe<Course_End_Jobs_Variance_Fields>;
};


/** aggregate fields of "course_end_jobs" */
export type Course_End_Jobs_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_End_Jobs_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Course_End_Jobs_Avg_Fields = {
  __typename?: 'course_end_jobs_avg_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "course_end_jobs". All fields are combined with a logical 'AND'. */
export type Course_End_Jobs_Bool_Exp = {
  _and?: InputMaybe<Array<Course_End_Jobs_Bool_Exp>>;
  _not?: InputMaybe<Course_End_Jobs_Bool_Exp>;
  _or?: InputMaybe<Array<Course_End_Jobs_Bool_Exp>>;
  course_id?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  job_id?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_end_jobs" */
export enum Course_End_Jobs_Constraint {
  /** unique or primary key constraint */
  CourseEndJobsCourseIdJobIdKey = 'course_end_jobs_course_id_job_id_key',
  /** unique or primary key constraint */
  CourseEndJobsPkey = 'course_end_jobs_pkey'
}

/** input type for incrementing numeric columns in table "course_end_jobs" */
export type Course_End_Jobs_Inc_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_end_jobs" */
export type Course_End_Jobs_Insert_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  job_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Course_End_Jobs_Max_Fields = {
  __typename?: 'course_end_jobs_max_fields';
  course_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  job_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Course_End_Jobs_Min_Fields = {
  __typename?: 'course_end_jobs_min_fields';
  course_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  job_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "course_end_jobs" */
export type Course_End_Jobs_Mutation_Response = {
  __typename?: 'course_end_jobs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_End_Jobs>;
};

/** on_conflict condition type for table "course_end_jobs" */
export type Course_End_Jobs_On_Conflict = {
  constraint: Course_End_Jobs_Constraint;
  update_columns?: Array<Course_End_Jobs_Update_Column>;
  where?: InputMaybe<Course_End_Jobs_Bool_Exp>;
};

/** Ordering options when selecting data from "course_end_jobs". */
export type Course_End_Jobs_Order_By = {
  course_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  job_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_end_jobs */
export type Course_End_Jobs_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_end_jobs" */
export enum Course_End_Jobs_Select_Column {
  /** column name */
  CourseId = 'course_id',
  /** column name */
  Id = 'id',
  /** column name */
  JobId = 'job_id'
}

/** input type for updating data in table "course_end_jobs" */
export type Course_End_Jobs_Set_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  job_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Course_End_Jobs_Stddev_Fields = {
  __typename?: 'course_end_jobs_stddev_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Course_End_Jobs_Stddev_Pop_Fields = {
  __typename?: 'course_end_jobs_stddev_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Course_End_Jobs_Stddev_Samp_Fields = {
  __typename?: 'course_end_jobs_stddev_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Course_End_Jobs_Sum_Fields = {
  __typename?: 'course_end_jobs_sum_fields';
  course_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "course_end_jobs" */
export enum Course_End_Jobs_Update_Column {
  /** column name */
  CourseId = 'course_id',
  /** column name */
  Id = 'id',
  /** column name */
  JobId = 'job_id'
}

/** aggregate var_pop on columns */
export type Course_End_Jobs_Var_Pop_Fields = {
  __typename?: 'course_end_jobs_var_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Course_End_Jobs_Var_Samp_Fields = {
  __typename?: 'course_end_jobs_var_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Course_End_Jobs_Variance_Fields = {
  __typename?: 'course_end_jobs_variance_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** Enquiries about open courses */
export type Course_Enquiry = {
  __typename?: 'course_enquiry';
  /** An object relationship */
  course: Course;
  courseId: Scalars['Int'];
  created_at?: Maybe<Scalars['timestamptz']>;
  email: Scalars['String'];
  familyName: Scalars['String'];
  givenName: Scalars['String'];
  id: Scalars['uuid'];
  interest: Scalars['String'];
  message?: Maybe<Scalars['String']>;
  orgName: Scalars['String'];
  phone: Scalars['String'];
  sector: Scalars['String'];
  source?: Maybe<Scalars['String']>;
};

/** aggregated selection of "course_enquiry" */
export type Course_Enquiry_Aggregate = {
  __typename?: 'course_enquiry_aggregate';
  aggregate?: Maybe<Course_Enquiry_Aggregate_Fields>;
  nodes: Array<Course_Enquiry>;
};

/** aggregate fields of "course_enquiry" */
export type Course_Enquiry_Aggregate_Fields = {
  __typename?: 'course_enquiry_aggregate_fields';
  avg?: Maybe<Course_Enquiry_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Enquiry_Max_Fields>;
  min?: Maybe<Course_Enquiry_Min_Fields>;
  stddev?: Maybe<Course_Enquiry_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Enquiry_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Enquiry_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Enquiry_Sum_Fields>;
  var_pop?: Maybe<Course_Enquiry_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Enquiry_Var_Samp_Fields>;
  variance?: Maybe<Course_Enquiry_Variance_Fields>;
};


/** aggregate fields of "course_enquiry" */
export type Course_Enquiry_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Enquiry_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Course_Enquiry_Avg_Fields = {
  __typename?: 'course_enquiry_avg_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "course_enquiry". All fields are combined with a logical 'AND'. */
export type Course_Enquiry_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Enquiry_Bool_Exp>>;
  _not?: InputMaybe<Course_Enquiry_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Enquiry_Bool_Exp>>;
  course?: InputMaybe<Course_Bool_Exp>;
  courseId?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  familyName?: InputMaybe<String_Comparison_Exp>;
  givenName?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  interest?: InputMaybe<String_Comparison_Exp>;
  message?: InputMaybe<String_Comparison_Exp>;
  orgName?: InputMaybe<String_Comparison_Exp>;
  phone?: InputMaybe<String_Comparison_Exp>;
  sector?: InputMaybe<String_Comparison_Exp>;
  source?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_enquiry" */
export enum Course_Enquiry_Constraint {
  /** unique or primary key constraint */
  CourseEnquiryEmailCourseIdKey = 'course_enquiry_email_course_id_key',
  /** unique or primary key constraint */
  CourseEnquiryPkey = 'course_enquiry_pkey'
}

/** input type for incrementing numeric columns in table "course_enquiry" */
export type Course_Enquiry_Inc_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_enquiry" */
export type Course_Enquiry_Insert_Input = {
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  courseId?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  familyName?: InputMaybe<Scalars['String']>;
  givenName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  interest?: InputMaybe<Scalars['String']>;
  message?: InputMaybe<Scalars['String']>;
  orgName?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  sector?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Enquiry_Max_Fields = {
  __typename?: 'course_enquiry_max_fields';
  courseId?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  givenName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  interest?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  orgName?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  sector?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Enquiry_Min_Fields = {
  __typename?: 'course_enquiry_min_fields';
  courseId?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  givenName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  interest?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  orgName?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  sector?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_enquiry" */
export type Course_Enquiry_Mutation_Response = {
  __typename?: 'course_enquiry_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Enquiry>;
};

/** on_conflict condition type for table "course_enquiry" */
export type Course_Enquiry_On_Conflict = {
  constraint: Course_Enquiry_Constraint;
  update_columns?: Array<Course_Enquiry_Update_Column>;
  where?: InputMaybe<Course_Enquiry_Bool_Exp>;
};

/** Ordering options when selecting data from "course_enquiry". */
export type Course_Enquiry_Order_By = {
  course?: InputMaybe<Course_Order_By>;
  courseId?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  familyName?: InputMaybe<Order_By>;
  givenName?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  interest?: InputMaybe<Order_By>;
  message?: InputMaybe<Order_By>;
  orgName?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
  sector?: InputMaybe<Order_By>;
  source?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_enquiry */
export type Course_Enquiry_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_enquiry" */
export enum Course_Enquiry_Select_Column {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  FamilyName = 'familyName',
  /** column name */
  GivenName = 'givenName',
  /** column name */
  Id = 'id',
  /** column name */
  Interest = 'interest',
  /** column name */
  Message = 'message',
  /** column name */
  OrgName = 'orgName',
  /** column name */
  Phone = 'phone',
  /** column name */
  Sector = 'sector',
  /** column name */
  Source = 'source'
}

/** input type for updating data in table "course_enquiry" */
export type Course_Enquiry_Set_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  familyName?: InputMaybe<Scalars['String']>;
  givenName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  interest?: InputMaybe<Scalars['String']>;
  message?: InputMaybe<Scalars['String']>;
  orgName?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  sector?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Course_Enquiry_Stddev_Fields = {
  __typename?: 'course_enquiry_stddev_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Course_Enquiry_Stddev_Pop_Fields = {
  __typename?: 'course_enquiry_stddev_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Course_Enquiry_Stddev_Samp_Fields = {
  __typename?: 'course_enquiry_stddev_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Course_Enquiry_Sum_Fields = {
  __typename?: 'course_enquiry_sum_fields';
  courseId?: Maybe<Scalars['Int']>;
};

/** update columns of table "course_enquiry" */
export enum Course_Enquiry_Update_Column {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  FamilyName = 'familyName',
  /** column name */
  GivenName = 'givenName',
  /** column name */
  Id = 'id',
  /** column name */
  Interest = 'interest',
  /** column name */
  Message = 'message',
  /** column name */
  OrgName = 'orgName',
  /** column name */
  Phone = 'phone',
  /** column name */
  Sector = 'sector',
  /** column name */
  Source = 'source'
}

/** aggregate var_pop on columns */
export type Course_Enquiry_Var_Pop_Fields = {
  __typename?: 'course_enquiry_var_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Course_Enquiry_Var_Samp_Fields = {
  __typename?: 'course_enquiry_var_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Course_Enquiry_Variance_Fields = {
  __typename?: 'course_enquiry_variance_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "course_evaluation_answers" */
export type Course_Evaluation_Answers = {
  __typename?: 'course_evaluation_answers';
  answer?: Maybe<Scalars['String']>;
  /** An object relationship */
  course: Course;
  courseId: Scalars['Int'];
  id: Scalars['uuid'];
  /** An object relationship */
  participant?: Maybe<Course_Participant>;
  /** An object relationship */
  profile: Profile;
  profileId: Scalars['uuid'];
  /** An object relationship */
  question: Course_Evaluation_Questions;
  questionId: Scalars['uuid'];
};

/** aggregated selection of "course_evaluation_answers" */
export type Course_Evaluation_Answers_Aggregate = {
  __typename?: 'course_evaluation_answers_aggregate';
  aggregate?: Maybe<Course_Evaluation_Answers_Aggregate_Fields>;
  nodes: Array<Course_Evaluation_Answers>;
};

/** aggregate fields of "course_evaluation_answers" */
export type Course_Evaluation_Answers_Aggregate_Fields = {
  __typename?: 'course_evaluation_answers_aggregate_fields';
  avg?: Maybe<Course_Evaluation_Answers_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Evaluation_Answers_Max_Fields>;
  min?: Maybe<Course_Evaluation_Answers_Min_Fields>;
  stddev?: Maybe<Course_Evaluation_Answers_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Evaluation_Answers_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Evaluation_Answers_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Evaluation_Answers_Sum_Fields>;
  var_pop?: Maybe<Course_Evaluation_Answers_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Evaluation_Answers_Var_Samp_Fields>;
  variance?: Maybe<Course_Evaluation_Answers_Variance_Fields>;
};


/** aggregate fields of "course_evaluation_answers" */
export type Course_Evaluation_Answers_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Evaluation_Answers_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Aggregate_Order_By = {
  avg?: InputMaybe<Course_Evaluation_Answers_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Course_Evaluation_Answers_Max_Order_By>;
  min?: InputMaybe<Course_Evaluation_Answers_Min_Order_By>;
  stddev?: InputMaybe<Course_Evaluation_Answers_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Course_Evaluation_Answers_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Course_Evaluation_Answers_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Course_Evaluation_Answers_Sum_Order_By>;
  var_pop?: InputMaybe<Course_Evaluation_Answers_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Course_Evaluation_Answers_Var_Samp_Order_By>;
  variance?: InputMaybe<Course_Evaluation_Answers_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Arr_Rel_Insert_Input = {
  data: Array<Course_Evaluation_Answers_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Evaluation_Answers_On_Conflict>;
};

/** aggregate avg on columns */
export type Course_Evaluation_Answers_Avg_Fields = {
  __typename?: 'course_evaluation_answers_avg_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Avg_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "course_evaluation_answers". All fields are combined with a logical 'AND'. */
export type Course_Evaluation_Answers_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Evaluation_Answers_Bool_Exp>>;
  _not?: InputMaybe<Course_Evaluation_Answers_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Evaluation_Answers_Bool_Exp>>;
  answer?: InputMaybe<String_Comparison_Exp>;
  course?: InputMaybe<Course_Bool_Exp>;
  courseId?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  participant?: InputMaybe<Course_Participant_Bool_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profileId?: InputMaybe<Uuid_Comparison_Exp>;
  question?: InputMaybe<Course_Evaluation_Questions_Bool_Exp>;
  questionId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_evaluation_answers" */
export enum Course_Evaluation_Answers_Constraint {
  /** unique or primary key constraint */
  CourseEvaluationAnswersPkey = 'course_evaluation_answers_pkey'
}

/** input type for incrementing numeric columns in table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Inc_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Insert_Input = {
  answer?: InputMaybe<Scalars['String']>;
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  courseId?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  participant?: InputMaybe<Course_Participant_Obj_Rel_Insert_Input>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profileId?: InputMaybe<Scalars['uuid']>;
  question?: InputMaybe<Course_Evaluation_Questions_Obj_Rel_Insert_Input>;
  questionId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Course_Evaluation_Answers_Max_Fields = {
  __typename?: 'course_evaluation_answers_max_fields';
  answer?: Maybe<Scalars['String']>;
  courseId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  profileId?: Maybe<Scalars['uuid']>;
  questionId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Max_Order_By = {
  answer?: InputMaybe<Order_By>;
  courseId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profileId?: InputMaybe<Order_By>;
  questionId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Course_Evaluation_Answers_Min_Fields = {
  __typename?: 'course_evaluation_answers_min_fields';
  answer?: Maybe<Scalars['String']>;
  courseId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  profileId?: Maybe<Scalars['uuid']>;
  questionId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Min_Order_By = {
  answer?: InputMaybe<Order_By>;
  courseId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profileId?: InputMaybe<Order_By>;
  questionId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Mutation_Response = {
  __typename?: 'course_evaluation_answers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Evaluation_Answers>;
};

/** on_conflict condition type for table "course_evaluation_answers" */
export type Course_Evaluation_Answers_On_Conflict = {
  constraint: Course_Evaluation_Answers_Constraint;
  update_columns?: Array<Course_Evaluation_Answers_Update_Column>;
  where?: InputMaybe<Course_Evaluation_Answers_Bool_Exp>;
};

/** Ordering options when selecting data from "course_evaluation_answers". */
export type Course_Evaluation_Answers_Order_By = {
  answer?: InputMaybe<Order_By>;
  course?: InputMaybe<Course_Order_By>;
  courseId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  participant?: InputMaybe<Course_Participant_Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profileId?: InputMaybe<Order_By>;
  question?: InputMaybe<Course_Evaluation_Questions_Order_By>;
  questionId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_evaluation_answers */
export type Course_Evaluation_Answers_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_evaluation_answers" */
export enum Course_Evaluation_Answers_Select_Column {
  /** column name */
  Answer = 'answer',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profileId',
  /** column name */
  QuestionId = 'questionId'
}

/** input type for updating data in table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Set_Input = {
  answer?: InputMaybe<Scalars['String']>;
  courseId?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  profileId?: InputMaybe<Scalars['uuid']>;
  questionId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Course_Evaluation_Answers_Stddev_Fields = {
  __typename?: 'course_evaluation_answers_stddev_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Stddev_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Course_Evaluation_Answers_Stddev_Pop_Fields = {
  __typename?: 'course_evaluation_answers_stddev_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Stddev_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Course_Evaluation_Answers_Stddev_Samp_Fields = {
  __typename?: 'course_evaluation_answers_stddev_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Stddev_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Course_Evaluation_Answers_Sum_Fields = {
  __typename?: 'course_evaluation_answers_sum_fields';
  courseId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Sum_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** update columns of table "course_evaluation_answers" */
export enum Course_Evaluation_Answers_Update_Column {
  /** column name */
  Answer = 'answer',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profileId',
  /** column name */
  QuestionId = 'questionId'
}

/** aggregate var_pop on columns */
export type Course_Evaluation_Answers_Var_Pop_Fields = {
  __typename?: 'course_evaluation_answers_var_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Var_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Course_Evaluation_Answers_Var_Samp_Fields = {
  __typename?: 'course_evaluation_answers_var_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Var_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Course_Evaluation_Answers_Variance_Fields = {
  __typename?: 'course_evaluation_answers_variance_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "course_evaluation_answers" */
export type Course_Evaluation_Answers_Variance_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** columns and relationships of "course_evaluation_question_group" */
export type Course_Evaluation_Question_Group = {
  __typename?: 'course_evaluation_question_group';
  name: Scalars['String'];
};

/** aggregated selection of "course_evaluation_question_group" */
export type Course_Evaluation_Question_Group_Aggregate = {
  __typename?: 'course_evaluation_question_group_aggregate';
  aggregate?: Maybe<Course_Evaluation_Question_Group_Aggregate_Fields>;
  nodes: Array<Course_Evaluation_Question_Group>;
};

/** aggregate fields of "course_evaluation_question_group" */
export type Course_Evaluation_Question_Group_Aggregate_Fields = {
  __typename?: 'course_evaluation_question_group_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Evaluation_Question_Group_Max_Fields>;
  min?: Maybe<Course_Evaluation_Question_Group_Min_Fields>;
};


/** aggregate fields of "course_evaluation_question_group" */
export type Course_Evaluation_Question_Group_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Evaluation_Question_Group_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "course_evaluation_question_group". All fields are combined with a logical 'AND'. */
export type Course_Evaluation_Question_Group_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Evaluation_Question_Group_Bool_Exp>>;
  _not?: InputMaybe<Course_Evaluation_Question_Group_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Evaluation_Question_Group_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_evaluation_question_group" */
export enum Course_Evaluation_Question_Group_Constraint {
  /** unique or primary key constraint */
  CourseEvaluationQuestionGroupPkey = 'course_evaluation_question_group_pkey'
}

export enum Course_Evaluation_Question_Group_Enum {
  MaterialsAndVenue = 'MATERIALS_AND_VENUE',
  TrainerStandards = 'TRAINER_STANDARDS',
  TrainingRating = 'TRAINING_RATING',
  TrainingRelevance = 'TRAINING_RELEVANCE',
  Ungrouped = 'UNGROUPED'
}

/** Boolean expression to compare columns of type "course_evaluation_question_group_enum". All fields are combined with logical 'AND'. */
export type Course_Evaluation_Question_Group_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Course_Evaluation_Question_Group_Enum>;
  _in?: InputMaybe<Array<Course_Evaluation_Question_Group_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Course_Evaluation_Question_Group_Enum>;
  _nin?: InputMaybe<Array<Course_Evaluation_Question_Group_Enum>>;
};

/** input type for inserting data into table "course_evaluation_question_group" */
export type Course_Evaluation_Question_Group_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Evaluation_Question_Group_Max_Fields = {
  __typename?: 'course_evaluation_question_group_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Evaluation_Question_Group_Min_Fields = {
  __typename?: 'course_evaluation_question_group_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_evaluation_question_group" */
export type Course_Evaluation_Question_Group_Mutation_Response = {
  __typename?: 'course_evaluation_question_group_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Evaluation_Question_Group>;
};

/** on_conflict condition type for table "course_evaluation_question_group" */
export type Course_Evaluation_Question_Group_On_Conflict = {
  constraint: Course_Evaluation_Question_Group_Constraint;
  update_columns?: Array<Course_Evaluation_Question_Group_Update_Column>;
  where?: InputMaybe<Course_Evaluation_Question_Group_Bool_Exp>;
};

/** Ordering options when selecting data from "course_evaluation_question_group". */
export type Course_Evaluation_Question_Group_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_evaluation_question_group */
export type Course_Evaluation_Question_Group_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "course_evaluation_question_group" */
export enum Course_Evaluation_Question_Group_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "course_evaluation_question_group" */
export type Course_Evaluation_Question_Group_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "course_evaluation_question_group" */
export enum Course_Evaluation_Question_Group_Update_Column {
  /** column name */
  Name = 'name'
}

/** columns and relationships of "course_evaluation_question_type" */
export type Course_Evaluation_Question_Type = {
  __typename?: 'course_evaluation_question_type';
  name: Scalars['String'];
};

/** aggregated selection of "course_evaluation_question_type" */
export type Course_Evaluation_Question_Type_Aggregate = {
  __typename?: 'course_evaluation_question_type_aggregate';
  aggregate?: Maybe<Course_Evaluation_Question_Type_Aggregate_Fields>;
  nodes: Array<Course_Evaluation_Question_Type>;
};

/** aggregate fields of "course_evaluation_question_type" */
export type Course_Evaluation_Question_Type_Aggregate_Fields = {
  __typename?: 'course_evaluation_question_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Evaluation_Question_Type_Max_Fields>;
  min?: Maybe<Course_Evaluation_Question_Type_Min_Fields>;
};


/** aggregate fields of "course_evaluation_question_type" */
export type Course_Evaluation_Question_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Evaluation_Question_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "course_evaluation_question_type". All fields are combined with a logical 'AND'. */
export type Course_Evaluation_Question_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Evaluation_Question_Type_Bool_Exp>>;
  _not?: InputMaybe<Course_Evaluation_Question_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Evaluation_Question_Type_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_evaluation_question_type" */
export enum Course_Evaluation_Question_Type_Constraint {
  /** unique or primary key constraint */
  CourseEvaluationQuestionTypePkey = 'course_evaluation_question_type_pkey'
}

export enum Course_Evaluation_Question_Type_Enum {
  Boolean = 'BOOLEAN',
  BooleanReasonN = 'BOOLEAN_REASON_N',
  BooleanReasonY = 'BOOLEAN_REASON_Y',
  Rating = 'RATING',
  Text = 'TEXT'
}

/** Boolean expression to compare columns of type "course_evaluation_question_type_enum". All fields are combined with logical 'AND'. */
export type Course_Evaluation_Question_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Course_Evaluation_Question_Type_Enum>;
  _in?: InputMaybe<Array<Course_Evaluation_Question_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Course_Evaluation_Question_Type_Enum>;
  _nin?: InputMaybe<Array<Course_Evaluation_Question_Type_Enum>>;
};

/** input type for inserting data into table "course_evaluation_question_type" */
export type Course_Evaluation_Question_Type_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Evaluation_Question_Type_Max_Fields = {
  __typename?: 'course_evaluation_question_type_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Evaluation_Question_Type_Min_Fields = {
  __typename?: 'course_evaluation_question_type_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_evaluation_question_type" */
export type Course_Evaluation_Question_Type_Mutation_Response = {
  __typename?: 'course_evaluation_question_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Evaluation_Question_Type>;
};

/** on_conflict condition type for table "course_evaluation_question_type" */
export type Course_Evaluation_Question_Type_On_Conflict = {
  constraint: Course_Evaluation_Question_Type_Constraint;
  update_columns?: Array<Course_Evaluation_Question_Type_Update_Column>;
  where?: InputMaybe<Course_Evaluation_Question_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "course_evaluation_question_type". */
export type Course_Evaluation_Question_Type_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_evaluation_question_type */
export type Course_Evaluation_Question_Type_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "course_evaluation_question_type" */
export enum Course_Evaluation_Question_Type_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "course_evaluation_question_type" */
export type Course_Evaluation_Question_Type_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "course_evaluation_question_type" */
export enum Course_Evaluation_Question_Type_Update_Column {
  /** column name */
  Name = 'name'
}

/** Table for storing text and references of course evaluation questions */
export type Course_Evaluation_Questions = {
  __typename?: 'course_evaluation_questions';
  displayOrder: Scalars['Int'];
  group?: Maybe<Course_Evaluation_Question_Group_Enum>;
  id: Scalars['uuid'];
  question: Scalars['String'];
  questionKey?: Maybe<Scalars['String']>;
  required: Scalars['Boolean'];
  type?: Maybe<Course_Evaluation_Question_Type_Enum>;
};

/** aggregated selection of "course_evaluation_questions" */
export type Course_Evaluation_Questions_Aggregate = {
  __typename?: 'course_evaluation_questions_aggregate';
  aggregate?: Maybe<Course_Evaluation_Questions_Aggregate_Fields>;
  nodes: Array<Course_Evaluation_Questions>;
};

/** aggregate fields of "course_evaluation_questions" */
export type Course_Evaluation_Questions_Aggregate_Fields = {
  __typename?: 'course_evaluation_questions_aggregate_fields';
  avg?: Maybe<Course_Evaluation_Questions_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Evaluation_Questions_Max_Fields>;
  min?: Maybe<Course_Evaluation_Questions_Min_Fields>;
  stddev?: Maybe<Course_Evaluation_Questions_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Evaluation_Questions_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Evaluation_Questions_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Evaluation_Questions_Sum_Fields>;
  var_pop?: Maybe<Course_Evaluation_Questions_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Evaluation_Questions_Var_Samp_Fields>;
  variance?: Maybe<Course_Evaluation_Questions_Variance_Fields>;
};


/** aggregate fields of "course_evaluation_questions" */
export type Course_Evaluation_Questions_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Evaluation_Questions_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Course_Evaluation_Questions_Avg_Fields = {
  __typename?: 'course_evaluation_questions_avg_fields';
  displayOrder?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "course_evaluation_questions". All fields are combined with a logical 'AND'. */
export type Course_Evaluation_Questions_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Evaluation_Questions_Bool_Exp>>;
  _not?: InputMaybe<Course_Evaluation_Questions_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Evaluation_Questions_Bool_Exp>>;
  displayOrder?: InputMaybe<Int_Comparison_Exp>;
  group?: InputMaybe<Course_Evaluation_Question_Group_Enum_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  question?: InputMaybe<String_Comparison_Exp>;
  questionKey?: InputMaybe<String_Comparison_Exp>;
  required?: InputMaybe<Boolean_Comparison_Exp>;
  type?: InputMaybe<Course_Evaluation_Question_Type_Enum_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_evaluation_questions" */
export enum Course_Evaluation_Questions_Constraint {
  /** unique or primary key constraint */
  CourseEvaluationQuestionsPkey = 'course_evaluation_questions_pkey',
  /** unique or primary key constraint */
  CourseEvaluationQuestionsQuestionKeyKey = 'course_evaluation_questions_question_key_key'
}

/** input type for incrementing numeric columns in table "course_evaluation_questions" */
export type Course_Evaluation_Questions_Inc_Input = {
  displayOrder?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_evaluation_questions" */
export type Course_Evaluation_Questions_Insert_Input = {
  displayOrder?: InputMaybe<Scalars['Int']>;
  group?: InputMaybe<Course_Evaluation_Question_Group_Enum>;
  id?: InputMaybe<Scalars['uuid']>;
  question?: InputMaybe<Scalars['String']>;
  questionKey?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  type?: InputMaybe<Course_Evaluation_Question_Type_Enum>;
};

/** aggregate max on columns */
export type Course_Evaluation_Questions_Max_Fields = {
  __typename?: 'course_evaluation_questions_max_fields';
  displayOrder?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  question?: Maybe<Scalars['String']>;
  questionKey?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Evaluation_Questions_Min_Fields = {
  __typename?: 'course_evaluation_questions_min_fields';
  displayOrder?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  question?: Maybe<Scalars['String']>;
  questionKey?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_evaluation_questions" */
export type Course_Evaluation_Questions_Mutation_Response = {
  __typename?: 'course_evaluation_questions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Evaluation_Questions>;
};

/** input type for inserting object relation for remote table "course_evaluation_questions" */
export type Course_Evaluation_Questions_Obj_Rel_Insert_Input = {
  data: Course_Evaluation_Questions_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Evaluation_Questions_On_Conflict>;
};

/** on_conflict condition type for table "course_evaluation_questions" */
export type Course_Evaluation_Questions_On_Conflict = {
  constraint: Course_Evaluation_Questions_Constraint;
  update_columns?: Array<Course_Evaluation_Questions_Update_Column>;
  where?: InputMaybe<Course_Evaluation_Questions_Bool_Exp>;
};

/** Ordering options when selecting data from "course_evaluation_questions". */
export type Course_Evaluation_Questions_Order_By = {
  displayOrder?: InputMaybe<Order_By>;
  group?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  question?: InputMaybe<Order_By>;
  questionKey?: InputMaybe<Order_By>;
  required?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_evaluation_questions */
export type Course_Evaluation_Questions_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_evaluation_questions" */
export enum Course_Evaluation_Questions_Select_Column {
  /** column name */
  DisplayOrder = 'displayOrder',
  /** column name */
  Group = 'group',
  /** column name */
  Id = 'id',
  /** column name */
  Question = 'question',
  /** column name */
  QuestionKey = 'questionKey',
  /** column name */
  Required = 'required',
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "course_evaluation_questions" */
export type Course_Evaluation_Questions_Set_Input = {
  displayOrder?: InputMaybe<Scalars['Int']>;
  group?: InputMaybe<Course_Evaluation_Question_Group_Enum>;
  id?: InputMaybe<Scalars['uuid']>;
  question?: InputMaybe<Scalars['String']>;
  questionKey?: InputMaybe<Scalars['String']>;
  required?: InputMaybe<Scalars['Boolean']>;
  type?: InputMaybe<Course_Evaluation_Question_Type_Enum>;
};

/** aggregate stddev on columns */
export type Course_Evaluation_Questions_Stddev_Fields = {
  __typename?: 'course_evaluation_questions_stddev_fields';
  displayOrder?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Course_Evaluation_Questions_Stddev_Pop_Fields = {
  __typename?: 'course_evaluation_questions_stddev_pop_fields';
  displayOrder?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Course_Evaluation_Questions_Stddev_Samp_Fields = {
  __typename?: 'course_evaluation_questions_stddev_samp_fields';
  displayOrder?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Course_Evaluation_Questions_Sum_Fields = {
  __typename?: 'course_evaluation_questions_sum_fields';
  displayOrder?: Maybe<Scalars['Int']>;
};

/** update columns of table "course_evaluation_questions" */
export enum Course_Evaluation_Questions_Update_Column {
  /** column name */
  DisplayOrder = 'displayOrder',
  /** column name */
  Group = 'group',
  /** column name */
  Id = 'id',
  /** column name */
  Question = 'question',
  /** column name */
  QuestionKey = 'questionKey',
  /** column name */
  Required = 'required',
  /** column name */
  Type = 'type'
}

/** aggregate var_pop on columns */
export type Course_Evaluation_Questions_Var_Pop_Fields = {
  __typename?: 'course_evaluation_questions_var_pop_fields';
  displayOrder?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Course_Evaluation_Questions_Var_Samp_Fields = {
  __typename?: 'course_evaluation_questions_var_samp_fields';
  displayOrder?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Course_Evaluation_Questions_Variance_Fields = {
  __typename?: 'course_evaluation_questions_variance_fields';
  displayOrder?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "course_expenses" */
export type Course_Expenses = {
  __typename?: 'course_expenses';
  /** An object relationship */
  course: Course;
  courseId: Scalars['Int'];
  createdAt: Scalars['timestamptz'];
  data: Scalars['jsonb'];
  id: Scalars['uuid'];
  /** An object relationship */
  trainer: Profile;
  trainerId: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "course_expenses" */
export type Course_ExpensesDataArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "course_expenses" */
export type Course_Expenses_Aggregate = {
  __typename?: 'course_expenses_aggregate';
  aggregate?: Maybe<Course_Expenses_Aggregate_Fields>;
  nodes: Array<Course_Expenses>;
};

/** aggregate fields of "course_expenses" */
export type Course_Expenses_Aggregate_Fields = {
  __typename?: 'course_expenses_aggregate_fields';
  avg?: Maybe<Course_Expenses_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Expenses_Max_Fields>;
  min?: Maybe<Course_Expenses_Min_Fields>;
  stddev?: Maybe<Course_Expenses_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Expenses_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Expenses_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Expenses_Sum_Fields>;
  var_pop?: Maybe<Course_Expenses_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Expenses_Var_Samp_Fields>;
  variance?: Maybe<Course_Expenses_Variance_Fields>;
};


/** aggregate fields of "course_expenses" */
export type Course_Expenses_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Expenses_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "course_expenses" */
export type Course_Expenses_Aggregate_Order_By = {
  avg?: InputMaybe<Course_Expenses_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Course_Expenses_Max_Order_By>;
  min?: InputMaybe<Course_Expenses_Min_Order_By>;
  stddev?: InputMaybe<Course_Expenses_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Course_Expenses_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Course_Expenses_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Course_Expenses_Sum_Order_By>;
  var_pop?: InputMaybe<Course_Expenses_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Course_Expenses_Var_Samp_Order_By>;
  variance?: InputMaybe<Course_Expenses_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Course_Expenses_Append_Input = {
  data?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "course_expenses" */
export type Course_Expenses_Arr_Rel_Insert_Input = {
  data: Array<Course_Expenses_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Expenses_On_Conflict>;
};

/** aggregate avg on columns */
export type Course_Expenses_Avg_Fields = {
  __typename?: 'course_expenses_avg_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "course_expenses" */
export type Course_Expenses_Avg_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "course_expenses". All fields are combined with a logical 'AND'. */
export type Course_Expenses_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Expenses_Bool_Exp>>;
  _not?: InputMaybe<Course_Expenses_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Expenses_Bool_Exp>>;
  course?: InputMaybe<Course_Bool_Exp>;
  courseId?: InputMaybe<Int_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  data?: InputMaybe<Jsonb_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  trainer?: InputMaybe<Profile_Bool_Exp>;
  trainerId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_expenses" */
export enum Course_Expenses_Constraint {
  /** unique or primary key constraint */
  CourseExpensesPkey = 'course_expenses_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Course_Expenses_Delete_At_Path_Input = {
  data?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Course_Expenses_Delete_Elem_Input = {
  data?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Course_Expenses_Delete_Key_Input = {
  data?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "course_expenses" */
export type Course_Expenses_Inc_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_expenses" */
export type Course_Expenses_Insert_Input = {
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  courseId?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  data?: InputMaybe<Scalars['jsonb']>;
  id?: InputMaybe<Scalars['uuid']>;
  trainer?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  trainerId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Course_Expenses_Max_Fields = {
  __typename?: 'course_expenses_max_fields';
  courseId?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  trainerId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "course_expenses" */
export type Course_Expenses_Max_Order_By = {
  courseId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  trainerId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Course_Expenses_Min_Fields = {
  __typename?: 'course_expenses_min_fields';
  courseId?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  trainerId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "course_expenses" */
export type Course_Expenses_Min_Order_By = {
  courseId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  trainerId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "course_expenses" */
export type Course_Expenses_Mutation_Response = {
  __typename?: 'course_expenses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Expenses>;
};

/** on_conflict condition type for table "course_expenses" */
export type Course_Expenses_On_Conflict = {
  constraint: Course_Expenses_Constraint;
  update_columns?: Array<Course_Expenses_Update_Column>;
  where?: InputMaybe<Course_Expenses_Bool_Exp>;
};

/** Ordering options when selecting data from "course_expenses". */
export type Course_Expenses_Order_By = {
  course?: InputMaybe<Course_Order_By>;
  courseId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  data?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  trainer?: InputMaybe<Profile_Order_By>;
  trainerId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_expenses */
export type Course_Expenses_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Course_Expenses_Prepend_Input = {
  data?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "course_expenses" */
export enum Course_Expenses_Select_Column {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  TrainerId = 'trainerId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "course_expenses" */
export type Course_Expenses_Set_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  data?: InputMaybe<Scalars['jsonb']>;
  id?: InputMaybe<Scalars['uuid']>;
  trainerId?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Course_Expenses_Stddev_Fields = {
  __typename?: 'course_expenses_stddev_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "course_expenses" */
export type Course_Expenses_Stddev_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Course_Expenses_Stddev_Pop_Fields = {
  __typename?: 'course_expenses_stddev_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "course_expenses" */
export type Course_Expenses_Stddev_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Course_Expenses_Stddev_Samp_Fields = {
  __typename?: 'course_expenses_stddev_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "course_expenses" */
export type Course_Expenses_Stddev_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Course_Expenses_Sum_Fields = {
  __typename?: 'course_expenses_sum_fields';
  courseId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "course_expenses" */
export type Course_Expenses_Sum_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** update columns of table "course_expenses" */
export enum Course_Expenses_Update_Column {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  TrainerId = 'trainerId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Course_Expenses_Var_Pop_Fields = {
  __typename?: 'course_expenses_var_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "course_expenses" */
export type Course_Expenses_Var_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Course_Expenses_Var_Samp_Fields = {
  __typename?: 'course_expenses_var_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "course_expenses" */
export type Course_Expenses_Var_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Course_Expenses_Variance_Fields = {
  __typename?: 'course_expenses_variance_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "course_expenses" */
export type Course_Expenses_Variance_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** input type for incrementing numeric columns in table "course" */
export type Course_Inc_Input = {
  aolCostOfCourse?: InputMaybe<Scalars['numeric']>;
  cancellationFeePercent?: InputMaybe<Scalars['Int']>;
  freeSpaces?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  max_participants?: InputMaybe<Scalars['Int']>;
  min_participants?: InputMaybe<Scalars['Int']>;
  modulesDuration?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course" */
export type Course_Insert_Input = {
  accountCode?: InputMaybe<Scalars['String']>;
  aolCostOfCourse?: InputMaybe<Scalars['numeric']>;
  aolCountry?: InputMaybe<Scalars['String']>;
  aolRegion?: InputMaybe<Scalars['String']>;
  cancellationFeePercent?: InputMaybe<Scalars['Int']>;
  cancellationReason?: InputMaybe<Scalars['String']>;
  cancellationRequest?: InputMaybe<Course_Cancellation_Request_Obj_Rel_Insert_Input>;
  contactProfile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  contactProfileId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deliveryType?: InputMaybe<Course_Delivery_Type_Enum>;
  description?: InputMaybe<Scalars['String']>;
  evaluation_answers?: InputMaybe<Course_Evaluation_Answers_Arr_Rel_Insert_Input>;
  expenses?: InputMaybe<Course_Expenses_Arr_Rel_Insert_Input>;
  freeSpaces?: InputMaybe<Scalars['Int']>;
  go1Integration?: InputMaybe<Scalars['Boolean']>;
  gradingConfirmed?: InputMaybe<Scalars['Boolean']>;
  gradingStarted?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['Int']>;
  level?: InputMaybe<Course_Level_Enum>;
  max_participants?: InputMaybe<Scalars['Int']>;
  min_participants?: InputMaybe<Scalars['Int']>;
  modules?: InputMaybe<Course_Module_Arr_Rel_Insert_Input>;
  modulesDuration?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  notes?: InputMaybe<Scalars['String']>;
  orders?: InputMaybe<Order_Arr_Rel_Insert_Input>;
  organization?: InputMaybe<Organization_Obj_Rel_Insert_Input>;
  organization_id?: InputMaybe<Scalars['uuid']>;
  participants?: InputMaybe<Course_Participant_Arr_Rel_Insert_Input>;
  promo_codes?: InputMaybe<Course_Promo_Code_Arr_Rel_Insert_Input>;
  reaccreditation?: InputMaybe<Scalars['Boolean']>;
  salesRepresentative?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  salesRepresentativeId?: InputMaybe<Scalars['uuid']>;
  schedule?: InputMaybe<Course_Schedule_Arr_Rel_Insert_Input>;
  status?: InputMaybe<Course_Status_Enum>;
  trainers?: InputMaybe<Course_Trainer_Arr_Rel_Insert_Input>;
  type?: InputMaybe<Course_Type_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  waitlists?: InputMaybe<Waitlist_Arr_Rel_Insert_Input>;
};

/** Enums for status of course registration invites */
export type Course_Invite_Status = {
  __typename?: 'course_invite_status';
  name: Scalars['String'];
};

/** aggregated selection of "course_invite_status" */
export type Course_Invite_Status_Aggregate = {
  __typename?: 'course_invite_status_aggregate';
  aggregate?: Maybe<Course_Invite_Status_Aggregate_Fields>;
  nodes: Array<Course_Invite_Status>;
};

/** aggregate fields of "course_invite_status" */
export type Course_Invite_Status_Aggregate_Fields = {
  __typename?: 'course_invite_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Invite_Status_Max_Fields>;
  min?: Maybe<Course_Invite_Status_Min_Fields>;
};


/** aggregate fields of "course_invite_status" */
export type Course_Invite_Status_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Invite_Status_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "course_invite_status". All fields are combined with a logical 'AND'. */
export type Course_Invite_Status_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Invite_Status_Bool_Exp>>;
  _not?: InputMaybe<Course_Invite_Status_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Invite_Status_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_invite_status" */
export enum Course_Invite_Status_Constraint {
  /** unique or primary key constraint */
  CourseInviteStatusPkey = 'course_invite_status_pkey'
}

export enum Course_Invite_Status_Enum {
  Accepted = 'ACCEPTED',
  Declined = 'DECLINED',
  Pending = 'PENDING'
}

/** Boolean expression to compare columns of type "course_invite_status_enum". All fields are combined with logical 'AND'. */
export type Course_Invite_Status_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Course_Invite_Status_Enum>;
  _in?: InputMaybe<Array<Course_Invite_Status_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Course_Invite_Status_Enum>;
  _nin?: InputMaybe<Array<Course_Invite_Status_Enum>>;
};

/** input type for inserting data into table "course_invite_status" */
export type Course_Invite_Status_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Invite_Status_Max_Fields = {
  __typename?: 'course_invite_status_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Invite_Status_Min_Fields = {
  __typename?: 'course_invite_status_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_invite_status" */
export type Course_Invite_Status_Mutation_Response = {
  __typename?: 'course_invite_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Invite_Status>;
};

/** on_conflict condition type for table "course_invite_status" */
export type Course_Invite_Status_On_Conflict = {
  constraint: Course_Invite_Status_Constraint;
  update_columns?: Array<Course_Invite_Status_Update_Column>;
  where?: InputMaybe<Course_Invite_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "course_invite_status". */
export type Course_Invite_Status_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_invite_status */
export type Course_Invite_Status_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "course_invite_status" */
export enum Course_Invite_Status_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "course_invite_status" */
export type Course_Invite_Status_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "course_invite_status" */
export enum Course_Invite_Status_Update_Column {
  /** column name */
  Name = 'name'
}

/** Represents course registration invitations */
export type Course_Invites = {
  __typename?: 'course_invites';
  /** An object relationship */
  course: Course;
  course_id: Scalars['Int'];
  createdAt: Scalars['timestamptz'];
  email?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  note?: Maybe<Scalars['String']>;
  /** An object relationship */
  participant?: Maybe<Course_Participant>;
  status?: Maybe<Course_Invite_Status_Enum>;
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "course_invites" */
export type Course_Invites_Aggregate = {
  __typename?: 'course_invites_aggregate';
  aggregate?: Maybe<Course_Invites_Aggregate_Fields>;
  nodes: Array<Course_Invites>;
};

/** aggregate fields of "course_invites" */
export type Course_Invites_Aggregate_Fields = {
  __typename?: 'course_invites_aggregate_fields';
  avg?: Maybe<Course_Invites_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Invites_Max_Fields>;
  min?: Maybe<Course_Invites_Min_Fields>;
  stddev?: Maybe<Course_Invites_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Invites_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Invites_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Invites_Sum_Fields>;
  var_pop?: Maybe<Course_Invites_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Invites_Var_Samp_Fields>;
  variance?: Maybe<Course_Invites_Variance_Fields>;
};


/** aggregate fields of "course_invites" */
export type Course_Invites_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Invites_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Course_Invites_Avg_Fields = {
  __typename?: 'course_invites_avg_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "course_invites". All fields are combined with a logical 'AND'. */
export type Course_Invites_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Invites_Bool_Exp>>;
  _not?: InputMaybe<Course_Invites_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Invites_Bool_Exp>>;
  course?: InputMaybe<Course_Bool_Exp>;
  course_id?: InputMaybe<Int_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  note?: InputMaybe<String_Comparison_Exp>;
  participant?: InputMaybe<Course_Participant_Bool_Exp>;
  status?: InputMaybe<Course_Invite_Status_Enum_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_invites" */
export enum Course_Invites_Constraint {
  /** unique or primary key constraint */
  CourseInvitesEmailCourseIdKey = 'course_invites_email_course_id_key',
  /** unique or primary key constraint */
  CourseInvitesPkey = 'course_invites_pkey'
}

/** input type for incrementing numeric columns in table "course_invites" */
export type Course_Invites_Inc_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_invites" */
export type Course_Invites_Insert_Input = {
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  course_id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  note?: InputMaybe<Scalars['String']>;
  participant?: InputMaybe<Course_Participant_Obj_Rel_Insert_Input>;
  status?: InputMaybe<Course_Invite_Status_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Course_Invites_Max_Fields = {
  __typename?: 'course_invites_max_fields';
  course_id?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  note?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Course_Invites_Min_Fields = {
  __typename?: 'course_invites_min_fields';
  course_id?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  note?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "course_invites" */
export type Course_Invites_Mutation_Response = {
  __typename?: 'course_invites_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Invites>;
};

/** input type for inserting object relation for remote table "course_invites" */
export type Course_Invites_Obj_Rel_Insert_Input = {
  data: Course_Invites_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Invites_On_Conflict>;
};

/** on_conflict condition type for table "course_invites" */
export type Course_Invites_On_Conflict = {
  constraint: Course_Invites_Constraint;
  update_columns?: Array<Course_Invites_Update_Column>;
  where?: InputMaybe<Course_Invites_Bool_Exp>;
};

/** Ordering options when selecting data from "course_invites". */
export type Course_Invites_Order_By = {
  course?: InputMaybe<Course_Order_By>;
  course_id?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  note?: InputMaybe<Order_By>;
  participant?: InputMaybe<Course_Participant_Order_By>;
  status?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_invites */
export type Course_Invites_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_invites" */
export enum Course_Invites_Select_Column {
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Note = 'note',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "course_invites" */
export type Course_Invites_Set_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  note?: InputMaybe<Scalars['String']>;
  status?: InputMaybe<Course_Invite_Status_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Course_Invites_Stddev_Fields = {
  __typename?: 'course_invites_stddev_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Course_Invites_Stddev_Pop_Fields = {
  __typename?: 'course_invites_stddev_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Course_Invites_Stddev_Samp_Fields = {
  __typename?: 'course_invites_stddev_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Course_Invites_Sum_Fields = {
  __typename?: 'course_invites_sum_fields';
  course_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "course_invites" */
export enum Course_Invites_Update_Column {
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Note = 'note',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Course_Invites_Var_Pop_Fields = {
  __typename?: 'course_invites_var_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Course_Invites_Var_Samp_Fields = {
  __typename?: 'course_invites_var_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Course_Invites_Variance_Fields = {
  __typename?: 'course_invites_variance_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "course_level" */
export type Course_Level = {
  __typename?: 'course_level';
  name: Scalars['String'];
};

/** aggregated selection of "course_level" */
export type Course_Level_Aggregate = {
  __typename?: 'course_level_aggregate';
  aggregate?: Maybe<Course_Level_Aggregate_Fields>;
  nodes: Array<Course_Level>;
};

/** aggregate fields of "course_level" */
export type Course_Level_Aggregate_Fields = {
  __typename?: 'course_level_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Level_Max_Fields>;
  min?: Maybe<Course_Level_Min_Fields>;
};


/** aggregate fields of "course_level" */
export type Course_Level_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Level_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "course_level". All fields are combined with a logical 'AND'. */
export type Course_Level_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Level_Bool_Exp>>;
  _not?: InputMaybe<Course_Level_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Level_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_level" */
export enum Course_Level_Constraint {
  /** unique or primary key constraint */
  CourseLevelPkey = 'course_level_pkey'
}

export enum Course_Level_Enum {
  Advanced = 'ADVANCED',
  AdvancedTrainer = 'ADVANCED_TRAINER',
  BildAct = 'BILD_ACT',
  BildActTrainer = 'BILD_ACT_TRAINER',
  IntermediateTrainer = 'INTERMEDIATE_TRAINER',
  Level_1 = 'LEVEL_1',
  Level_2 = 'LEVEL_2'
}

/** Boolean expression to compare columns of type "course_level_enum". All fields are combined with logical 'AND'. */
export type Course_Level_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Course_Level_Enum>;
  _in?: InputMaybe<Array<Course_Level_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Course_Level_Enum>;
  _nin?: InputMaybe<Array<Course_Level_Enum>>;
};

/** input type for inserting data into table "course_level" */
export type Course_Level_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Level_Max_Fields = {
  __typename?: 'course_level_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Level_Min_Fields = {
  __typename?: 'course_level_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_level" */
export type Course_Level_Mutation_Response = {
  __typename?: 'course_level_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Level>;
};

/** on_conflict condition type for table "course_level" */
export type Course_Level_On_Conflict = {
  constraint: Course_Level_Constraint;
  update_columns?: Array<Course_Level_Update_Column>;
  where?: InputMaybe<Course_Level_Bool_Exp>;
};

/** Ordering options when selecting data from "course_level". */
export type Course_Level_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_level */
export type Course_Level_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** Course levels with their prefixes (used to generate course codes) */
export type Course_Level_Prefix = {
  __typename?: 'course_level_prefix';
  id: Scalars['uuid'];
  name: Scalars['String'];
  prefix: Scalars['String'];
};

/** aggregated selection of "course_level_prefix" */
export type Course_Level_Prefix_Aggregate = {
  __typename?: 'course_level_prefix_aggregate';
  aggregate?: Maybe<Course_Level_Prefix_Aggregate_Fields>;
  nodes: Array<Course_Level_Prefix>;
};

/** aggregate fields of "course_level_prefix" */
export type Course_Level_Prefix_Aggregate_Fields = {
  __typename?: 'course_level_prefix_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Level_Prefix_Max_Fields>;
  min?: Maybe<Course_Level_Prefix_Min_Fields>;
};


/** aggregate fields of "course_level_prefix" */
export type Course_Level_Prefix_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Level_Prefix_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "course_level_prefix". All fields are combined with a logical 'AND'. */
export type Course_Level_Prefix_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Level_Prefix_Bool_Exp>>;
  _not?: InputMaybe<Course_Level_Prefix_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Level_Prefix_Bool_Exp>>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  prefix?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_level_prefix" */
export enum Course_Level_Prefix_Constraint {
  /** unique or primary key constraint */
  CourseLevelPrefixNameKey = 'course_level_prefix_name_key',
  /** unique or primary key constraint */
  CourseLevelPrefixPkey = 'course_level_prefix_pkey',
  /** unique or primary key constraint */
  CourseLevelPrefixPrefixKey = 'course_level_prefix_prefix_key'
}

/** input type for inserting data into table "course_level_prefix" */
export type Course_Level_Prefix_Insert_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  prefix?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Level_Prefix_Max_Fields = {
  __typename?: 'course_level_prefix_max_fields';
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  prefix?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Level_Prefix_Min_Fields = {
  __typename?: 'course_level_prefix_min_fields';
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  prefix?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_level_prefix" */
export type Course_Level_Prefix_Mutation_Response = {
  __typename?: 'course_level_prefix_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Level_Prefix>;
};

/** on_conflict condition type for table "course_level_prefix" */
export type Course_Level_Prefix_On_Conflict = {
  constraint: Course_Level_Prefix_Constraint;
  update_columns?: Array<Course_Level_Prefix_Update_Column>;
  where?: InputMaybe<Course_Level_Prefix_Bool_Exp>;
};

/** Ordering options when selecting data from "course_level_prefix". */
export type Course_Level_Prefix_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  prefix?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_level_prefix */
export type Course_Level_Prefix_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_level_prefix" */
export enum Course_Level_Prefix_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Prefix = 'prefix'
}

/** input type for updating data in table "course_level_prefix" */
export type Course_Level_Prefix_Set_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  prefix?: InputMaybe<Scalars['String']>;
};

/** update columns of table "course_level_prefix" */
export enum Course_Level_Prefix_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Prefix = 'prefix'
}

/** select columns of table "course_level" */
export enum Course_Level_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "course_level" */
export type Course_Level_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "course_level" */
export enum Course_Level_Update_Column {
  /** column name */
  Name = 'name'
}

/** aggregate max on columns */
export type Course_Max_Fields = {
  __typename?: 'course_max_fields';
  accountCode?: Maybe<Scalars['String']>;
  aolCostOfCourse?: Maybe<Scalars['numeric']>;
  aolCountry?: Maybe<Scalars['String']>;
  aolRegion?: Maybe<Scalars['String']>;
  cancellationFeePercent?: Maybe<Scalars['Int']>;
  cancellationReason?: Maybe<Scalars['String']>;
  contactProfileId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  freeSpaces?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  max_participants?: Maybe<Scalars['Int']>;
  min_participants?: Maybe<Scalars['Int']>;
  modulesDuration?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  organization_id?: Maybe<Scalars['uuid']>;
  salesRepresentativeId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "course" */
export type Course_Max_Order_By = {
  accountCode?: InputMaybe<Order_By>;
  aolCostOfCourse?: InputMaybe<Order_By>;
  aolCountry?: InputMaybe<Order_By>;
  aolRegion?: InputMaybe<Order_By>;
  cancellationFeePercent?: InputMaybe<Order_By>;
  cancellationReason?: InputMaybe<Order_By>;
  contactProfileId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  freeSpaces?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  max_participants?: InputMaybe<Order_By>;
  min_participants?: InputMaybe<Order_By>;
  modulesDuration?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  salesRepresentativeId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Course_Min_Fields = {
  __typename?: 'course_min_fields';
  accountCode?: Maybe<Scalars['String']>;
  aolCostOfCourse?: Maybe<Scalars['numeric']>;
  aolCountry?: Maybe<Scalars['String']>;
  aolRegion?: Maybe<Scalars['String']>;
  cancellationFeePercent?: Maybe<Scalars['Int']>;
  cancellationReason?: Maybe<Scalars['String']>;
  contactProfileId?: Maybe<Scalars['uuid']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  freeSpaces?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  max_participants?: Maybe<Scalars['Int']>;
  min_participants?: Maybe<Scalars['Int']>;
  modulesDuration?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  organization_id?: Maybe<Scalars['uuid']>;
  salesRepresentativeId?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "course" */
export type Course_Min_Order_By = {
  accountCode?: InputMaybe<Order_By>;
  aolCostOfCourse?: InputMaybe<Order_By>;
  aolCountry?: InputMaybe<Order_By>;
  aolRegion?: InputMaybe<Order_By>;
  cancellationFeePercent?: InputMaybe<Order_By>;
  cancellationReason?: InputMaybe<Order_By>;
  contactProfileId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  freeSpaces?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  max_participants?: InputMaybe<Order_By>;
  min_participants?: InputMaybe<Order_By>;
  modulesDuration?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  salesRepresentativeId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** columns and relationships of "course_module" */
export type Course_Module = {
  __typename?: 'course_module';
  /** An object relationship */
  course: Course;
  courseId: Scalars['Int'];
  covered?: Maybe<Scalars['Boolean']>;
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  module: Module;
  moduleId: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "course_module" */
export type Course_Module_Aggregate = {
  __typename?: 'course_module_aggregate';
  aggregate?: Maybe<Course_Module_Aggregate_Fields>;
  nodes: Array<Course_Module>;
};

/** aggregate fields of "course_module" */
export type Course_Module_Aggregate_Fields = {
  __typename?: 'course_module_aggregate_fields';
  avg?: Maybe<Course_Module_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Module_Max_Fields>;
  min?: Maybe<Course_Module_Min_Fields>;
  stddev?: Maybe<Course_Module_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Module_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Module_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Module_Sum_Fields>;
  var_pop?: Maybe<Course_Module_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Module_Var_Samp_Fields>;
  variance?: Maybe<Course_Module_Variance_Fields>;
};


/** aggregate fields of "course_module" */
export type Course_Module_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Module_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "course_module" */
export type Course_Module_Aggregate_Order_By = {
  avg?: InputMaybe<Course_Module_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Course_Module_Max_Order_By>;
  min?: InputMaybe<Course_Module_Min_Order_By>;
  stddev?: InputMaybe<Course_Module_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Course_Module_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Course_Module_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Course_Module_Sum_Order_By>;
  var_pop?: InputMaybe<Course_Module_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Course_Module_Var_Samp_Order_By>;
  variance?: InputMaybe<Course_Module_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "course_module" */
export type Course_Module_Arr_Rel_Insert_Input = {
  data: Array<Course_Module_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Module_On_Conflict>;
};

/** aggregate avg on columns */
export type Course_Module_Avg_Fields = {
  __typename?: 'course_module_avg_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "course_module" */
export type Course_Module_Avg_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "course_module". All fields are combined with a logical 'AND'. */
export type Course_Module_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Module_Bool_Exp>>;
  _not?: InputMaybe<Course_Module_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Module_Bool_Exp>>;
  course?: InputMaybe<Course_Bool_Exp>;
  courseId?: InputMaybe<Int_Comparison_Exp>;
  covered?: InputMaybe<Boolean_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  module?: InputMaybe<Module_Bool_Exp>;
  moduleId?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_module" */
export enum Course_Module_Constraint {
  /** unique or primary key constraint */
  CourseModulePkey = 'course_module_pkey'
}

/** input type for incrementing numeric columns in table "course_module" */
export type Course_Module_Inc_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_module" */
export type Course_Module_Insert_Input = {
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  courseId?: InputMaybe<Scalars['Int']>;
  covered?: InputMaybe<Scalars['Boolean']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  module?: InputMaybe<Module_Obj_Rel_Insert_Input>;
  moduleId?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Course_Module_Max_Fields = {
  __typename?: 'course_module_max_fields';
  courseId?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  moduleId?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "course_module" */
export type Course_Module_Max_Order_By = {
  courseId?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  moduleId?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Course_Module_Min_Fields = {
  __typename?: 'course_module_min_fields';
  courseId?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  moduleId?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "course_module" */
export type Course_Module_Min_Order_By = {
  courseId?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  moduleId?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "course_module" */
export type Course_Module_Mutation_Response = {
  __typename?: 'course_module_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Module>;
};

/** on_conflict condition type for table "course_module" */
export type Course_Module_On_Conflict = {
  constraint: Course_Module_Constraint;
  update_columns?: Array<Course_Module_Update_Column>;
  where?: InputMaybe<Course_Module_Bool_Exp>;
};

/** Ordering options when selecting data from "course_module". */
export type Course_Module_Order_By = {
  course?: InputMaybe<Course_Order_By>;
  courseId?: InputMaybe<Order_By>;
  covered?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  module?: InputMaybe<Module_Order_By>;
  moduleId?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_module */
export type Course_Module_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_module" */
export enum Course_Module_Select_Column {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  Covered = 'covered',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ModuleId = 'moduleId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "course_module" */
export type Course_Module_Set_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
  covered?: InputMaybe<Scalars['Boolean']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  moduleId?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Course_Module_Stddev_Fields = {
  __typename?: 'course_module_stddev_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "course_module" */
export type Course_Module_Stddev_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Course_Module_Stddev_Pop_Fields = {
  __typename?: 'course_module_stddev_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "course_module" */
export type Course_Module_Stddev_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Course_Module_Stddev_Samp_Fields = {
  __typename?: 'course_module_stddev_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "course_module" */
export type Course_Module_Stddev_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Course_Module_Sum_Fields = {
  __typename?: 'course_module_sum_fields';
  courseId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "course_module" */
export type Course_Module_Sum_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** update columns of table "course_module" */
export enum Course_Module_Update_Column {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  Covered = 'covered',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ModuleId = 'moduleId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Course_Module_Var_Pop_Fields = {
  __typename?: 'course_module_var_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "course_module" */
export type Course_Module_Var_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Course_Module_Var_Samp_Fields = {
  __typename?: 'course_module_var_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "course_module" */
export type Course_Module_Var_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Course_Module_Variance_Fields = {
  __typename?: 'course_module_variance_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "course_module" */
export type Course_Module_Variance_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "course" */
export type Course_Mutation_Response = {
  __typename?: 'course_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course>;
};

/** input type for inserting object relation for remote table "course" */
export type Course_Obj_Rel_Insert_Input = {
  data: Course_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_On_Conflict>;
};

/** on_conflict condition type for table "course" */
export type Course_On_Conflict = {
  constraint: Course_Constraint;
  update_columns?: Array<Course_Update_Column>;
  where?: InputMaybe<Course_Bool_Exp>;
};

/** Ordering options when selecting data from "course". */
export type Course_Order_By = {
  accountCode?: InputMaybe<Order_By>;
  aolCostOfCourse?: InputMaybe<Order_By>;
  aolCountry?: InputMaybe<Order_By>;
  aolRegion?: InputMaybe<Order_By>;
  cancellationFeePercent?: InputMaybe<Order_By>;
  cancellationReason?: InputMaybe<Order_By>;
  cancellationRequest?: InputMaybe<Course_Cancellation_Request_Order_By>;
  contactProfile?: InputMaybe<Profile_Order_By>;
  contactProfileId?: InputMaybe<Order_By>;
  course_code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  deliveryType?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  end?: InputMaybe<Order_By>;
  evaluation_answers_aggregate?: InputMaybe<Course_Evaluation_Answers_Aggregate_Order_By>;
  expenses_aggregate?: InputMaybe<Course_Expenses_Aggregate_Order_By>;
  freeSpaces?: InputMaybe<Order_By>;
  go1Integration?: InputMaybe<Order_By>;
  gradingConfirmed?: InputMaybe<Order_By>;
  gradingStarted?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  level?: InputMaybe<Order_By>;
  max_participants?: InputMaybe<Order_By>;
  min_participants?: InputMaybe<Order_By>;
  modulesDuration?: InputMaybe<Order_By>;
  modules_aggregate?: InputMaybe<Course_Module_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  notes?: InputMaybe<Order_By>;
  orders_aggregate?: InputMaybe<Order_Aggregate_Order_By>;
  organization?: InputMaybe<Organization_Order_By>;
  organization_id?: InputMaybe<Order_By>;
  participants_aggregate?: InputMaybe<Course_Participant_Aggregate_Order_By>;
  promo_codes_aggregate?: InputMaybe<Course_Promo_Code_Aggregate_Order_By>;
  reaccreditation?: InputMaybe<Order_By>;
  salesRepresentative?: InputMaybe<Profile_Order_By>;
  salesRepresentativeId?: InputMaybe<Order_By>;
  schedule_aggregate?: InputMaybe<Course_Schedule_Aggregate_Order_By>;
  start?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  trainers_aggregate?: InputMaybe<Course_Trainer_Aggregate_Order_By>;
  type?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  waitlists_aggregate?: InputMaybe<Waitlist_Aggregate_Order_By>;
};

/** columns and relationships of "course_participant" */
export type Course_Participant = {
  __typename?: 'course_participant';
  attended?: Maybe<Scalars['Boolean']>;
  bookingDate?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  certificate?: Maybe<Course_Certificate>;
  /** An array relationship */
  certificateChanges: Array<Course_Certificate_Changelog>;
  /** An aggregate relationship */
  certificateChanges_aggregate: Course_Certificate_Changelog_Aggregate;
  certificate_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  course: Course;
  course_id: Scalars['Int'];
  created_at?: Maybe<Scalars['timestamptz']>;
  dateGraded?: Maybe<Scalars['timestamptz']>;
  go1EnrolmentId?: Maybe<Scalars['Int']>;
  go1EnrolmentStatus?: Maybe<Blended_Learning_Status_Enum>;
  grade?: Maybe<Grade_Enum>;
  /** An array relationship */
  gradingModules: Array<Course_Participant_Module>;
  /** An aggregate relationship */
  gradingModules_aggregate: Course_Participant_Module_Aggregate;
  grading_feedback?: Maybe<Scalars['String']>;
  healthSafetyConsent: Scalars['Boolean'];
  id: Scalars['uuid'];
  /** An object relationship */
  invite?: Maybe<Course_Invites>;
  invite_id?: Maybe<Scalars['uuid']>;
  invoiceID?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  profile: Profile;
  profile_id: Scalars['uuid'];
  registration_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};


/** columns and relationships of "course_participant" */
export type Course_ParticipantCertificateChangesArgs = {
  distinct_on?: InputMaybe<Array<Course_Certificate_Changelog_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Certificate_Changelog_Order_By>>;
  where?: InputMaybe<Course_Certificate_Changelog_Bool_Exp>;
};


/** columns and relationships of "course_participant" */
export type Course_ParticipantCertificateChanges_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Certificate_Changelog_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Certificate_Changelog_Order_By>>;
  where?: InputMaybe<Course_Certificate_Changelog_Bool_Exp>;
};


/** columns and relationships of "course_participant" */
export type Course_ParticipantGradingModulesArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Module_Order_By>>;
  where?: InputMaybe<Course_Participant_Module_Bool_Exp>;
};


/** columns and relationships of "course_participant" */
export type Course_ParticipantGradingModules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Module_Order_By>>;
  where?: InputMaybe<Course_Participant_Module_Bool_Exp>;
};

/** aggregated selection of "course_participant" */
export type Course_Participant_Aggregate = {
  __typename?: 'course_participant_aggregate';
  aggregate?: Maybe<Course_Participant_Aggregate_Fields>;
  nodes: Array<Course_Participant>;
};

/** aggregate fields of "course_participant" */
export type Course_Participant_Aggregate_Fields = {
  __typename?: 'course_participant_aggregate_fields';
  avg?: Maybe<Course_Participant_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Participant_Max_Fields>;
  min?: Maybe<Course_Participant_Min_Fields>;
  stddev?: Maybe<Course_Participant_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Participant_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Participant_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Participant_Sum_Fields>;
  var_pop?: Maybe<Course_Participant_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Participant_Var_Samp_Fields>;
  variance?: Maybe<Course_Participant_Variance_Fields>;
};


/** aggregate fields of "course_participant" */
export type Course_Participant_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Participant_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "course_participant" */
export type Course_Participant_Aggregate_Order_By = {
  avg?: InputMaybe<Course_Participant_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Course_Participant_Max_Order_By>;
  min?: InputMaybe<Course_Participant_Min_Order_By>;
  stddev?: InputMaybe<Course_Participant_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Course_Participant_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Course_Participant_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Course_Participant_Sum_Order_By>;
  var_pop?: InputMaybe<Course_Participant_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Course_Participant_Var_Samp_Order_By>;
  variance?: InputMaybe<Course_Participant_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "course_participant" */
export type Course_Participant_Arr_Rel_Insert_Input = {
  data: Array<Course_Participant_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Participant_On_Conflict>;
};

/** columns and relationships of "course_participant_audit" */
export type Course_Participant_Audit = {
  __typename?: 'course_participant_audit';
  /** An object relationship */
  authorizedBy: Profile;
  authorized_by: Scalars['uuid'];
  /** An object relationship */
  course: Course;
  course_id: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  /** A computed field, executes function "course_participant_audit_from_course" */
  fromCourse?: Maybe<Array<Course>>;
  id: Scalars['uuid'];
  /** A computed field, executes function "course_participant_audit_new_attendee" */
  newAttendeeEmail?: Maybe<Scalars['String']>;
  payload: Scalars['jsonb'];
  /** An object relationship */
  profile: Profile;
  profile_id: Scalars['uuid'];
  /** A computed field, executes function "course_participant_audit_to_course" */
  toCourse?: Maybe<Array<Course>>;
  type: Course_Participant_Audit_Type_Enum;
  updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "course_participant_audit" */
export type Course_Participant_AuditFromCourseArgs = {
  distinct_on?: InputMaybe<Array<Course_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Order_By>>;
  where?: InputMaybe<Course_Bool_Exp>;
};


/** columns and relationships of "course_participant_audit" */
export type Course_Participant_AuditPayloadArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "course_participant_audit" */
export type Course_Participant_AuditToCourseArgs = {
  distinct_on?: InputMaybe<Array<Course_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Order_By>>;
  where?: InputMaybe<Course_Bool_Exp>;
};

/** aggregated selection of "course_participant_audit" */
export type Course_Participant_Audit_Aggregate = {
  __typename?: 'course_participant_audit_aggregate';
  aggregate?: Maybe<Course_Participant_Audit_Aggregate_Fields>;
  nodes: Array<Course_Participant_Audit>;
};

/** aggregate fields of "course_participant_audit" */
export type Course_Participant_Audit_Aggregate_Fields = {
  __typename?: 'course_participant_audit_aggregate_fields';
  avg?: Maybe<Course_Participant_Audit_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Participant_Audit_Max_Fields>;
  min?: Maybe<Course_Participant_Audit_Min_Fields>;
  stddev?: Maybe<Course_Participant_Audit_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Participant_Audit_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Participant_Audit_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Participant_Audit_Sum_Fields>;
  var_pop?: Maybe<Course_Participant_Audit_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Participant_Audit_Var_Samp_Fields>;
  variance?: Maybe<Course_Participant_Audit_Variance_Fields>;
};


/** aggregate fields of "course_participant_audit" */
export type Course_Participant_Audit_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Participant_Audit_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "course_participant_audit" */
export type Course_Participant_Audit_Aggregate_Order_By = {
  avg?: InputMaybe<Course_Participant_Audit_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Course_Participant_Audit_Max_Order_By>;
  min?: InputMaybe<Course_Participant_Audit_Min_Order_By>;
  stddev?: InputMaybe<Course_Participant_Audit_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Course_Participant_Audit_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Course_Participant_Audit_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Course_Participant_Audit_Sum_Order_By>;
  var_pop?: InputMaybe<Course_Participant_Audit_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Course_Participant_Audit_Var_Samp_Order_By>;
  variance?: InputMaybe<Course_Participant_Audit_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Course_Participant_Audit_Append_Input = {
  payload?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "course_participant_audit" */
export type Course_Participant_Audit_Arr_Rel_Insert_Input = {
  data: Array<Course_Participant_Audit_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Participant_Audit_On_Conflict>;
};

/** aggregate avg on columns */
export type Course_Participant_Audit_Avg_Fields = {
  __typename?: 'course_participant_audit_avg_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "course_participant_audit" */
export type Course_Participant_Audit_Avg_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "course_participant_audit". All fields are combined with a logical 'AND'. */
export type Course_Participant_Audit_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Participant_Audit_Bool_Exp>>;
  _not?: InputMaybe<Course_Participant_Audit_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Participant_Audit_Bool_Exp>>;
  authorizedBy?: InputMaybe<Profile_Bool_Exp>;
  authorized_by?: InputMaybe<Uuid_Comparison_Exp>;
  course?: InputMaybe<Course_Bool_Exp>;
  course_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  fromCourse?: InputMaybe<Course_Bool_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  newAttendeeEmail?: InputMaybe<String_Comparison_Exp>;
  payload?: InputMaybe<Jsonb_Comparison_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profile_id?: InputMaybe<Uuid_Comparison_Exp>;
  toCourse?: InputMaybe<Course_Bool_Exp>;
  type?: InputMaybe<Course_Participant_Audit_Type_Enum_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_participant_audit" */
export enum Course_Participant_Audit_Constraint {
  /** unique or primary key constraint */
  CourseParticipantAuditPkey = 'course_participant_audit_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Course_Participant_Audit_Delete_At_Path_Input = {
  payload?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Course_Participant_Audit_Delete_Elem_Input = {
  payload?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Course_Participant_Audit_Delete_Key_Input = {
  payload?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "course_participant_audit" */
export type Course_Participant_Audit_Inc_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_participant_audit" */
export type Course_Participant_Audit_Insert_Input = {
  authorizedBy?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  authorized_by?: InputMaybe<Scalars['uuid']>;
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  course_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  payload?: InputMaybe<Scalars['jsonb']>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  type?: InputMaybe<Course_Participant_Audit_Type_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Course_Participant_Audit_Max_Fields = {
  __typename?: 'course_participant_audit_max_fields';
  authorized_by?: Maybe<Scalars['uuid']>;
  course_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "course_participant_audit" */
export type Course_Participant_Audit_Max_Order_By = {
  authorized_by?: InputMaybe<Order_By>;
  course_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Course_Participant_Audit_Min_Fields = {
  __typename?: 'course_participant_audit_min_fields';
  authorized_by?: Maybe<Scalars['uuid']>;
  course_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "course_participant_audit" */
export type Course_Participant_Audit_Min_Order_By = {
  authorized_by?: InputMaybe<Order_By>;
  course_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "course_participant_audit" */
export type Course_Participant_Audit_Mutation_Response = {
  __typename?: 'course_participant_audit_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Participant_Audit>;
};

/** on_conflict condition type for table "course_participant_audit" */
export type Course_Participant_Audit_On_Conflict = {
  constraint: Course_Participant_Audit_Constraint;
  update_columns?: Array<Course_Participant_Audit_Update_Column>;
  where?: InputMaybe<Course_Participant_Audit_Bool_Exp>;
};

/** Ordering options when selecting data from "course_participant_audit". */
export type Course_Participant_Audit_Order_By = {
  authorizedBy?: InputMaybe<Profile_Order_By>;
  authorized_by?: InputMaybe<Order_By>;
  course?: InputMaybe<Course_Order_By>;
  course_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  fromCourse_aggregate?: InputMaybe<Course_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  newAttendeeEmail?: InputMaybe<Order_By>;
  payload?: InputMaybe<Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profile_id?: InputMaybe<Order_By>;
  toCourse_aggregate?: InputMaybe<Course_Aggregate_Order_By>;
  type?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_participant_audit */
export type Course_Participant_Audit_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Course_Participant_Audit_Prepend_Input = {
  payload?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "course_participant_audit" */
export enum Course_Participant_Audit_Select_Column {
  /** column name */
  AuthorizedBy = 'authorized_by',
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Payload = 'payload',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "course_participant_audit" */
export type Course_Participant_Audit_Set_Input = {
  authorized_by?: InputMaybe<Scalars['uuid']>;
  course_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  payload?: InputMaybe<Scalars['jsonb']>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  type?: InputMaybe<Course_Participant_Audit_Type_Enum>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Course_Participant_Audit_Stddev_Fields = {
  __typename?: 'course_participant_audit_stddev_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "course_participant_audit" */
export type Course_Participant_Audit_Stddev_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Course_Participant_Audit_Stddev_Pop_Fields = {
  __typename?: 'course_participant_audit_stddev_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "course_participant_audit" */
export type Course_Participant_Audit_Stddev_Pop_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Course_Participant_Audit_Stddev_Samp_Fields = {
  __typename?: 'course_participant_audit_stddev_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "course_participant_audit" */
export type Course_Participant_Audit_Stddev_Samp_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Course_Participant_Audit_Sum_Fields = {
  __typename?: 'course_participant_audit_sum_fields';
  course_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "course_participant_audit" */
export type Course_Participant_Audit_Sum_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "course_participant_audit_type" */
export type Course_Participant_Audit_Type = {
  __typename?: 'course_participant_audit_type';
  name: Scalars['String'];
};

/** aggregated selection of "course_participant_audit_type" */
export type Course_Participant_Audit_Type_Aggregate = {
  __typename?: 'course_participant_audit_type_aggregate';
  aggregate?: Maybe<Course_Participant_Audit_Type_Aggregate_Fields>;
  nodes: Array<Course_Participant_Audit_Type>;
};

/** aggregate fields of "course_participant_audit_type" */
export type Course_Participant_Audit_Type_Aggregate_Fields = {
  __typename?: 'course_participant_audit_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Participant_Audit_Type_Max_Fields>;
  min?: Maybe<Course_Participant_Audit_Type_Min_Fields>;
};


/** aggregate fields of "course_participant_audit_type" */
export type Course_Participant_Audit_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Participant_Audit_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "course_participant_audit_type". All fields are combined with a logical 'AND'. */
export type Course_Participant_Audit_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Participant_Audit_Type_Bool_Exp>>;
  _not?: InputMaybe<Course_Participant_Audit_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Participant_Audit_Type_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_participant_audit_type" */
export enum Course_Participant_Audit_Type_Constraint {
  /** unique or primary key constraint */
  CourseParticipantAuditTypePkey = 'course_participant_audit_type_pkey'
}

export enum Course_Participant_Audit_Type_Enum {
  Attended = 'ATTENDED',
  Cancellation = 'CANCELLATION',
  NotAttended = 'NOT_ATTENDED',
  Replacement = 'REPLACEMENT',
  Transfer = 'TRANSFER'
}

/** Boolean expression to compare columns of type "course_participant_audit_type_enum". All fields are combined with logical 'AND'. */
export type Course_Participant_Audit_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Course_Participant_Audit_Type_Enum>;
  _in?: InputMaybe<Array<Course_Participant_Audit_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Course_Participant_Audit_Type_Enum>;
  _nin?: InputMaybe<Array<Course_Participant_Audit_Type_Enum>>;
};

/** input type for inserting data into table "course_participant_audit_type" */
export type Course_Participant_Audit_Type_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Participant_Audit_Type_Max_Fields = {
  __typename?: 'course_participant_audit_type_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Participant_Audit_Type_Min_Fields = {
  __typename?: 'course_participant_audit_type_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_participant_audit_type" */
export type Course_Participant_Audit_Type_Mutation_Response = {
  __typename?: 'course_participant_audit_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Participant_Audit_Type>;
};

/** on_conflict condition type for table "course_participant_audit_type" */
export type Course_Participant_Audit_Type_On_Conflict = {
  constraint: Course_Participant_Audit_Type_Constraint;
  update_columns?: Array<Course_Participant_Audit_Type_Update_Column>;
  where?: InputMaybe<Course_Participant_Audit_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "course_participant_audit_type". */
export type Course_Participant_Audit_Type_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_participant_audit_type */
export type Course_Participant_Audit_Type_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "course_participant_audit_type" */
export enum Course_Participant_Audit_Type_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "course_participant_audit_type" */
export type Course_Participant_Audit_Type_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "course_participant_audit_type" */
export enum Course_Participant_Audit_Type_Update_Column {
  /** column name */
  Name = 'name'
}

/** update columns of table "course_participant_audit" */
export enum Course_Participant_Audit_Update_Column {
  /** column name */
  AuthorizedBy = 'authorized_by',
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Payload = 'payload',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Course_Participant_Audit_Var_Pop_Fields = {
  __typename?: 'course_participant_audit_var_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "course_participant_audit" */
export type Course_Participant_Audit_Var_Pop_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Course_Participant_Audit_Var_Samp_Fields = {
  __typename?: 'course_participant_audit_var_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "course_participant_audit" */
export type Course_Participant_Audit_Var_Samp_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Course_Participant_Audit_Variance_Fields = {
  __typename?: 'course_participant_audit_variance_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "course_participant_audit" */
export type Course_Participant_Audit_Variance_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate avg on columns */
export type Course_Participant_Avg_Fields = {
  __typename?: 'course_participant_avg_fields';
  course_id?: Maybe<Scalars['Float']>;
  go1EnrolmentId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "course_participant" */
export type Course_Participant_Avg_Order_By = {
  course_id?: InputMaybe<Order_By>;
  go1EnrolmentId?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "course_participant". All fields are combined with a logical 'AND'. */
export type Course_Participant_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Participant_Bool_Exp>>;
  _not?: InputMaybe<Course_Participant_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Participant_Bool_Exp>>;
  attended?: InputMaybe<Boolean_Comparison_Exp>;
  bookingDate?: InputMaybe<Timestamptz_Comparison_Exp>;
  certificate?: InputMaybe<Course_Certificate_Bool_Exp>;
  certificateChanges?: InputMaybe<Course_Certificate_Changelog_Bool_Exp>;
  certificate_id?: InputMaybe<Uuid_Comparison_Exp>;
  course?: InputMaybe<Course_Bool_Exp>;
  course_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  dateGraded?: InputMaybe<Timestamptz_Comparison_Exp>;
  go1EnrolmentId?: InputMaybe<Int_Comparison_Exp>;
  go1EnrolmentStatus?: InputMaybe<Blended_Learning_Status_Enum_Comparison_Exp>;
  grade?: InputMaybe<Grade_Enum_Comparison_Exp>;
  gradingModules?: InputMaybe<Course_Participant_Module_Bool_Exp>;
  grading_feedback?: InputMaybe<String_Comparison_Exp>;
  healthSafetyConsent?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  invite?: InputMaybe<Course_Invites_Bool_Exp>;
  invite_id?: InputMaybe<Uuid_Comparison_Exp>;
  invoiceID?: InputMaybe<Uuid_Comparison_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profile_id?: InputMaybe<Uuid_Comparison_Exp>;
  registration_id?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** columns and relationships of "course_participant_cancellation" */
export type Course_Participant_Cancellation = {
  __typename?: 'course_participant_cancellation';
  cancellation_fee_percent: Scalars['Int'];
  cancellation_reason: Scalars['String'];
  course_id: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  profile_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "course_participant_cancellation" */
export type Course_Participant_Cancellation_Aggregate = {
  __typename?: 'course_participant_cancellation_aggregate';
  aggregate?: Maybe<Course_Participant_Cancellation_Aggregate_Fields>;
  nodes: Array<Course_Participant_Cancellation>;
};

/** aggregate fields of "course_participant_cancellation" */
export type Course_Participant_Cancellation_Aggregate_Fields = {
  __typename?: 'course_participant_cancellation_aggregate_fields';
  avg?: Maybe<Course_Participant_Cancellation_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Participant_Cancellation_Max_Fields>;
  min?: Maybe<Course_Participant_Cancellation_Min_Fields>;
  stddev?: Maybe<Course_Participant_Cancellation_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Participant_Cancellation_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Participant_Cancellation_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Participant_Cancellation_Sum_Fields>;
  var_pop?: Maybe<Course_Participant_Cancellation_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Participant_Cancellation_Var_Samp_Fields>;
  variance?: Maybe<Course_Participant_Cancellation_Variance_Fields>;
};


/** aggregate fields of "course_participant_cancellation" */
export type Course_Participant_Cancellation_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Participant_Cancellation_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Course_Participant_Cancellation_Avg_Fields = {
  __typename?: 'course_participant_cancellation_avg_fields';
  cancellation_fee_percent?: Maybe<Scalars['Float']>;
  course_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "course_participant_cancellation". All fields are combined with a logical 'AND'. */
export type Course_Participant_Cancellation_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Participant_Cancellation_Bool_Exp>>;
  _not?: InputMaybe<Course_Participant_Cancellation_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Participant_Cancellation_Bool_Exp>>;
  cancellation_fee_percent?: InputMaybe<Int_Comparison_Exp>;
  cancellation_reason?: InputMaybe<String_Comparison_Exp>;
  course_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  profile_id?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_participant_cancellation" */
export enum Course_Participant_Cancellation_Constraint {
  /** unique or primary key constraint */
  CourseParticipantCancellationPkey = 'course_participant_cancellation_pkey'
}

/** input type for incrementing numeric columns in table "course_participant_cancellation" */
export type Course_Participant_Cancellation_Inc_Input = {
  cancellation_fee_percent?: InputMaybe<Scalars['Int']>;
  course_id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_participant_cancellation" */
export type Course_Participant_Cancellation_Insert_Input = {
  cancellation_fee_percent?: InputMaybe<Scalars['Int']>;
  cancellation_reason?: InputMaybe<Scalars['String']>;
  course_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Course_Participant_Cancellation_Max_Fields = {
  __typename?: 'course_participant_cancellation_max_fields';
  cancellation_fee_percent?: Maybe<Scalars['Int']>;
  cancellation_reason?: Maybe<Scalars['String']>;
  course_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Course_Participant_Cancellation_Min_Fields = {
  __typename?: 'course_participant_cancellation_min_fields';
  cancellation_fee_percent?: Maybe<Scalars['Int']>;
  cancellation_reason?: Maybe<Scalars['String']>;
  course_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "course_participant_cancellation" */
export type Course_Participant_Cancellation_Mutation_Response = {
  __typename?: 'course_participant_cancellation_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Participant_Cancellation>;
};

/** on_conflict condition type for table "course_participant_cancellation" */
export type Course_Participant_Cancellation_On_Conflict = {
  constraint: Course_Participant_Cancellation_Constraint;
  update_columns?: Array<Course_Participant_Cancellation_Update_Column>;
  where?: InputMaybe<Course_Participant_Cancellation_Bool_Exp>;
};

/** Ordering options when selecting data from "course_participant_cancellation". */
export type Course_Participant_Cancellation_Order_By = {
  cancellation_fee_percent?: InputMaybe<Order_By>;
  cancellation_reason?: InputMaybe<Order_By>;
  course_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_participant_cancellation */
export type Course_Participant_Cancellation_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_participant_cancellation" */
export enum Course_Participant_Cancellation_Select_Column {
  /** column name */
  CancellationFeePercent = 'cancellation_fee_percent',
  /** column name */
  CancellationReason = 'cancellation_reason',
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "course_participant_cancellation" */
export type Course_Participant_Cancellation_Set_Input = {
  cancellation_fee_percent?: InputMaybe<Scalars['Int']>;
  cancellation_reason?: InputMaybe<Scalars['String']>;
  course_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Course_Participant_Cancellation_Stddev_Fields = {
  __typename?: 'course_participant_cancellation_stddev_fields';
  cancellation_fee_percent?: Maybe<Scalars['Float']>;
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Course_Participant_Cancellation_Stddev_Pop_Fields = {
  __typename?: 'course_participant_cancellation_stddev_pop_fields';
  cancellation_fee_percent?: Maybe<Scalars['Float']>;
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Course_Participant_Cancellation_Stddev_Samp_Fields = {
  __typename?: 'course_participant_cancellation_stddev_samp_fields';
  cancellation_fee_percent?: Maybe<Scalars['Float']>;
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Course_Participant_Cancellation_Sum_Fields = {
  __typename?: 'course_participant_cancellation_sum_fields';
  cancellation_fee_percent?: Maybe<Scalars['Int']>;
  course_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "course_participant_cancellation" */
export enum Course_Participant_Cancellation_Update_Column {
  /** column name */
  CancellationFeePercent = 'cancellation_fee_percent',
  /** column name */
  CancellationReason = 'cancellation_reason',
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Course_Participant_Cancellation_Var_Pop_Fields = {
  __typename?: 'course_participant_cancellation_var_pop_fields';
  cancellation_fee_percent?: Maybe<Scalars['Float']>;
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Course_Participant_Cancellation_Var_Samp_Fields = {
  __typename?: 'course_participant_cancellation_var_samp_fields';
  cancellation_fee_percent?: Maybe<Scalars['Float']>;
  course_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Course_Participant_Cancellation_Variance_Fields = {
  __typename?: 'course_participant_cancellation_variance_fields';
  cancellation_fee_percent?: Maybe<Scalars['Float']>;
  course_id?: Maybe<Scalars['Float']>;
};

/** unique or primary key constraints on table "course_participant" */
export enum Course_Participant_Constraint {
  /** unique or primary key constraint */
  CourseParticipantPkey = 'course_participant_pkey',
  /** unique or primary key constraint */
  CourseParticipantProfileIdCourseIdKey = 'course_participant_profile_id_course_id_key'
}

/** input type for incrementing numeric columns in table "course_participant" */
export type Course_Participant_Inc_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
  go1EnrolmentId?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_participant" */
export type Course_Participant_Insert_Input = {
  attended?: InputMaybe<Scalars['Boolean']>;
  bookingDate?: InputMaybe<Scalars['timestamptz']>;
  certificate?: InputMaybe<Course_Certificate_Obj_Rel_Insert_Input>;
  certificateChanges?: InputMaybe<Course_Certificate_Changelog_Arr_Rel_Insert_Input>;
  certificate_id?: InputMaybe<Scalars['uuid']>;
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  course_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  dateGraded?: InputMaybe<Scalars['timestamptz']>;
  go1EnrolmentId?: InputMaybe<Scalars['Int']>;
  go1EnrolmentStatus?: InputMaybe<Blended_Learning_Status_Enum>;
  grade?: InputMaybe<Grade_Enum>;
  gradingModules?: InputMaybe<Course_Participant_Module_Arr_Rel_Insert_Input>;
  grading_feedback?: InputMaybe<Scalars['String']>;
  healthSafetyConsent?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  invite?: InputMaybe<Course_Invites_Obj_Rel_Insert_Input>;
  invite_id?: InputMaybe<Scalars['uuid']>;
  invoiceID?: InputMaybe<Scalars['uuid']>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  registration_id?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Course_Participant_Max_Fields = {
  __typename?: 'course_participant_max_fields';
  bookingDate?: Maybe<Scalars['timestamptz']>;
  certificate_id?: Maybe<Scalars['uuid']>;
  course_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dateGraded?: Maybe<Scalars['timestamptz']>;
  go1EnrolmentId?: Maybe<Scalars['Int']>;
  grading_feedback?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  invite_id?: Maybe<Scalars['uuid']>;
  invoiceID?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
  registration_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "course_participant" */
export type Course_Participant_Max_Order_By = {
  bookingDate?: InputMaybe<Order_By>;
  certificate_id?: InputMaybe<Order_By>;
  course_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  dateGraded?: InputMaybe<Order_By>;
  go1EnrolmentId?: InputMaybe<Order_By>;
  grading_feedback?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invite_id?: InputMaybe<Order_By>;
  invoiceID?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  registration_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Course_Participant_Min_Fields = {
  __typename?: 'course_participant_min_fields';
  bookingDate?: Maybe<Scalars['timestamptz']>;
  certificate_id?: Maybe<Scalars['uuid']>;
  course_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dateGraded?: Maybe<Scalars['timestamptz']>;
  go1EnrolmentId?: Maybe<Scalars['Int']>;
  grading_feedback?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  invite_id?: Maybe<Scalars['uuid']>;
  invoiceID?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
  registration_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "course_participant" */
export type Course_Participant_Min_Order_By = {
  bookingDate?: InputMaybe<Order_By>;
  certificate_id?: InputMaybe<Order_By>;
  course_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  dateGraded?: InputMaybe<Order_By>;
  go1EnrolmentId?: InputMaybe<Order_By>;
  grading_feedback?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invite_id?: InputMaybe<Order_By>;
  invoiceID?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  registration_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** Course modules that course participant completed */
export type Course_Participant_Module = {
  __typename?: 'course_participant_module';
  completed: Scalars['Boolean'];
  /** An object relationship */
  course_participant: Course_Participant;
  course_participant_id: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An object relationship */
  module: Module;
  module_id: Scalars['uuid'];
};

/** aggregated selection of "course_participant_module" */
export type Course_Participant_Module_Aggregate = {
  __typename?: 'course_participant_module_aggregate';
  aggregate?: Maybe<Course_Participant_Module_Aggregate_Fields>;
  nodes: Array<Course_Participant_Module>;
};

/** aggregate fields of "course_participant_module" */
export type Course_Participant_Module_Aggregate_Fields = {
  __typename?: 'course_participant_module_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Participant_Module_Max_Fields>;
  min?: Maybe<Course_Participant_Module_Min_Fields>;
};


/** aggregate fields of "course_participant_module" */
export type Course_Participant_Module_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Participant_Module_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "course_participant_module" */
export type Course_Participant_Module_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Course_Participant_Module_Max_Order_By>;
  min?: InputMaybe<Course_Participant_Module_Min_Order_By>;
};

/** input type for inserting array relation for remote table "course_participant_module" */
export type Course_Participant_Module_Arr_Rel_Insert_Input = {
  data: Array<Course_Participant_Module_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Participant_Module_On_Conflict>;
};

/** Boolean expression to filter rows from the table "course_participant_module". All fields are combined with a logical 'AND'. */
export type Course_Participant_Module_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Participant_Module_Bool_Exp>>;
  _not?: InputMaybe<Course_Participant_Module_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Participant_Module_Bool_Exp>>;
  completed?: InputMaybe<Boolean_Comparison_Exp>;
  course_participant?: InputMaybe<Course_Participant_Bool_Exp>;
  course_participant_id?: InputMaybe<Uuid_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  module?: InputMaybe<Module_Bool_Exp>;
  module_id?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_participant_module" */
export enum Course_Participant_Module_Constraint {
  /** unique or primary key constraint */
  CourseParticipantModuleCourseParticipantIdModuleIdKey = 'course_participant_module_course_participant_id_module_id_key',
  /** unique or primary key constraint */
  CourseParticipantModulePkey = 'course_participant_module_pkey'
}

/** input type for inserting data into table "course_participant_module" */
export type Course_Participant_Module_Insert_Input = {
  completed?: InputMaybe<Scalars['Boolean']>;
  course_participant?: InputMaybe<Course_Participant_Obj_Rel_Insert_Input>;
  course_participant_id?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  module?: InputMaybe<Module_Obj_Rel_Insert_Input>;
  module_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Course_Participant_Module_Max_Fields = {
  __typename?: 'course_participant_module_max_fields';
  course_participant_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  module_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "course_participant_module" */
export type Course_Participant_Module_Max_Order_By = {
  course_participant_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  module_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Course_Participant_Module_Min_Fields = {
  __typename?: 'course_participant_module_min_fields';
  course_participant_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  module_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "course_participant_module" */
export type Course_Participant_Module_Min_Order_By = {
  course_participant_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  module_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "course_participant_module" */
export type Course_Participant_Module_Mutation_Response = {
  __typename?: 'course_participant_module_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Participant_Module>;
};

/** on_conflict condition type for table "course_participant_module" */
export type Course_Participant_Module_On_Conflict = {
  constraint: Course_Participant_Module_Constraint;
  update_columns?: Array<Course_Participant_Module_Update_Column>;
  where?: InputMaybe<Course_Participant_Module_Bool_Exp>;
};

/** Ordering options when selecting data from "course_participant_module". */
export type Course_Participant_Module_Order_By = {
  completed?: InputMaybe<Order_By>;
  course_participant?: InputMaybe<Course_Participant_Order_By>;
  course_participant_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  module?: InputMaybe<Module_Order_By>;
  module_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_participant_module */
export type Course_Participant_Module_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_participant_module" */
export enum Course_Participant_Module_Select_Column {
  /** column name */
  Completed = 'completed',
  /** column name */
  CourseParticipantId = 'course_participant_id',
  /** column name */
  Id = 'id',
  /** column name */
  ModuleId = 'module_id'
}

/** input type for updating data in table "course_participant_module" */
export type Course_Participant_Module_Set_Input = {
  completed?: InputMaybe<Scalars['Boolean']>;
  course_participant_id?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  module_id?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "course_participant_module" */
export enum Course_Participant_Module_Update_Column {
  /** column name */
  Completed = 'completed',
  /** column name */
  CourseParticipantId = 'course_participant_id',
  /** column name */
  Id = 'id',
  /** column name */
  ModuleId = 'module_id'
}

/** response of any mutation on the table "course_participant" */
export type Course_Participant_Mutation_Response = {
  __typename?: 'course_participant_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Participant>;
};

/** input type for inserting object relation for remote table "course_participant" */
export type Course_Participant_Obj_Rel_Insert_Input = {
  data: Course_Participant_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Participant_On_Conflict>;
};

/** on_conflict condition type for table "course_participant" */
export type Course_Participant_On_Conflict = {
  constraint: Course_Participant_Constraint;
  update_columns?: Array<Course_Participant_Update_Column>;
  where?: InputMaybe<Course_Participant_Bool_Exp>;
};

/** Ordering options when selecting data from "course_participant". */
export type Course_Participant_Order_By = {
  attended?: InputMaybe<Order_By>;
  bookingDate?: InputMaybe<Order_By>;
  certificate?: InputMaybe<Course_Certificate_Order_By>;
  certificateChanges_aggregate?: InputMaybe<Course_Certificate_Changelog_Aggregate_Order_By>;
  certificate_id?: InputMaybe<Order_By>;
  course?: InputMaybe<Course_Order_By>;
  course_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  dateGraded?: InputMaybe<Order_By>;
  go1EnrolmentId?: InputMaybe<Order_By>;
  go1EnrolmentStatus?: InputMaybe<Order_By>;
  grade?: InputMaybe<Order_By>;
  gradingModules_aggregate?: InputMaybe<Course_Participant_Module_Aggregate_Order_By>;
  grading_feedback?: InputMaybe<Order_By>;
  healthSafetyConsent?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  invite?: InputMaybe<Course_Invites_Order_By>;
  invite_id?: InputMaybe<Order_By>;
  invoiceID?: InputMaybe<Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profile_id?: InputMaybe<Order_By>;
  registration_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_participant */
export type Course_Participant_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_participant" */
export enum Course_Participant_Select_Column {
  /** column name */
  Attended = 'attended',
  /** column name */
  BookingDate = 'bookingDate',
  /** column name */
  CertificateId = 'certificate_id',
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DateGraded = 'dateGraded',
  /** column name */
  Go1EnrolmentId = 'go1EnrolmentId',
  /** column name */
  Go1EnrolmentStatus = 'go1EnrolmentStatus',
  /** column name */
  Grade = 'grade',
  /** column name */
  GradingFeedback = 'grading_feedback',
  /** column name */
  HealthSafetyConsent = 'healthSafetyConsent',
  /** column name */
  Id = 'id',
  /** column name */
  InviteId = 'invite_id',
  /** column name */
  InvoiceId = 'invoiceID',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  RegistrationId = 'registration_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "course_participant" */
export type Course_Participant_Set_Input = {
  attended?: InputMaybe<Scalars['Boolean']>;
  bookingDate?: InputMaybe<Scalars['timestamptz']>;
  certificate_id?: InputMaybe<Scalars['uuid']>;
  course_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  dateGraded?: InputMaybe<Scalars['timestamptz']>;
  go1EnrolmentId?: InputMaybe<Scalars['Int']>;
  go1EnrolmentStatus?: InputMaybe<Blended_Learning_Status_Enum>;
  grade?: InputMaybe<Grade_Enum>;
  grading_feedback?: InputMaybe<Scalars['String']>;
  healthSafetyConsent?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  invite_id?: InputMaybe<Scalars['uuid']>;
  invoiceID?: InputMaybe<Scalars['uuid']>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  registration_id?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Course_Participant_Stddev_Fields = {
  __typename?: 'course_participant_stddev_fields';
  course_id?: Maybe<Scalars['Float']>;
  go1EnrolmentId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "course_participant" */
export type Course_Participant_Stddev_Order_By = {
  course_id?: InputMaybe<Order_By>;
  go1EnrolmentId?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Course_Participant_Stddev_Pop_Fields = {
  __typename?: 'course_participant_stddev_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
  go1EnrolmentId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "course_participant" */
export type Course_Participant_Stddev_Pop_Order_By = {
  course_id?: InputMaybe<Order_By>;
  go1EnrolmentId?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Course_Participant_Stddev_Samp_Fields = {
  __typename?: 'course_participant_stddev_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
  go1EnrolmentId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "course_participant" */
export type Course_Participant_Stddev_Samp_Order_By = {
  course_id?: InputMaybe<Order_By>;
  go1EnrolmentId?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Course_Participant_Sum_Fields = {
  __typename?: 'course_participant_sum_fields';
  course_id?: Maybe<Scalars['Int']>;
  go1EnrolmentId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "course_participant" */
export type Course_Participant_Sum_Order_By = {
  course_id?: InputMaybe<Order_By>;
  go1EnrolmentId?: InputMaybe<Order_By>;
};

/** update columns of table "course_participant" */
export enum Course_Participant_Update_Column {
  /** column name */
  Attended = 'attended',
  /** column name */
  BookingDate = 'bookingDate',
  /** column name */
  CertificateId = 'certificate_id',
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DateGraded = 'dateGraded',
  /** column name */
  Go1EnrolmentId = 'go1EnrolmentId',
  /** column name */
  Go1EnrolmentStatus = 'go1EnrolmentStatus',
  /** column name */
  Grade = 'grade',
  /** column name */
  GradingFeedback = 'grading_feedback',
  /** column name */
  HealthSafetyConsent = 'healthSafetyConsent',
  /** column name */
  Id = 'id',
  /** column name */
  InviteId = 'invite_id',
  /** column name */
  InvoiceId = 'invoiceID',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  RegistrationId = 'registration_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Course_Participant_Var_Pop_Fields = {
  __typename?: 'course_participant_var_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
  go1EnrolmentId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "course_participant" */
export type Course_Participant_Var_Pop_Order_By = {
  course_id?: InputMaybe<Order_By>;
  go1EnrolmentId?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Course_Participant_Var_Samp_Fields = {
  __typename?: 'course_participant_var_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
  go1EnrolmentId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "course_participant" */
export type Course_Participant_Var_Samp_Order_By = {
  course_id?: InputMaybe<Order_By>;
  go1EnrolmentId?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Course_Participant_Variance_Fields = {
  __typename?: 'course_participant_variance_fields';
  course_id?: Maybe<Scalars['Float']>;
  go1EnrolmentId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "course_participant" */
export type Course_Participant_Variance_Order_By = {
  course_id?: InputMaybe<Order_By>;
  go1EnrolmentId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course */
export type Course_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** Prices per participant for various course variants */
export type Course_Pricing = {
  __typename?: 'course_pricing';
  blended: Scalars['Boolean'];
  id: Scalars['uuid'];
  level: Course_Level_Enum;
  /** Price per participant without any discounts */
  priceAmount: Scalars['numeric'];
  priceCurrency: Scalars['String'];
  reaccreditation: Scalars['Boolean'];
  type: Course_Type_Enum;
  xeroCode: Scalars['String'];
};

/** aggregated selection of "course_pricing" */
export type Course_Pricing_Aggregate = {
  __typename?: 'course_pricing_aggregate';
  aggregate?: Maybe<Course_Pricing_Aggregate_Fields>;
  nodes: Array<Course_Pricing>;
};

/** aggregate fields of "course_pricing" */
export type Course_Pricing_Aggregate_Fields = {
  __typename?: 'course_pricing_aggregate_fields';
  avg?: Maybe<Course_Pricing_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Pricing_Max_Fields>;
  min?: Maybe<Course_Pricing_Min_Fields>;
  stddev?: Maybe<Course_Pricing_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Pricing_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Pricing_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Pricing_Sum_Fields>;
  var_pop?: Maybe<Course_Pricing_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Pricing_Var_Samp_Fields>;
  variance?: Maybe<Course_Pricing_Variance_Fields>;
};


/** aggregate fields of "course_pricing" */
export type Course_Pricing_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Pricing_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Course_Pricing_Avg_Fields = {
  __typename?: 'course_pricing_avg_fields';
  /** Price per participant without any discounts */
  priceAmount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "course_pricing". All fields are combined with a logical 'AND'. */
export type Course_Pricing_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Pricing_Bool_Exp>>;
  _not?: InputMaybe<Course_Pricing_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Pricing_Bool_Exp>>;
  blended?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  level?: InputMaybe<Course_Level_Enum_Comparison_Exp>;
  priceAmount?: InputMaybe<Numeric_Comparison_Exp>;
  priceCurrency?: InputMaybe<String_Comparison_Exp>;
  reaccreditation?: InputMaybe<Boolean_Comparison_Exp>;
  type?: InputMaybe<Course_Type_Enum_Comparison_Exp>;
  xeroCode?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_pricing" */
export enum Course_Pricing_Constraint {
  /** unique or primary key constraint */
  CoursePricingPkey = 'course_pricing_pkey',
  /** unique or primary key constraint */
  CoursePricingTypeLevelBlendedReaccreditationKey = 'course_pricing_type_level_blended_reaccreditation_key'
}

/** input type for incrementing numeric columns in table "course_pricing" */
export type Course_Pricing_Inc_Input = {
  /** Price per participant without any discounts */
  priceAmount?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "course_pricing" */
export type Course_Pricing_Insert_Input = {
  blended?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  level?: InputMaybe<Course_Level_Enum>;
  /** Price per participant without any discounts */
  priceAmount?: InputMaybe<Scalars['numeric']>;
  priceCurrency?: InputMaybe<Scalars['String']>;
  reaccreditation?: InputMaybe<Scalars['Boolean']>;
  type?: InputMaybe<Course_Type_Enum>;
  xeroCode?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Pricing_Max_Fields = {
  __typename?: 'course_pricing_max_fields';
  id?: Maybe<Scalars['uuid']>;
  /** Price per participant without any discounts */
  priceAmount?: Maybe<Scalars['numeric']>;
  priceCurrency?: Maybe<Scalars['String']>;
  xeroCode?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Pricing_Min_Fields = {
  __typename?: 'course_pricing_min_fields';
  id?: Maybe<Scalars['uuid']>;
  /** Price per participant without any discounts */
  priceAmount?: Maybe<Scalars['numeric']>;
  priceCurrency?: Maybe<Scalars['String']>;
  xeroCode?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_pricing" */
export type Course_Pricing_Mutation_Response = {
  __typename?: 'course_pricing_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Pricing>;
};

/** on_conflict condition type for table "course_pricing" */
export type Course_Pricing_On_Conflict = {
  constraint: Course_Pricing_Constraint;
  update_columns?: Array<Course_Pricing_Update_Column>;
  where?: InputMaybe<Course_Pricing_Bool_Exp>;
};

/** Ordering options when selecting data from "course_pricing". */
export type Course_Pricing_Order_By = {
  blended?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  level?: InputMaybe<Order_By>;
  priceAmount?: InputMaybe<Order_By>;
  priceCurrency?: InputMaybe<Order_By>;
  reaccreditation?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  xeroCode?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_pricing */
export type Course_Pricing_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_pricing" */
export enum Course_Pricing_Select_Column {
  /** column name */
  Blended = 'blended',
  /** column name */
  Id = 'id',
  /** column name */
  Level = 'level',
  /** column name */
  PriceAmount = 'priceAmount',
  /** column name */
  PriceCurrency = 'priceCurrency',
  /** column name */
  Reaccreditation = 'reaccreditation',
  /** column name */
  Type = 'type',
  /** column name */
  XeroCode = 'xeroCode'
}

/** input type for updating data in table "course_pricing" */
export type Course_Pricing_Set_Input = {
  blended?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  level?: InputMaybe<Course_Level_Enum>;
  /** Price per participant without any discounts */
  priceAmount?: InputMaybe<Scalars['numeric']>;
  priceCurrency?: InputMaybe<Scalars['String']>;
  reaccreditation?: InputMaybe<Scalars['Boolean']>;
  type?: InputMaybe<Course_Type_Enum>;
  xeroCode?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Course_Pricing_Stddev_Fields = {
  __typename?: 'course_pricing_stddev_fields';
  /** Price per participant without any discounts */
  priceAmount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Course_Pricing_Stddev_Pop_Fields = {
  __typename?: 'course_pricing_stddev_pop_fields';
  /** Price per participant without any discounts */
  priceAmount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Course_Pricing_Stddev_Samp_Fields = {
  __typename?: 'course_pricing_stddev_samp_fields';
  /** Price per participant without any discounts */
  priceAmount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Course_Pricing_Sum_Fields = {
  __typename?: 'course_pricing_sum_fields';
  /** Price per participant without any discounts */
  priceAmount?: Maybe<Scalars['numeric']>;
};

/** update columns of table "course_pricing" */
export enum Course_Pricing_Update_Column {
  /** column name */
  Blended = 'blended',
  /** column name */
  Id = 'id',
  /** column name */
  Level = 'level',
  /** column name */
  PriceAmount = 'priceAmount',
  /** column name */
  PriceCurrency = 'priceCurrency',
  /** column name */
  Reaccreditation = 'reaccreditation',
  /** column name */
  Type = 'type',
  /** column name */
  XeroCode = 'xeroCode'
}

/** aggregate var_pop on columns */
export type Course_Pricing_Var_Pop_Fields = {
  __typename?: 'course_pricing_var_pop_fields';
  /** Price per participant without any discounts */
  priceAmount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Course_Pricing_Var_Samp_Fields = {
  __typename?: 'course_pricing_var_samp_fields';
  /** Price per participant without any discounts */
  priceAmount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Course_Pricing_Variance_Fields = {
  __typename?: 'course_pricing_variance_fields';
  /** Price per participant without any discounts */
  priceAmount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "course_promo_code" */
export type Course_Promo_Code = {
  __typename?: 'course_promo_code';
  /** An object relationship */
  course?: Maybe<Course>;
  course_id?: Maybe<Scalars['Int']>;
  id: Scalars['uuid'];
  /** An object relationship */
  promo_code?: Maybe<Promo_Code>;
  promo_id?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "course_promo_code" */
export type Course_Promo_Code_Aggregate = {
  __typename?: 'course_promo_code_aggregate';
  aggregate?: Maybe<Course_Promo_Code_Aggregate_Fields>;
  nodes: Array<Course_Promo_Code>;
};

/** aggregate fields of "course_promo_code" */
export type Course_Promo_Code_Aggregate_Fields = {
  __typename?: 'course_promo_code_aggregate_fields';
  avg?: Maybe<Course_Promo_Code_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Promo_Code_Max_Fields>;
  min?: Maybe<Course_Promo_Code_Min_Fields>;
  stddev?: Maybe<Course_Promo_Code_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Promo_Code_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Promo_Code_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Promo_Code_Sum_Fields>;
  var_pop?: Maybe<Course_Promo_Code_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Promo_Code_Var_Samp_Fields>;
  variance?: Maybe<Course_Promo_Code_Variance_Fields>;
};


/** aggregate fields of "course_promo_code" */
export type Course_Promo_Code_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Promo_Code_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "course_promo_code" */
export type Course_Promo_Code_Aggregate_Order_By = {
  avg?: InputMaybe<Course_Promo_Code_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Course_Promo_Code_Max_Order_By>;
  min?: InputMaybe<Course_Promo_Code_Min_Order_By>;
  stddev?: InputMaybe<Course_Promo_Code_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Course_Promo_Code_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Course_Promo_Code_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Course_Promo_Code_Sum_Order_By>;
  var_pop?: InputMaybe<Course_Promo_Code_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Course_Promo_Code_Var_Samp_Order_By>;
  variance?: InputMaybe<Course_Promo_Code_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "course_promo_code" */
export type Course_Promo_Code_Arr_Rel_Insert_Input = {
  data: Array<Course_Promo_Code_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Promo_Code_On_Conflict>;
};

/** aggregate avg on columns */
export type Course_Promo_Code_Avg_Fields = {
  __typename?: 'course_promo_code_avg_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "course_promo_code" */
export type Course_Promo_Code_Avg_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "course_promo_code". All fields are combined with a logical 'AND'. */
export type Course_Promo_Code_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Promo_Code_Bool_Exp>>;
  _not?: InputMaybe<Course_Promo_Code_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Promo_Code_Bool_Exp>>;
  course?: InputMaybe<Course_Bool_Exp>;
  course_id?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  promo_code?: InputMaybe<Promo_Code_Bool_Exp>;
  promo_id?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_promo_code" */
export enum Course_Promo_Code_Constraint {
  /** unique or primary key constraint */
  CoursePromoCodePkey = 'course_promo_code_pkey'
}

/** input type for incrementing numeric columns in table "course_promo_code" */
export type Course_Promo_Code_Inc_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_promo_code" */
export type Course_Promo_Code_Insert_Input = {
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  course_id?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  promo_code?: InputMaybe<Promo_Code_Obj_Rel_Insert_Input>;
  promo_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Course_Promo_Code_Max_Fields = {
  __typename?: 'course_promo_code_max_fields';
  course_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  promo_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "course_promo_code" */
export type Course_Promo_Code_Max_Order_By = {
  course_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  promo_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Course_Promo_Code_Min_Fields = {
  __typename?: 'course_promo_code_min_fields';
  course_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  promo_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "course_promo_code" */
export type Course_Promo_Code_Min_Order_By = {
  course_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  promo_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "course_promo_code" */
export type Course_Promo_Code_Mutation_Response = {
  __typename?: 'course_promo_code_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Promo_Code>;
};

/** on_conflict condition type for table "course_promo_code" */
export type Course_Promo_Code_On_Conflict = {
  constraint: Course_Promo_Code_Constraint;
  update_columns?: Array<Course_Promo_Code_Update_Column>;
  where?: InputMaybe<Course_Promo_Code_Bool_Exp>;
};

/** Ordering options when selecting data from "course_promo_code". */
export type Course_Promo_Code_Order_By = {
  course?: InputMaybe<Course_Order_By>;
  course_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  promo_code?: InputMaybe<Promo_Code_Order_By>;
  promo_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_promo_code */
export type Course_Promo_Code_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_promo_code" */
export enum Course_Promo_Code_Select_Column {
  /** column name */
  CourseId = 'course_id',
  /** column name */
  Id = 'id',
  /** column name */
  PromoId = 'promo_id'
}

/** input type for updating data in table "course_promo_code" */
export type Course_Promo_Code_Set_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  promo_id?: InputMaybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Course_Promo_Code_Stddev_Fields = {
  __typename?: 'course_promo_code_stddev_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "course_promo_code" */
export type Course_Promo_Code_Stddev_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Course_Promo_Code_Stddev_Pop_Fields = {
  __typename?: 'course_promo_code_stddev_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "course_promo_code" */
export type Course_Promo_Code_Stddev_Pop_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Course_Promo_Code_Stddev_Samp_Fields = {
  __typename?: 'course_promo_code_stddev_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "course_promo_code" */
export type Course_Promo_Code_Stddev_Samp_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Course_Promo_Code_Sum_Fields = {
  __typename?: 'course_promo_code_sum_fields';
  course_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "course_promo_code" */
export type Course_Promo_Code_Sum_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** update columns of table "course_promo_code" */
export enum Course_Promo_Code_Update_Column {
  /** column name */
  CourseId = 'course_id',
  /** column name */
  Id = 'id',
  /** column name */
  PromoId = 'promo_id'
}

/** aggregate var_pop on columns */
export type Course_Promo_Code_Var_Pop_Fields = {
  __typename?: 'course_promo_code_var_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "course_promo_code" */
export type Course_Promo_Code_Var_Pop_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Course_Promo_Code_Var_Samp_Fields = {
  __typename?: 'course_promo_code_var_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "course_promo_code" */
export type Course_Promo_Code_Var_Samp_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Course_Promo_Code_Variance_Fields = {
  __typename?: 'course_promo_code_variance_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "course_promo_code" */
export type Course_Promo_Code_Variance_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "course_schedule" */
export type Course_Schedule = {
  __typename?: 'course_schedule';
  /** An object relationship */
  course: Course;
  course_id: Scalars['Int'];
  createdAt: Scalars['timestamptz'];
  end: Scalars['timestamptz'];
  id: Scalars['uuid'];
  start: Scalars['timestamptz'];
  updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  venue?: Maybe<Venue>;
  venue_id?: Maybe<Scalars['uuid']>;
  virtualLink?: Maybe<Scalars['String']>;
};

/** aggregated selection of "course_schedule" */
export type Course_Schedule_Aggregate = {
  __typename?: 'course_schedule_aggregate';
  aggregate?: Maybe<Course_Schedule_Aggregate_Fields>;
  nodes: Array<Course_Schedule>;
};

/** aggregate fields of "course_schedule" */
export type Course_Schedule_Aggregate_Fields = {
  __typename?: 'course_schedule_aggregate_fields';
  avg?: Maybe<Course_Schedule_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Schedule_Max_Fields>;
  min?: Maybe<Course_Schedule_Min_Fields>;
  stddev?: Maybe<Course_Schedule_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Schedule_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Schedule_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Schedule_Sum_Fields>;
  var_pop?: Maybe<Course_Schedule_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Schedule_Var_Samp_Fields>;
  variance?: Maybe<Course_Schedule_Variance_Fields>;
};


/** aggregate fields of "course_schedule" */
export type Course_Schedule_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Schedule_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "course_schedule" */
export type Course_Schedule_Aggregate_Order_By = {
  avg?: InputMaybe<Course_Schedule_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Course_Schedule_Max_Order_By>;
  min?: InputMaybe<Course_Schedule_Min_Order_By>;
  stddev?: InputMaybe<Course_Schedule_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Course_Schedule_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Course_Schedule_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Course_Schedule_Sum_Order_By>;
  var_pop?: InputMaybe<Course_Schedule_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Course_Schedule_Var_Samp_Order_By>;
  variance?: InputMaybe<Course_Schedule_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "course_schedule" */
export type Course_Schedule_Arr_Rel_Insert_Input = {
  data: Array<Course_Schedule_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Schedule_On_Conflict>;
};

/** aggregate avg on columns */
export type Course_Schedule_Avg_Fields = {
  __typename?: 'course_schedule_avg_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "course_schedule" */
export type Course_Schedule_Avg_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "course_schedule". All fields are combined with a logical 'AND'. */
export type Course_Schedule_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Schedule_Bool_Exp>>;
  _not?: InputMaybe<Course_Schedule_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Schedule_Bool_Exp>>;
  course?: InputMaybe<Course_Bool_Exp>;
  course_id?: InputMaybe<Int_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  end?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  start?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  venue?: InputMaybe<Venue_Bool_Exp>;
  venue_id?: InputMaybe<Uuid_Comparison_Exp>;
  virtualLink?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_schedule" */
export enum Course_Schedule_Constraint {
  /** unique or primary key constraint */
  CourseSchedulePkey = 'course_schedule_pkey'
}

/** input type for incrementing numeric columns in table "course_schedule" */
export type Course_Schedule_Inc_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_schedule" */
export type Course_Schedule_Insert_Input = {
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  course_id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  end?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  start?: InputMaybe<Scalars['timestamptz']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venue?: InputMaybe<Venue_Obj_Rel_Insert_Input>;
  venue_id?: InputMaybe<Scalars['uuid']>;
  virtualLink?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Schedule_Max_Fields = {
  __typename?: 'course_schedule_max_fields';
  course_id?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  end?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  start?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venue_id?: Maybe<Scalars['uuid']>;
  virtualLink?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "course_schedule" */
export type Course_Schedule_Max_Order_By = {
  course_id?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  end?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  start?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  venue_id?: InputMaybe<Order_By>;
  virtualLink?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Course_Schedule_Min_Fields = {
  __typename?: 'course_schedule_min_fields';
  course_id?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  end?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  start?: Maybe<Scalars['timestamptz']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  venue_id?: Maybe<Scalars['uuid']>;
  virtualLink?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "course_schedule" */
export type Course_Schedule_Min_Order_By = {
  course_id?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  end?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  start?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  venue_id?: InputMaybe<Order_By>;
  virtualLink?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "course_schedule" */
export type Course_Schedule_Mutation_Response = {
  __typename?: 'course_schedule_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Schedule>;
};

/** on_conflict condition type for table "course_schedule" */
export type Course_Schedule_On_Conflict = {
  constraint: Course_Schedule_Constraint;
  update_columns?: Array<Course_Schedule_Update_Column>;
  where?: InputMaybe<Course_Schedule_Bool_Exp>;
};

/** Ordering options when selecting data from "course_schedule". */
export type Course_Schedule_Order_By = {
  course?: InputMaybe<Course_Order_By>;
  course_id?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  end?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  start?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  venue?: InputMaybe<Venue_Order_By>;
  venue_id?: InputMaybe<Order_By>;
  virtualLink?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_schedule */
export type Course_Schedule_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_schedule" */
export enum Course_Schedule_Select_Column {
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  End = 'end',
  /** column name */
  Id = 'id',
  /** column name */
  Start = 'start',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venue_id',
  /** column name */
  VirtualLink = 'virtualLink'
}

/** input type for updating data in table "course_schedule" */
export type Course_Schedule_Set_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  end?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  start?: InputMaybe<Scalars['timestamptz']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  venue_id?: InputMaybe<Scalars['uuid']>;
  virtualLink?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Course_Schedule_Stddev_Fields = {
  __typename?: 'course_schedule_stddev_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "course_schedule" */
export type Course_Schedule_Stddev_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Course_Schedule_Stddev_Pop_Fields = {
  __typename?: 'course_schedule_stddev_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "course_schedule" */
export type Course_Schedule_Stddev_Pop_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Course_Schedule_Stddev_Samp_Fields = {
  __typename?: 'course_schedule_stddev_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "course_schedule" */
export type Course_Schedule_Stddev_Samp_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Course_Schedule_Sum_Fields = {
  __typename?: 'course_schedule_sum_fields';
  course_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "course_schedule" */
export type Course_Schedule_Sum_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** update columns of table "course_schedule" */
export enum Course_Schedule_Update_Column {
  /** column name */
  CourseId = 'course_id',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  End = 'end',
  /** column name */
  Id = 'id',
  /** column name */
  Start = 'start',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VenueId = 'venue_id',
  /** column name */
  VirtualLink = 'virtualLink'
}

/** aggregate var_pop on columns */
export type Course_Schedule_Var_Pop_Fields = {
  __typename?: 'course_schedule_var_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "course_schedule" */
export type Course_Schedule_Var_Pop_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Course_Schedule_Var_Samp_Fields = {
  __typename?: 'course_schedule_var_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "course_schedule" */
export type Course_Schedule_Var_Samp_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Course_Schedule_Variance_Fields = {
  __typename?: 'course_schedule_variance_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "course_schedule" */
export type Course_Schedule_Variance_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** select columns of table "course" */
export enum Course_Select_Column {
  /** column name */
  AccountCode = 'accountCode',
  /** column name */
  AolCostOfCourse = 'aolCostOfCourse',
  /** column name */
  AolCountry = 'aolCountry',
  /** column name */
  AolRegion = 'aolRegion',
  /** column name */
  CancellationFeePercent = 'cancellationFeePercent',
  /** column name */
  CancellationReason = 'cancellationReason',
  /** column name */
  ContactProfileId = 'contactProfileId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeliveryType = 'deliveryType',
  /** column name */
  Description = 'description',
  /** column name */
  FreeSpaces = 'freeSpaces',
  /** column name */
  Go1Integration = 'go1Integration',
  /** column name */
  GradingConfirmed = 'gradingConfirmed',
  /** column name */
  GradingStarted = 'gradingStarted',
  /** column name */
  Id = 'id',
  /** column name */
  Level = 'level',
  /** column name */
  MaxParticipants = 'max_participants',
  /** column name */
  MinParticipants = 'min_participants',
  /** column name */
  ModulesDuration = 'modulesDuration',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  Reaccreditation = 'reaccreditation',
  /** column name */
  SalesRepresentativeId = 'salesRepresentativeId',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "course" */
export type Course_Set_Input = {
  accountCode?: InputMaybe<Scalars['String']>;
  aolCostOfCourse?: InputMaybe<Scalars['numeric']>;
  aolCountry?: InputMaybe<Scalars['String']>;
  aolRegion?: InputMaybe<Scalars['String']>;
  cancellationFeePercent?: InputMaybe<Scalars['Int']>;
  cancellationReason?: InputMaybe<Scalars['String']>;
  contactProfileId?: InputMaybe<Scalars['uuid']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  deliveryType?: InputMaybe<Course_Delivery_Type_Enum>;
  description?: InputMaybe<Scalars['String']>;
  freeSpaces?: InputMaybe<Scalars['Int']>;
  go1Integration?: InputMaybe<Scalars['Boolean']>;
  gradingConfirmed?: InputMaybe<Scalars['Boolean']>;
  gradingStarted?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['Int']>;
  level?: InputMaybe<Course_Level_Enum>;
  max_participants?: InputMaybe<Scalars['Int']>;
  min_participants?: InputMaybe<Scalars['Int']>;
  modulesDuration?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  notes?: InputMaybe<Scalars['String']>;
  organization_id?: InputMaybe<Scalars['uuid']>;
  reaccreditation?: InputMaybe<Scalars['Boolean']>;
  salesRepresentativeId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<Course_Status_Enum>;
  type?: InputMaybe<Course_Type_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** columns and relationships of "course_status" */
export type Course_Status = {
  __typename?: 'course_status';
  name: Scalars['String'];
};

/** aggregated selection of "course_status" */
export type Course_Status_Aggregate = {
  __typename?: 'course_status_aggregate';
  aggregate?: Maybe<Course_Status_Aggregate_Fields>;
  nodes: Array<Course_Status>;
};

/** aggregate fields of "course_status" */
export type Course_Status_Aggregate_Fields = {
  __typename?: 'course_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Status_Max_Fields>;
  min?: Maybe<Course_Status_Min_Fields>;
};


/** aggregate fields of "course_status" */
export type Course_Status_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Status_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "course_status". All fields are combined with a logical 'AND'. */
export type Course_Status_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Status_Bool_Exp>>;
  _not?: InputMaybe<Course_Status_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Status_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_status" */
export enum Course_Status_Constraint {
  /** unique or primary key constraint */
  CourseStatusPkey = 'course_status_pkey'
}

export enum Course_Status_Enum {
  ApprovalPending = 'APPROVAL_PENDING',
  Cancelled = 'CANCELLED',
  Completed = 'COMPLETED',
  ConfirmModules = 'CONFIRM_MODULES',
  Declined = 'DECLINED',
  Draft = 'DRAFT',
  EvaluationMissing = 'EVALUATION_MISSING',
  ExceptionsApprovalPending = 'EXCEPTIONS_APPROVAL_PENDING',
  GradeMissing = 'GRADE_MISSING',
  Scheduled = 'SCHEDULED',
  TrainerMissing = 'TRAINER_MISSING',
  TrainerPending = 'TRAINER_PENDING',
  TrainerUnavailable = 'TRAINER_UNAVAILABLE'
}

/** Boolean expression to compare columns of type "course_status_enum". All fields are combined with logical 'AND'. */
export type Course_Status_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Course_Status_Enum>;
  _in?: InputMaybe<Array<Course_Status_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Course_Status_Enum>;
  _nin?: InputMaybe<Array<Course_Status_Enum>>;
};

/** input type for inserting data into table "course_status" */
export type Course_Status_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Status_Max_Fields = {
  __typename?: 'course_status_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Status_Min_Fields = {
  __typename?: 'course_status_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_status" */
export type Course_Status_Mutation_Response = {
  __typename?: 'course_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Status>;
};

/** on_conflict condition type for table "course_status" */
export type Course_Status_On_Conflict = {
  constraint: Course_Status_Constraint;
  update_columns?: Array<Course_Status_Update_Column>;
  where?: InputMaybe<Course_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "course_status". */
export type Course_Status_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_status */
export type Course_Status_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "course_status" */
export enum Course_Status_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "course_status" */
export type Course_Status_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "course_status" */
export enum Course_Status_Update_Column {
  /** column name */
  Name = 'name'
}

/** aggregate stddev on columns */
export type Course_Stddev_Fields = {
  __typename?: 'course_stddev_fields';
  aolCostOfCourse?: Maybe<Scalars['Float']>;
  cancellationFeePercent?: Maybe<Scalars['Float']>;
  freeSpaces?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_participants?: Maybe<Scalars['Float']>;
  min_participants?: Maybe<Scalars['Float']>;
  modulesDuration?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "course" */
export type Course_Stddev_Order_By = {
  aolCostOfCourse?: InputMaybe<Order_By>;
  cancellationFeePercent?: InputMaybe<Order_By>;
  freeSpaces?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  max_participants?: InputMaybe<Order_By>;
  min_participants?: InputMaybe<Order_By>;
  modulesDuration?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Course_Stddev_Pop_Fields = {
  __typename?: 'course_stddev_pop_fields';
  aolCostOfCourse?: Maybe<Scalars['Float']>;
  cancellationFeePercent?: Maybe<Scalars['Float']>;
  freeSpaces?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_participants?: Maybe<Scalars['Float']>;
  min_participants?: Maybe<Scalars['Float']>;
  modulesDuration?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "course" */
export type Course_Stddev_Pop_Order_By = {
  aolCostOfCourse?: InputMaybe<Order_By>;
  cancellationFeePercent?: InputMaybe<Order_By>;
  freeSpaces?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  max_participants?: InputMaybe<Order_By>;
  min_participants?: InputMaybe<Order_By>;
  modulesDuration?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Course_Stddev_Samp_Fields = {
  __typename?: 'course_stddev_samp_fields';
  aolCostOfCourse?: Maybe<Scalars['Float']>;
  cancellationFeePercent?: Maybe<Scalars['Float']>;
  freeSpaces?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_participants?: Maybe<Scalars['Float']>;
  min_participants?: Maybe<Scalars['Float']>;
  modulesDuration?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "course" */
export type Course_Stddev_Samp_Order_By = {
  aolCostOfCourse?: InputMaybe<Order_By>;
  cancellationFeePercent?: InputMaybe<Order_By>;
  freeSpaces?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  max_participants?: InputMaybe<Order_By>;
  min_participants?: InputMaybe<Order_By>;
  modulesDuration?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Course_Sum_Fields = {
  __typename?: 'course_sum_fields';
  aolCostOfCourse?: Maybe<Scalars['numeric']>;
  cancellationFeePercent?: Maybe<Scalars['Int']>;
  freeSpaces?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  max_participants?: Maybe<Scalars['Int']>;
  min_participants?: Maybe<Scalars['Int']>;
  modulesDuration?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "course" */
export type Course_Sum_Order_By = {
  aolCostOfCourse?: InputMaybe<Order_By>;
  cancellationFeePercent?: InputMaybe<Order_By>;
  freeSpaces?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  max_participants?: InputMaybe<Order_By>;
  min_participants?: InputMaybe<Order_By>;
  modulesDuration?: InputMaybe<Order_By>;
};

/** columns and relationships of "course_trainer" */
export type Course_Trainer = {
  __typename?: 'course_trainer';
  /** An object relationship */
  course: Course;
  course_id: Scalars['Int'];
  id: Scalars['uuid'];
  /** An object relationship */
  profile: Profile;
  profile_id: Scalars['uuid'];
  status?: Maybe<Course_Invite_Status_Enum>;
  type: Course_Trainer_Type_Enum;
};

/** aggregated selection of "course_trainer" */
export type Course_Trainer_Aggregate = {
  __typename?: 'course_trainer_aggregate';
  aggregate?: Maybe<Course_Trainer_Aggregate_Fields>;
  nodes: Array<Course_Trainer>;
};

/** aggregate fields of "course_trainer" */
export type Course_Trainer_Aggregate_Fields = {
  __typename?: 'course_trainer_aggregate_fields';
  avg?: Maybe<Course_Trainer_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Course_Trainer_Max_Fields>;
  min?: Maybe<Course_Trainer_Min_Fields>;
  stddev?: Maybe<Course_Trainer_Stddev_Fields>;
  stddev_pop?: Maybe<Course_Trainer_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Course_Trainer_Stddev_Samp_Fields>;
  sum?: Maybe<Course_Trainer_Sum_Fields>;
  var_pop?: Maybe<Course_Trainer_Var_Pop_Fields>;
  var_samp?: Maybe<Course_Trainer_Var_Samp_Fields>;
  variance?: Maybe<Course_Trainer_Variance_Fields>;
};


/** aggregate fields of "course_trainer" */
export type Course_Trainer_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Trainer_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "course_trainer" */
export type Course_Trainer_Aggregate_Order_By = {
  avg?: InputMaybe<Course_Trainer_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Course_Trainer_Max_Order_By>;
  min?: InputMaybe<Course_Trainer_Min_Order_By>;
  stddev?: InputMaybe<Course_Trainer_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Course_Trainer_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Course_Trainer_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Course_Trainer_Sum_Order_By>;
  var_pop?: InputMaybe<Course_Trainer_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Course_Trainer_Var_Samp_Order_By>;
  variance?: InputMaybe<Course_Trainer_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "course_trainer" */
export type Course_Trainer_Arr_Rel_Insert_Input = {
  data: Array<Course_Trainer_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Course_Trainer_On_Conflict>;
};

/** aggregate avg on columns */
export type Course_Trainer_Avg_Fields = {
  __typename?: 'course_trainer_avg_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "course_trainer" */
export type Course_Trainer_Avg_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "course_trainer". All fields are combined with a logical 'AND'. */
export type Course_Trainer_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Trainer_Bool_Exp>>;
  _not?: InputMaybe<Course_Trainer_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Trainer_Bool_Exp>>;
  course?: InputMaybe<Course_Bool_Exp>;
  course_id?: InputMaybe<Int_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profile_id?: InputMaybe<Uuid_Comparison_Exp>;
  status?: InputMaybe<Course_Invite_Status_Enum_Comparison_Exp>;
  type?: InputMaybe<Course_Trainer_Type_Enum_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_trainer" */
export enum Course_Trainer_Constraint {
  /** unique or primary key constraint */
  CourseLeaderPkey = 'course_leader_pkey',
  /** unique or primary key constraint */
  CourseTrainerCourseIdProfileIdKey = 'course_trainer_course_id_profile_id_key',
  /** unique or primary key constraint */
  CourseTrainerUniqueLeader = 'course_trainer_unique_leader'
}

/** input type for incrementing numeric columns in table "course_trainer" */
export type Course_Trainer_Inc_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "course_trainer" */
export type Course_Trainer_Insert_Input = {
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  course_id?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<Course_Invite_Status_Enum>;
  type?: InputMaybe<Course_Trainer_Type_Enum>;
};

/** aggregate max on columns */
export type Course_Trainer_Max_Fields = {
  __typename?: 'course_trainer_max_fields';
  course_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "course_trainer" */
export type Course_Trainer_Max_Order_By = {
  course_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Course_Trainer_Min_Fields = {
  __typename?: 'course_trainer_min_fields';
  course_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "course_trainer" */
export type Course_Trainer_Min_Order_By = {
  course_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "course_trainer" */
export type Course_Trainer_Mutation_Response = {
  __typename?: 'course_trainer_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Trainer>;
};

/** on_conflict condition type for table "course_trainer" */
export type Course_Trainer_On_Conflict = {
  constraint: Course_Trainer_Constraint;
  update_columns?: Array<Course_Trainer_Update_Column>;
  where?: InputMaybe<Course_Trainer_Bool_Exp>;
};

/** Ordering options when selecting data from "course_trainer". */
export type Course_Trainer_Order_By = {
  course?: InputMaybe<Course_Order_By>;
  course_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profile_id?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_trainer */
export type Course_Trainer_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_trainer" */
export enum Course_Trainer_Select_Column {
  /** column name */
  CourseId = 'course_id',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "course_trainer" */
export type Course_Trainer_Set_Input = {
  course_id?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<Course_Invite_Status_Enum>;
  type?: InputMaybe<Course_Trainer_Type_Enum>;
};

/** aggregate stddev on columns */
export type Course_Trainer_Stddev_Fields = {
  __typename?: 'course_trainer_stddev_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "course_trainer" */
export type Course_Trainer_Stddev_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Course_Trainer_Stddev_Pop_Fields = {
  __typename?: 'course_trainer_stddev_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "course_trainer" */
export type Course_Trainer_Stddev_Pop_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Course_Trainer_Stddev_Samp_Fields = {
  __typename?: 'course_trainer_stddev_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "course_trainer" */
export type Course_Trainer_Stddev_Samp_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Course_Trainer_Sum_Fields = {
  __typename?: 'course_trainer_sum_fields';
  course_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "course_trainer" */
export type Course_Trainer_Sum_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "course_trainer_type" */
export type Course_Trainer_Type = {
  __typename?: 'course_trainer_type';
  name: Scalars['String'];
};

/** aggregated selection of "course_trainer_type" */
export type Course_Trainer_Type_Aggregate = {
  __typename?: 'course_trainer_type_aggregate';
  aggregate?: Maybe<Course_Trainer_Type_Aggregate_Fields>;
  nodes: Array<Course_Trainer_Type>;
};

/** aggregate fields of "course_trainer_type" */
export type Course_Trainer_Type_Aggregate_Fields = {
  __typename?: 'course_trainer_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Trainer_Type_Max_Fields>;
  min?: Maybe<Course_Trainer_Type_Min_Fields>;
};


/** aggregate fields of "course_trainer_type" */
export type Course_Trainer_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Trainer_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "course_trainer_type". All fields are combined with a logical 'AND'. */
export type Course_Trainer_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Trainer_Type_Bool_Exp>>;
  _not?: InputMaybe<Course_Trainer_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Trainer_Type_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_trainer_type" */
export enum Course_Trainer_Type_Constraint {
  /** unique or primary key constraint */
  CourseTrainerTypePkey = 'course_trainer_type_pkey'
}

export enum Course_Trainer_Type_Enum {
  Assistant = 'ASSISTANT',
  Leader = 'LEADER',
  Moderator = 'MODERATOR'
}

/** Boolean expression to compare columns of type "course_trainer_type_enum". All fields are combined with logical 'AND'. */
export type Course_Trainer_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Course_Trainer_Type_Enum>;
  _in?: InputMaybe<Array<Course_Trainer_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Course_Trainer_Type_Enum>;
  _nin?: InputMaybe<Array<Course_Trainer_Type_Enum>>;
};

/** input type for inserting data into table "course_trainer_type" */
export type Course_Trainer_Type_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Trainer_Type_Max_Fields = {
  __typename?: 'course_trainer_type_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Trainer_Type_Min_Fields = {
  __typename?: 'course_trainer_type_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_trainer_type" */
export type Course_Trainer_Type_Mutation_Response = {
  __typename?: 'course_trainer_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Trainer_Type>;
};

/** on_conflict condition type for table "course_trainer_type" */
export type Course_Trainer_Type_On_Conflict = {
  constraint: Course_Trainer_Type_Constraint;
  update_columns?: Array<Course_Trainer_Type_Update_Column>;
  where?: InputMaybe<Course_Trainer_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "course_trainer_type". */
export type Course_Trainer_Type_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_trainer_type */
export type Course_Trainer_Type_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "course_trainer_type" */
export enum Course_Trainer_Type_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "course_trainer_type" */
export type Course_Trainer_Type_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "course_trainer_type" */
export enum Course_Trainer_Type_Update_Column {
  /** column name */
  Name = 'name'
}

/** update columns of table "course_trainer" */
export enum Course_Trainer_Update_Column {
  /** column name */
  CourseId = 'course_id',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type'
}

/** aggregate var_pop on columns */
export type Course_Trainer_Var_Pop_Fields = {
  __typename?: 'course_trainer_var_pop_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "course_trainer" */
export type Course_Trainer_Var_Pop_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Course_Trainer_Var_Samp_Fields = {
  __typename?: 'course_trainer_var_samp_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "course_trainer" */
export type Course_Trainer_Var_Samp_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Course_Trainer_Variance_Fields = {
  __typename?: 'course_trainer_variance_fields';
  course_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "course_trainer" */
export type Course_Trainer_Variance_Order_By = {
  course_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "course_type" */
export type Course_Type = {
  __typename?: 'course_type';
  name: Scalars['String'];
};

/** aggregated selection of "course_type" */
export type Course_Type_Aggregate = {
  __typename?: 'course_type_aggregate';
  aggregate?: Maybe<Course_Type_Aggregate_Fields>;
  nodes: Array<Course_Type>;
};

/** aggregate fields of "course_type" */
export type Course_Type_Aggregate_Fields = {
  __typename?: 'course_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Type_Max_Fields>;
  min?: Maybe<Course_Type_Min_Fields>;
};


/** aggregate fields of "course_type" */
export type Course_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "course_type". All fields are combined with a logical 'AND'. */
export type Course_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Type_Bool_Exp>>;
  _not?: InputMaybe<Course_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Type_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_type" */
export enum Course_Type_Constraint {
  /** unique or primary key constraint */
  CourseTypePkey = 'course_type_pkey'
}

export enum Course_Type_Enum {
  Closed = 'CLOSED',
  Indirect = 'INDIRECT',
  Open = 'OPEN'
}

/** Boolean expression to compare columns of type "course_type_enum". All fields are combined with logical 'AND'. */
export type Course_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Course_Type_Enum>;
  _in?: InputMaybe<Array<Course_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Course_Type_Enum>;
  _nin?: InputMaybe<Array<Course_Type_Enum>>;
};

/** input type for inserting data into table "course_type" */
export type Course_Type_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Type_Max_Fields = {
  __typename?: 'course_type_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Type_Min_Fields = {
  __typename?: 'course_type_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_type" */
export type Course_Type_Mutation_Response = {
  __typename?: 'course_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Type>;
};

/** on_conflict condition type for table "course_type" */
export type Course_Type_On_Conflict = {
  constraint: Course_Type_Constraint;
  update_columns?: Array<Course_Type_Update_Column>;
  where?: InputMaybe<Course_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "course_type". */
export type Course_Type_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_type */
export type Course_Type_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** Course types with their prefixes (used to generate course codes) */
export type Course_Type_Prefix = {
  __typename?: 'course_type_prefix';
  id: Scalars['uuid'];
  name: Scalars['String'];
  prefix: Scalars['String'];
};

/** aggregated selection of "course_type_prefix" */
export type Course_Type_Prefix_Aggregate = {
  __typename?: 'course_type_prefix_aggregate';
  aggregate?: Maybe<Course_Type_Prefix_Aggregate_Fields>;
  nodes: Array<Course_Type_Prefix>;
};

/** aggregate fields of "course_type_prefix" */
export type Course_Type_Prefix_Aggregate_Fields = {
  __typename?: 'course_type_prefix_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Course_Type_Prefix_Max_Fields>;
  min?: Maybe<Course_Type_Prefix_Min_Fields>;
};


/** aggregate fields of "course_type_prefix" */
export type Course_Type_Prefix_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Course_Type_Prefix_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "course_type_prefix". All fields are combined with a logical 'AND'. */
export type Course_Type_Prefix_Bool_Exp = {
  _and?: InputMaybe<Array<Course_Type_Prefix_Bool_Exp>>;
  _not?: InputMaybe<Course_Type_Prefix_Bool_Exp>;
  _or?: InputMaybe<Array<Course_Type_Prefix_Bool_Exp>>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  prefix?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "course_type_prefix" */
export enum Course_Type_Prefix_Constraint {
  /** unique or primary key constraint */
  CourseTypePrefixNameKey = 'course_type_prefix_name_key',
  /** unique or primary key constraint */
  CourseTypePrefixPkey = 'course_type_prefix_pkey',
  /** unique or primary key constraint */
  CourseTypePrefixPrefixKey = 'course_type_prefix_prefix_key'
}

/** input type for inserting data into table "course_type_prefix" */
export type Course_Type_Prefix_Insert_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  prefix?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Course_Type_Prefix_Max_Fields = {
  __typename?: 'course_type_prefix_max_fields';
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  prefix?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Course_Type_Prefix_Min_Fields = {
  __typename?: 'course_type_prefix_min_fields';
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  prefix?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "course_type_prefix" */
export type Course_Type_Prefix_Mutation_Response = {
  __typename?: 'course_type_prefix_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Course_Type_Prefix>;
};

/** on_conflict condition type for table "course_type_prefix" */
export type Course_Type_Prefix_On_Conflict = {
  constraint: Course_Type_Prefix_Constraint;
  update_columns?: Array<Course_Type_Prefix_Update_Column>;
  where?: InputMaybe<Course_Type_Prefix_Bool_Exp>;
};

/** Ordering options when selecting data from "course_type_prefix". */
export type Course_Type_Prefix_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  prefix?: InputMaybe<Order_By>;
};

/** primary key columns input for table: course_type_prefix */
export type Course_Type_Prefix_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "course_type_prefix" */
export enum Course_Type_Prefix_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Prefix = 'prefix'
}

/** input type for updating data in table "course_type_prefix" */
export type Course_Type_Prefix_Set_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  prefix?: InputMaybe<Scalars['String']>;
};

/** update columns of table "course_type_prefix" */
export enum Course_Type_Prefix_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Prefix = 'prefix'
}

/** select columns of table "course_type" */
export enum Course_Type_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "course_type" */
export type Course_Type_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "course_type" */
export enum Course_Type_Update_Column {
  /** column name */
  Name = 'name'
}

/** update columns of table "course" */
export enum Course_Update_Column {
  /** column name */
  AccountCode = 'accountCode',
  /** column name */
  AolCostOfCourse = 'aolCostOfCourse',
  /** column name */
  AolCountry = 'aolCountry',
  /** column name */
  AolRegion = 'aolRegion',
  /** column name */
  CancellationFeePercent = 'cancellationFeePercent',
  /** column name */
  CancellationReason = 'cancellationReason',
  /** column name */
  ContactProfileId = 'contactProfileId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DeliveryType = 'deliveryType',
  /** column name */
  Description = 'description',
  /** column name */
  FreeSpaces = 'freeSpaces',
  /** column name */
  Go1Integration = 'go1Integration',
  /** column name */
  GradingConfirmed = 'gradingConfirmed',
  /** column name */
  GradingStarted = 'gradingStarted',
  /** column name */
  Id = 'id',
  /** column name */
  Level = 'level',
  /** column name */
  MaxParticipants = 'max_participants',
  /** column name */
  MinParticipants = 'min_participants',
  /** column name */
  ModulesDuration = 'modulesDuration',
  /** column name */
  Name = 'name',
  /** column name */
  Notes = 'notes',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  Reaccreditation = 'reaccreditation',
  /** column name */
  SalesRepresentativeId = 'salesRepresentativeId',
  /** column name */
  Status = 'status',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Course_Var_Pop_Fields = {
  __typename?: 'course_var_pop_fields';
  aolCostOfCourse?: Maybe<Scalars['Float']>;
  cancellationFeePercent?: Maybe<Scalars['Float']>;
  freeSpaces?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_participants?: Maybe<Scalars['Float']>;
  min_participants?: Maybe<Scalars['Float']>;
  modulesDuration?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "course" */
export type Course_Var_Pop_Order_By = {
  aolCostOfCourse?: InputMaybe<Order_By>;
  cancellationFeePercent?: InputMaybe<Order_By>;
  freeSpaces?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  max_participants?: InputMaybe<Order_By>;
  min_participants?: InputMaybe<Order_By>;
  modulesDuration?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Course_Var_Samp_Fields = {
  __typename?: 'course_var_samp_fields';
  aolCostOfCourse?: Maybe<Scalars['Float']>;
  cancellationFeePercent?: Maybe<Scalars['Float']>;
  freeSpaces?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_participants?: Maybe<Scalars['Float']>;
  min_participants?: Maybe<Scalars['Float']>;
  modulesDuration?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "course" */
export type Course_Var_Samp_Order_By = {
  aolCostOfCourse?: InputMaybe<Order_By>;
  cancellationFeePercent?: InputMaybe<Order_By>;
  freeSpaces?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  max_participants?: InputMaybe<Order_By>;
  min_participants?: InputMaybe<Order_By>;
  modulesDuration?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Course_Variance_Fields = {
  __typename?: 'course_variance_fields';
  aolCostOfCourse?: Maybe<Scalars['Float']>;
  cancellationFeePercent?: Maybe<Scalars['Float']>;
  freeSpaces?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  max_participants?: Maybe<Scalars['Float']>;
  min_participants?: Maybe<Scalars['Float']>;
  modulesDuration?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "course" */
export type Course_Variance_Order_By = {
  aolCostOfCourse?: InputMaybe<Order_By>;
  cancellationFeePercent?: InputMaybe<Order_By>;
  freeSpaces?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  max_participants?: InputMaybe<Order_By>;
  min_participants?: InputMaybe<Order_By>;
  modulesDuration?: InputMaybe<Order_By>;
};

export type CreateSubscriptionOutput = {
  __typename?: 'createSubscriptionOutput';
  clientSecret: Scalars['String'];
  subscriptionId: Scalars['String'];
};

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type Date_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['date']>;
  _gt?: InputMaybe<Scalars['date']>;
  _gte?: InputMaybe<Scalars['date']>;
  _in?: InputMaybe<Array<Scalars['date']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['date']>;
  _lte?: InputMaybe<Scalars['date']>;
  _neq?: InputMaybe<Scalars['date']>;
  _nin?: InputMaybe<Array<Scalars['date']>>;
};

/** columns and relationships of "dfe_establishment" */
export type Dfe_Establishment = {
  __typename?: 'dfe_establishment';
  addressLineOne?: Maybe<Scalars['String']>;
  addressLineThree?: Maybe<Scalars['String']>;
  addressLineTwo?: Maybe<Scalars['String']>;
  county?: Maybe<Scalars['String']>;
  headFirstName?: Maybe<Scalars['String']>;
  headJobTitle?: Maybe<Scalars['String']>;
  headLastName?: Maybe<Scalars['String']>;
  headTitle?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  localAuthority: Scalars['String'];
  name: Scalars['String'];
  ofstedLastInspection?: Maybe<Scalars['String']>;
  ofstedRating?: Maybe<Scalars['String']>;
  postcode?: Maybe<Scalars['String']>;
  town?: Maybe<Scalars['String']>;
  trustName?: Maybe<Scalars['String']>;
  trustType?: Maybe<Scalars['String']>;
  urn: Scalars['String'];
};

/** aggregated selection of "dfe_establishment" */
export type Dfe_Establishment_Aggregate = {
  __typename?: 'dfe_establishment_aggregate';
  aggregate?: Maybe<Dfe_Establishment_Aggregate_Fields>;
  nodes: Array<Dfe_Establishment>;
};

/** aggregate fields of "dfe_establishment" */
export type Dfe_Establishment_Aggregate_Fields = {
  __typename?: 'dfe_establishment_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Dfe_Establishment_Max_Fields>;
  min?: Maybe<Dfe_Establishment_Min_Fields>;
};


/** aggregate fields of "dfe_establishment" */
export type Dfe_Establishment_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Dfe_Establishment_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "dfe_establishment". All fields are combined with a logical 'AND'. */
export type Dfe_Establishment_Bool_Exp = {
  _and?: InputMaybe<Array<Dfe_Establishment_Bool_Exp>>;
  _not?: InputMaybe<Dfe_Establishment_Bool_Exp>;
  _or?: InputMaybe<Array<Dfe_Establishment_Bool_Exp>>;
  addressLineOne?: InputMaybe<String_Comparison_Exp>;
  addressLineThree?: InputMaybe<String_Comparison_Exp>;
  addressLineTwo?: InputMaybe<String_Comparison_Exp>;
  county?: InputMaybe<String_Comparison_Exp>;
  headFirstName?: InputMaybe<String_Comparison_Exp>;
  headJobTitle?: InputMaybe<String_Comparison_Exp>;
  headLastName?: InputMaybe<String_Comparison_Exp>;
  headTitle?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  localAuthority?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  ofstedLastInspection?: InputMaybe<String_Comparison_Exp>;
  ofstedRating?: InputMaybe<String_Comparison_Exp>;
  postcode?: InputMaybe<String_Comparison_Exp>;
  town?: InputMaybe<String_Comparison_Exp>;
  trustName?: InputMaybe<String_Comparison_Exp>;
  trustType?: InputMaybe<String_Comparison_Exp>;
  urn?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "dfe_establishment" */
export enum Dfe_Establishment_Constraint {
  /** unique or primary key constraint */
  DfeEstablishmentPkey = 'dfe_establishment_pkey'
}

/** input type for inserting data into table "dfe_establishment" */
export type Dfe_Establishment_Insert_Input = {
  addressLineOne?: InputMaybe<Scalars['String']>;
  addressLineThree?: InputMaybe<Scalars['String']>;
  addressLineTwo?: InputMaybe<Scalars['String']>;
  county?: InputMaybe<Scalars['String']>;
  headFirstName?: InputMaybe<Scalars['String']>;
  headJobTitle?: InputMaybe<Scalars['String']>;
  headLastName?: InputMaybe<Scalars['String']>;
  headTitle?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  localAuthority?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  ofstedLastInspection?: InputMaybe<Scalars['String']>;
  ofstedRating?: InputMaybe<Scalars['String']>;
  postcode?: InputMaybe<Scalars['String']>;
  town?: InputMaybe<Scalars['String']>;
  trustName?: InputMaybe<Scalars['String']>;
  trustType?: InputMaybe<Scalars['String']>;
  urn?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Dfe_Establishment_Max_Fields = {
  __typename?: 'dfe_establishment_max_fields';
  addressLineOne?: Maybe<Scalars['String']>;
  addressLineThree?: Maybe<Scalars['String']>;
  addressLineTwo?: Maybe<Scalars['String']>;
  county?: Maybe<Scalars['String']>;
  headFirstName?: Maybe<Scalars['String']>;
  headJobTitle?: Maybe<Scalars['String']>;
  headLastName?: Maybe<Scalars['String']>;
  headTitle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  localAuthority?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  ofstedLastInspection?: Maybe<Scalars['String']>;
  ofstedRating?: Maybe<Scalars['String']>;
  postcode?: Maybe<Scalars['String']>;
  town?: Maybe<Scalars['String']>;
  trustName?: Maybe<Scalars['String']>;
  trustType?: Maybe<Scalars['String']>;
  urn?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Dfe_Establishment_Min_Fields = {
  __typename?: 'dfe_establishment_min_fields';
  addressLineOne?: Maybe<Scalars['String']>;
  addressLineThree?: Maybe<Scalars['String']>;
  addressLineTwo?: Maybe<Scalars['String']>;
  county?: Maybe<Scalars['String']>;
  headFirstName?: Maybe<Scalars['String']>;
  headJobTitle?: Maybe<Scalars['String']>;
  headLastName?: Maybe<Scalars['String']>;
  headTitle?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  localAuthority?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  ofstedLastInspection?: Maybe<Scalars['String']>;
  ofstedRating?: Maybe<Scalars['String']>;
  postcode?: Maybe<Scalars['String']>;
  town?: Maybe<Scalars['String']>;
  trustName?: Maybe<Scalars['String']>;
  trustType?: Maybe<Scalars['String']>;
  urn?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "dfe_establishment" */
export type Dfe_Establishment_Mutation_Response = {
  __typename?: 'dfe_establishment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dfe_Establishment>;
};

/** on_conflict condition type for table "dfe_establishment" */
export type Dfe_Establishment_On_Conflict = {
  constraint: Dfe_Establishment_Constraint;
  update_columns?: Array<Dfe_Establishment_Update_Column>;
  where?: InputMaybe<Dfe_Establishment_Bool_Exp>;
};

/** Ordering options when selecting data from "dfe_establishment". */
export type Dfe_Establishment_Order_By = {
  addressLineOne?: InputMaybe<Order_By>;
  addressLineThree?: InputMaybe<Order_By>;
  addressLineTwo?: InputMaybe<Order_By>;
  county?: InputMaybe<Order_By>;
  headFirstName?: InputMaybe<Order_By>;
  headJobTitle?: InputMaybe<Order_By>;
  headLastName?: InputMaybe<Order_By>;
  headTitle?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  localAuthority?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  ofstedLastInspection?: InputMaybe<Order_By>;
  ofstedRating?: InputMaybe<Order_By>;
  postcode?: InputMaybe<Order_By>;
  town?: InputMaybe<Order_By>;
  trustName?: InputMaybe<Order_By>;
  trustType?: InputMaybe<Order_By>;
  urn?: InputMaybe<Order_By>;
};

/** primary key columns input for table: dfe_establishment */
export type Dfe_Establishment_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "dfe_establishment" */
export enum Dfe_Establishment_Select_Column {
  /** column name */
  AddressLineOne = 'addressLineOne',
  /** column name */
  AddressLineThree = 'addressLineThree',
  /** column name */
  AddressLineTwo = 'addressLineTwo',
  /** column name */
  County = 'county',
  /** column name */
  HeadFirstName = 'headFirstName',
  /** column name */
  HeadJobTitle = 'headJobTitle',
  /** column name */
  HeadLastName = 'headLastName',
  /** column name */
  HeadTitle = 'headTitle',
  /** column name */
  Id = 'id',
  /** column name */
  LocalAuthority = 'localAuthority',
  /** column name */
  Name = 'name',
  /** column name */
  OfstedLastInspection = 'ofstedLastInspection',
  /** column name */
  OfstedRating = 'ofstedRating',
  /** column name */
  Postcode = 'postcode',
  /** column name */
  Town = 'town',
  /** column name */
  TrustName = 'trustName',
  /** column name */
  TrustType = 'trustType',
  /** column name */
  Urn = 'urn'
}

/** input type for updating data in table "dfe_establishment" */
export type Dfe_Establishment_Set_Input = {
  addressLineOne?: InputMaybe<Scalars['String']>;
  addressLineThree?: InputMaybe<Scalars['String']>;
  addressLineTwo?: InputMaybe<Scalars['String']>;
  county?: InputMaybe<Scalars['String']>;
  headFirstName?: InputMaybe<Scalars['String']>;
  headJobTitle?: InputMaybe<Scalars['String']>;
  headLastName?: InputMaybe<Scalars['String']>;
  headTitle?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  localAuthority?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  ofstedLastInspection?: InputMaybe<Scalars['String']>;
  ofstedRating?: InputMaybe<Scalars['String']>;
  postcode?: InputMaybe<Scalars['String']>;
  town?: InputMaybe<Scalars['String']>;
  trustName?: InputMaybe<Scalars['String']>;
  trustType?: InputMaybe<Scalars['String']>;
  urn?: InputMaybe<Scalars['String']>;
};

/** update columns of table "dfe_establishment" */
export enum Dfe_Establishment_Update_Column {
  /** column name */
  AddressLineOne = 'addressLineOne',
  /** column name */
  AddressLineThree = 'addressLineThree',
  /** column name */
  AddressLineTwo = 'addressLineTwo',
  /** column name */
  County = 'county',
  /** column name */
  HeadFirstName = 'headFirstName',
  /** column name */
  HeadJobTitle = 'headJobTitle',
  /** column name */
  HeadLastName = 'headLastName',
  /** column name */
  HeadTitle = 'headTitle',
  /** column name */
  Id = 'id',
  /** column name */
  LocalAuthority = 'localAuthority',
  /** column name */
  Name = 'name',
  /** column name */
  OfstedLastInspection = 'ofstedLastInspection',
  /** column name */
  OfstedRating = 'ofstedRating',
  /** column name */
  Postcode = 'postcode',
  /** column name */
  Town = 'town',
  /** column name */
  TrustName = 'trustName',
  /** column name */
  TrustType = 'trustType',
  /** column name */
  Urn = 'urn'
}

/** Stores scheduled jobs ids for expiring Go1 licenses */
export type Expire_Go1_License_Jobs = {
  __typename?: 'expire_go1_license_jobs';
  id: Scalars['uuid'];
  jobId: Scalars['uuid'];
  licenseId: Scalars['uuid'];
};

/** aggregated selection of "expire_go1_license_jobs" */
export type Expire_Go1_License_Jobs_Aggregate = {
  __typename?: 'expire_go1_license_jobs_aggregate';
  aggregate?: Maybe<Expire_Go1_License_Jobs_Aggregate_Fields>;
  nodes: Array<Expire_Go1_License_Jobs>;
};

/** aggregate fields of "expire_go1_license_jobs" */
export type Expire_Go1_License_Jobs_Aggregate_Fields = {
  __typename?: 'expire_go1_license_jobs_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Expire_Go1_License_Jobs_Max_Fields>;
  min?: Maybe<Expire_Go1_License_Jobs_Min_Fields>;
};


/** aggregate fields of "expire_go1_license_jobs" */
export type Expire_Go1_License_Jobs_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Expire_Go1_License_Jobs_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "expire_go1_license_jobs". All fields are combined with a logical 'AND'. */
export type Expire_Go1_License_Jobs_Bool_Exp = {
  _and?: InputMaybe<Array<Expire_Go1_License_Jobs_Bool_Exp>>;
  _not?: InputMaybe<Expire_Go1_License_Jobs_Bool_Exp>;
  _or?: InputMaybe<Array<Expire_Go1_License_Jobs_Bool_Exp>>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  jobId?: InputMaybe<Uuid_Comparison_Exp>;
  licenseId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "expire_go1_license_jobs" */
export enum Expire_Go1_License_Jobs_Constraint {
  /** unique or primary key constraint */
  ExpireGo1LicenseJobsJobIdLicenseIdKey = 'expire_go1_license_jobs_job_id_license_id_key',
  /** unique or primary key constraint */
  ExpireGo1LicenseJobsPkey = 'expire_go1_license_jobs_pkey'
}

/** input type for inserting data into table "expire_go1_license_jobs" */
export type Expire_Go1_License_Jobs_Insert_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  jobId?: InputMaybe<Scalars['uuid']>;
  licenseId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Expire_Go1_License_Jobs_Max_Fields = {
  __typename?: 'expire_go1_license_jobs_max_fields';
  id?: Maybe<Scalars['uuid']>;
  jobId?: Maybe<Scalars['uuid']>;
  licenseId?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Expire_Go1_License_Jobs_Min_Fields = {
  __typename?: 'expire_go1_license_jobs_min_fields';
  id?: Maybe<Scalars['uuid']>;
  jobId?: Maybe<Scalars['uuid']>;
  licenseId?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "expire_go1_license_jobs" */
export type Expire_Go1_License_Jobs_Mutation_Response = {
  __typename?: 'expire_go1_license_jobs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Expire_Go1_License_Jobs>;
};

/** on_conflict condition type for table "expire_go1_license_jobs" */
export type Expire_Go1_License_Jobs_On_Conflict = {
  constraint: Expire_Go1_License_Jobs_Constraint;
  update_columns?: Array<Expire_Go1_License_Jobs_Update_Column>;
  where?: InputMaybe<Expire_Go1_License_Jobs_Bool_Exp>;
};

/** Ordering options when selecting data from "expire_go1_license_jobs". */
export type Expire_Go1_License_Jobs_Order_By = {
  id?: InputMaybe<Order_By>;
  jobId?: InputMaybe<Order_By>;
  licenseId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: expire_go1_license_jobs */
export type Expire_Go1_License_Jobs_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "expire_go1_license_jobs" */
export enum Expire_Go1_License_Jobs_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  JobId = 'jobId',
  /** column name */
  LicenseId = 'licenseId'
}

/** input type for updating data in table "expire_go1_license_jobs" */
export type Expire_Go1_License_Jobs_Set_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  jobId?: InputMaybe<Scalars['uuid']>;
  licenseId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "expire_go1_license_jobs" */
export enum Expire_Go1_License_Jobs_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  JobId = 'jobId',
  /** column name */
  LicenseId = 'licenseId'
}

/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['float8']>;
  _gt?: InputMaybe<Scalars['float8']>;
  _gte?: InputMaybe<Scalars['float8']>;
  _in?: InputMaybe<Array<Scalars['float8']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['float8']>;
  _lte?: InputMaybe<Scalars['float8']>;
  _neq?: InputMaybe<Scalars['float8']>;
  _nin?: InputMaybe<Array<Scalars['float8']>>;
};

/** Enum table for Go1 licensing changes events */
export type Go1_History_Events = {
  __typename?: 'go1_history_events';
  name: Scalars['String'];
};

/** aggregated selection of "go1_history_events" */
export type Go1_History_Events_Aggregate = {
  __typename?: 'go1_history_events_aggregate';
  aggregate?: Maybe<Go1_History_Events_Aggregate_Fields>;
  nodes: Array<Go1_History_Events>;
};

/** aggregate fields of "go1_history_events" */
export type Go1_History_Events_Aggregate_Fields = {
  __typename?: 'go1_history_events_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Go1_History_Events_Max_Fields>;
  min?: Maybe<Go1_History_Events_Min_Fields>;
};


/** aggregate fields of "go1_history_events" */
export type Go1_History_Events_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Go1_History_Events_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "go1_history_events". All fields are combined with a logical 'AND'. */
export type Go1_History_Events_Bool_Exp = {
  _and?: InputMaybe<Array<Go1_History_Events_Bool_Exp>>;
  _not?: InputMaybe<Go1_History_Events_Bool_Exp>;
  _or?: InputMaybe<Array<Go1_History_Events_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "go1_history_events" */
export enum Go1_History_Events_Constraint {
  /** unique or primary key constraint */
  Go1HistoryEventsPkey = 'go1_history_events_pkey'
}

export enum Go1_History_Events_Enum {
  LicensesAdded = 'LICENSES_ADDED',
  LicensesCancelled = 'LICENSES_CANCELLED',
  LicensesPurchased = 'LICENSES_PURCHASED',
  LicensesReleased = 'LICENSES_RELEASED',
  LicensesRemoved = 'LICENSES_REMOVED',
  LicensesReserved = 'LICENSES_RESERVED',
  LicenseIssued = 'LICENSE_ISSUED',
  LicenseRevoked = 'LICENSE_REVOKED'
}

/** Boolean expression to compare columns of type "go1_history_events_enum". All fields are combined with logical 'AND'. */
export type Go1_History_Events_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Go1_History_Events_Enum>;
  _in?: InputMaybe<Array<Go1_History_Events_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Go1_History_Events_Enum>;
  _nin?: InputMaybe<Array<Go1_History_Events_Enum>>;
};

/** input type for inserting data into table "go1_history_events" */
export type Go1_History_Events_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Go1_History_Events_Max_Fields = {
  __typename?: 'go1_history_events_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Go1_History_Events_Min_Fields = {
  __typename?: 'go1_history_events_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "go1_history_events" */
export type Go1_History_Events_Mutation_Response = {
  __typename?: 'go1_history_events_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Go1_History_Events>;
};

/** on_conflict condition type for table "go1_history_events" */
export type Go1_History_Events_On_Conflict = {
  constraint: Go1_History_Events_Constraint;
  update_columns?: Array<Go1_History_Events_Update_Column>;
  where?: InputMaybe<Go1_History_Events_Bool_Exp>;
};

/** Ordering options when selecting data from "go1_history_events". */
export type Go1_History_Events_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: go1_history_events */
export type Go1_History_Events_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "go1_history_events" */
export enum Go1_History_Events_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "go1_history_events" */
export type Go1_History_Events_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "go1_history_events" */
export enum Go1_History_Events_Update_Column {
  /** column name */
  Name = 'name'
}

/** Organization's users Go1 licenses */
export type Go1_Licenses = {
  __typename?: 'go1_licenses';
  enrolledOn: Scalars['timestamptz'];
  expireDate: Scalars['timestamptz'];
  id: Scalars['uuid'];
  orgId: Scalars['uuid'];
  /** An object relationship */
  organization: Organization;
  profileId: Scalars['uuid'];
};

/** aggregated selection of "go1_licenses" */
export type Go1_Licenses_Aggregate = {
  __typename?: 'go1_licenses_aggregate';
  aggregate?: Maybe<Go1_Licenses_Aggregate_Fields>;
  nodes: Array<Go1_Licenses>;
};

/** aggregate fields of "go1_licenses" */
export type Go1_Licenses_Aggregate_Fields = {
  __typename?: 'go1_licenses_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Go1_Licenses_Max_Fields>;
  min?: Maybe<Go1_Licenses_Min_Fields>;
};


/** aggregate fields of "go1_licenses" */
export type Go1_Licenses_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Go1_Licenses_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "go1_licenses" */
export type Go1_Licenses_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Go1_Licenses_Max_Order_By>;
  min?: InputMaybe<Go1_Licenses_Min_Order_By>;
};

/** input type for inserting array relation for remote table "go1_licenses" */
export type Go1_Licenses_Arr_Rel_Insert_Input = {
  data: Array<Go1_Licenses_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Go1_Licenses_On_Conflict>;
};

/** Boolean expression to filter rows from the table "go1_licenses". All fields are combined with a logical 'AND'. */
export type Go1_Licenses_Bool_Exp = {
  _and?: InputMaybe<Array<Go1_Licenses_Bool_Exp>>;
  _not?: InputMaybe<Go1_Licenses_Bool_Exp>;
  _or?: InputMaybe<Array<Go1_Licenses_Bool_Exp>>;
  enrolledOn?: InputMaybe<Timestamptz_Comparison_Exp>;
  expireDate?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  orgId?: InputMaybe<Uuid_Comparison_Exp>;
  organization?: InputMaybe<Organization_Bool_Exp>;
  profileId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "go1_licenses" */
export enum Go1_Licenses_Constraint {
  /** unique or primary key constraint */
  Go1LicensesPkey = 'go1_licenses_pkey',
  /** unique or primary key constraint */
  Go1LicensesProfileIdOrgIdKey = 'go1_licenses_profile_id_org_id_key'
}

/** How organization's licenses number is changing in time */
export type Go1_Licenses_History = {
  __typename?: 'go1_licenses_history';
  balance: Scalars['Int'];
  captured_at: Scalars['timestamptz'];
  change: Scalars['Int'];
  event: Go1_History_Events_Enum;
  id: Scalars['uuid'];
  org_id: Scalars['uuid'];
  payload?: Maybe<Scalars['jsonb']>;
  reservedBalance: Scalars['Int'];
};


/** How organization's licenses number is changing in time */
export type Go1_Licenses_HistoryPayloadArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "go1_licenses_history" */
export type Go1_Licenses_History_Aggregate = {
  __typename?: 'go1_licenses_history_aggregate';
  aggregate?: Maybe<Go1_Licenses_History_Aggregate_Fields>;
  nodes: Array<Go1_Licenses_History>;
};

/** aggregate fields of "go1_licenses_history" */
export type Go1_Licenses_History_Aggregate_Fields = {
  __typename?: 'go1_licenses_history_aggregate_fields';
  avg?: Maybe<Go1_Licenses_History_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Go1_Licenses_History_Max_Fields>;
  min?: Maybe<Go1_Licenses_History_Min_Fields>;
  stddev?: Maybe<Go1_Licenses_History_Stddev_Fields>;
  stddev_pop?: Maybe<Go1_Licenses_History_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Go1_Licenses_History_Stddev_Samp_Fields>;
  sum?: Maybe<Go1_Licenses_History_Sum_Fields>;
  var_pop?: Maybe<Go1_Licenses_History_Var_Pop_Fields>;
  var_samp?: Maybe<Go1_Licenses_History_Var_Samp_Fields>;
  variance?: Maybe<Go1_Licenses_History_Variance_Fields>;
};


/** aggregate fields of "go1_licenses_history" */
export type Go1_Licenses_History_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Go1_Licenses_History_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "go1_licenses_history" */
export type Go1_Licenses_History_Aggregate_Order_By = {
  avg?: InputMaybe<Go1_Licenses_History_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Go1_Licenses_History_Max_Order_By>;
  min?: InputMaybe<Go1_Licenses_History_Min_Order_By>;
  stddev?: InputMaybe<Go1_Licenses_History_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Go1_Licenses_History_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Go1_Licenses_History_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Go1_Licenses_History_Sum_Order_By>;
  var_pop?: InputMaybe<Go1_Licenses_History_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Go1_Licenses_History_Var_Samp_Order_By>;
  variance?: InputMaybe<Go1_Licenses_History_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Go1_Licenses_History_Append_Input = {
  payload?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "go1_licenses_history" */
export type Go1_Licenses_History_Arr_Rel_Insert_Input = {
  data: Array<Go1_Licenses_History_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Go1_Licenses_History_On_Conflict>;
};

/** aggregate avg on columns */
export type Go1_Licenses_History_Avg_Fields = {
  __typename?: 'go1_licenses_history_avg_fields';
  balance?: Maybe<Scalars['Float']>;
  change?: Maybe<Scalars['Float']>;
  reservedBalance?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "go1_licenses_history" */
export type Go1_Licenses_History_Avg_Order_By = {
  balance?: InputMaybe<Order_By>;
  change?: InputMaybe<Order_By>;
  reservedBalance?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "go1_licenses_history". All fields are combined with a logical 'AND'. */
export type Go1_Licenses_History_Bool_Exp = {
  _and?: InputMaybe<Array<Go1_Licenses_History_Bool_Exp>>;
  _not?: InputMaybe<Go1_Licenses_History_Bool_Exp>;
  _or?: InputMaybe<Array<Go1_Licenses_History_Bool_Exp>>;
  balance?: InputMaybe<Int_Comparison_Exp>;
  captured_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  change?: InputMaybe<Int_Comparison_Exp>;
  event?: InputMaybe<Go1_History_Events_Enum_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  org_id?: InputMaybe<Uuid_Comparison_Exp>;
  payload?: InputMaybe<Jsonb_Comparison_Exp>;
  reservedBalance?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "go1_licenses_history" */
export enum Go1_Licenses_History_Constraint {
  /** unique or primary key constraint */
  Go1LicensesHistoryPkey = 'go1_licenses_history_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Go1_Licenses_History_Delete_At_Path_Input = {
  payload?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Go1_Licenses_History_Delete_Elem_Input = {
  payload?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Go1_Licenses_History_Delete_Key_Input = {
  payload?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "go1_licenses_history" */
export type Go1_Licenses_History_Inc_Input = {
  balance?: InputMaybe<Scalars['Int']>;
  change?: InputMaybe<Scalars['Int']>;
  reservedBalance?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "go1_licenses_history" */
export type Go1_Licenses_History_Insert_Input = {
  balance?: InputMaybe<Scalars['Int']>;
  captured_at?: InputMaybe<Scalars['timestamptz']>;
  change?: InputMaybe<Scalars['Int']>;
  event?: InputMaybe<Go1_History_Events_Enum>;
  id?: InputMaybe<Scalars['uuid']>;
  org_id?: InputMaybe<Scalars['uuid']>;
  payload?: InputMaybe<Scalars['jsonb']>;
  reservedBalance?: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Go1_Licenses_History_Max_Fields = {
  __typename?: 'go1_licenses_history_max_fields';
  balance?: Maybe<Scalars['Int']>;
  captured_at?: Maybe<Scalars['timestamptz']>;
  change?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  org_id?: Maybe<Scalars['uuid']>;
  reservedBalance?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "go1_licenses_history" */
export type Go1_Licenses_History_Max_Order_By = {
  balance?: InputMaybe<Order_By>;
  captured_at?: InputMaybe<Order_By>;
  change?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  org_id?: InputMaybe<Order_By>;
  reservedBalance?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Go1_Licenses_History_Min_Fields = {
  __typename?: 'go1_licenses_history_min_fields';
  balance?: Maybe<Scalars['Int']>;
  captured_at?: Maybe<Scalars['timestamptz']>;
  change?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  org_id?: Maybe<Scalars['uuid']>;
  reservedBalance?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "go1_licenses_history" */
export type Go1_Licenses_History_Min_Order_By = {
  balance?: InputMaybe<Order_By>;
  captured_at?: InputMaybe<Order_By>;
  change?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  org_id?: InputMaybe<Order_By>;
  reservedBalance?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "go1_licenses_history" */
export type Go1_Licenses_History_Mutation_Response = {
  __typename?: 'go1_licenses_history_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Go1_Licenses_History>;
};

/** on_conflict condition type for table "go1_licenses_history" */
export type Go1_Licenses_History_On_Conflict = {
  constraint: Go1_Licenses_History_Constraint;
  update_columns?: Array<Go1_Licenses_History_Update_Column>;
  where?: InputMaybe<Go1_Licenses_History_Bool_Exp>;
};

/** Ordering options when selecting data from "go1_licenses_history". */
export type Go1_Licenses_History_Order_By = {
  balance?: InputMaybe<Order_By>;
  captured_at?: InputMaybe<Order_By>;
  change?: InputMaybe<Order_By>;
  event?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  org_id?: InputMaybe<Order_By>;
  payload?: InputMaybe<Order_By>;
  reservedBalance?: InputMaybe<Order_By>;
};

/** primary key columns input for table: go1_licenses_history */
export type Go1_Licenses_History_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Go1_Licenses_History_Prepend_Input = {
  payload?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "go1_licenses_history" */
export enum Go1_Licenses_History_Select_Column {
  /** column name */
  Balance = 'balance',
  /** column name */
  CapturedAt = 'captured_at',
  /** column name */
  Change = 'change',
  /** column name */
  Event = 'event',
  /** column name */
  Id = 'id',
  /** column name */
  OrgId = 'org_id',
  /** column name */
  Payload = 'payload',
  /** column name */
  ReservedBalance = 'reservedBalance'
}

/** input type for updating data in table "go1_licenses_history" */
export type Go1_Licenses_History_Set_Input = {
  balance?: InputMaybe<Scalars['Int']>;
  captured_at?: InputMaybe<Scalars['timestamptz']>;
  change?: InputMaybe<Scalars['Int']>;
  event?: InputMaybe<Go1_History_Events_Enum>;
  id?: InputMaybe<Scalars['uuid']>;
  org_id?: InputMaybe<Scalars['uuid']>;
  payload?: InputMaybe<Scalars['jsonb']>;
  reservedBalance?: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Go1_Licenses_History_Stddev_Fields = {
  __typename?: 'go1_licenses_history_stddev_fields';
  balance?: Maybe<Scalars['Float']>;
  change?: Maybe<Scalars['Float']>;
  reservedBalance?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "go1_licenses_history" */
export type Go1_Licenses_History_Stddev_Order_By = {
  balance?: InputMaybe<Order_By>;
  change?: InputMaybe<Order_By>;
  reservedBalance?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Go1_Licenses_History_Stddev_Pop_Fields = {
  __typename?: 'go1_licenses_history_stddev_pop_fields';
  balance?: Maybe<Scalars['Float']>;
  change?: Maybe<Scalars['Float']>;
  reservedBalance?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "go1_licenses_history" */
export type Go1_Licenses_History_Stddev_Pop_Order_By = {
  balance?: InputMaybe<Order_By>;
  change?: InputMaybe<Order_By>;
  reservedBalance?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Go1_Licenses_History_Stddev_Samp_Fields = {
  __typename?: 'go1_licenses_history_stddev_samp_fields';
  balance?: Maybe<Scalars['Float']>;
  change?: Maybe<Scalars['Float']>;
  reservedBalance?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "go1_licenses_history" */
export type Go1_Licenses_History_Stddev_Samp_Order_By = {
  balance?: InputMaybe<Order_By>;
  change?: InputMaybe<Order_By>;
  reservedBalance?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Go1_Licenses_History_Sum_Fields = {
  __typename?: 'go1_licenses_history_sum_fields';
  balance?: Maybe<Scalars['Int']>;
  change?: Maybe<Scalars['Int']>;
  reservedBalance?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "go1_licenses_history" */
export type Go1_Licenses_History_Sum_Order_By = {
  balance?: InputMaybe<Order_By>;
  change?: InputMaybe<Order_By>;
  reservedBalance?: InputMaybe<Order_By>;
};

/** update columns of table "go1_licenses_history" */
export enum Go1_Licenses_History_Update_Column {
  /** column name */
  Balance = 'balance',
  /** column name */
  CapturedAt = 'captured_at',
  /** column name */
  Change = 'change',
  /** column name */
  Event = 'event',
  /** column name */
  Id = 'id',
  /** column name */
  OrgId = 'org_id',
  /** column name */
  Payload = 'payload',
  /** column name */
  ReservedBalance = 'reservedBalance'
}

/** aggregate var_pop on columns */
export type Go1_Licenses_History_Var_Pop_Fields = {
  __typename?: 'go1_licenses_history_var_pop_fields';
  balance?: Maybe<Scalars['Float']>;
  change?: Maybe<Scalars['Float']>;
  reservedBalance?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "go1_licenses_history" */
export type Go1_Licenses_History_Var_Pop_Order_By = {
  balance?: InputMaybe<Order_By>;
  change?: InputMaybe<Order_By>;
  reservedBalance?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Go1_Licenses_History_Var_Samp_Fields = {
  __typename?: 'go1_licenses_history_var_samp_fields';
  balance?: Maybe<Scalars['Float']>;
  change?: Maybe<Scalars['Float']>;
  reservedBalance?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "go1_licenses_history" */
export type Go1_Licenses_History_Var_Samp_Order_By = {
  balance?: InputMaybe<Order_By>;
  change?: InputMaybe<Order_By>;
  reservedBalance?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Go1_Licenses_History_Variance_Fields = {
  __typename?: 'go1_licenses_history_variance_fields';
  balance?: Maybe<Scalars['Float']>;
  change?: Maybe<Scalars['Float']>;
  reservedBalance?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "go1_licenses_history" */
export type Go1_Licenses_History_Variance_Order_By = {
  balance?: InputMaybe<Order_By>;
  change?: InputMaybe<Order_By>;
  reservedBalance?: InputMaybe<Order_By>;
};

/** input type for inserting data into table "go1_licenses" */
export type Go1_Licenses_Insert_Input = {
  enrolledOn?: InputMaybe<Scalars['timestamptz']>;
  expireDate?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  orgId?: InputMaybe<Scalars['uuid']>;
  organization?: InputMaybe<Organization_Obj_Rel_Insert_Input>;
  profileId?: InputMaybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Go1_Licenses_Max_Fields = {
  __typename?: 'go1_licenses_max_fields';
  enrolledOn?: Maybe<Scalars['timestamptz']>;
  expireDate?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  orgId?: Maybe<Scalars['uuid']>;
  profileId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "go1_licenses" */
export type Go1_Licenses_Max_Order_By = {
  enrolledOn?: InputMaybe<Order_By>;
  expireDate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  orgId?: InputMaybe<Order_By>;
  profileId?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Go1_Licenses_Min_Fields = {
  __typename?: 'go1_licenses_min_fields';
  enrolledOn?: Maybe<Scalars['timestamptz']>;
  expireDate?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  orgId?: Maybe<Scalars['uuid']>;
  profileId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "go1_licenses" */
export type Go1_Licenses_Min_Order_By = {
  enrolledOn?: InputMaybe<Order_By>;
  expireDate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  orgId?: InputMaybe<Order_By>;
  profileId?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "go1_licenses" */
export type Go1_Licenses_Mutation_Response = {
  __typename?: 'go1_licenses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Go1_Licenses>;
};

/** on_conflict condition type for table "go1_licenses" */
export type Go1_Licenses_On_Conflict = {
  constraint: Go1_Licenses_Constraint;
  update_columns?: Array<Go1_Licenses_Update_Column>;
  where?: InputMaybe<Go1_Licenses_Bool_Exp>;
};

/** Ordering options when selecting data from "go1_licenses". */
export type Go1_Licenses_Order_By = {
  enrolledOn?: InputMaybe<Order_By>;
  expireDate?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  orgId?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organization_Order_By>;
  profileId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: go1_licenses */
export type Go1_Licenses_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "go1_licenses" */
export enum Go1_Licenses_Select_Column {
  /** column name */
  EnrolledOn = 'enrolledOn',
  /** column name */
  ExpireDate = 'expireDate',
  /** column name */
  Id = 'id',
  /** column name */
  OrgId = 'orgId',
  /** column name */
  ProfileId = 'profileId'
}

/** input type for updating data in table "go1_licenses" */
export type Go1_Licenses_Set_Input = {
  enrolledOn?: InputMaybe<Scalars['timestamptz']>;
  expireDate?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  orgId?: InputMaybe<Scalars['uuid']>;
  profileId?: InputMaybe<Scalars['uuid']>;
};

/** update columns of table "go1_licenses" */
export enum Go1_Licenses_Update_Column {
  /** column name */
  EnrolledOn = 'enrolledOn',
  /** column name */
  ExpireDate = 'expireDate',
  /** column name */
  Id = 'id',
  /** column name */
  OrgId = 'orgId',
  /** column name */
  ProfileId = 'profileId'
}

/** Enum table for possible course grades */
export type Grade = {
  __typename?: 'grade';
  name: Scalars['String'];
};

/** aggregated selection of "grade" */
export type Grade_Aggregate = {
  __typename?: 'grade_aggregate';
  aggregate?: Maybe<Grade_Aggregate_Fields>;
  nodes: Array<Grade>;
};

/** aggregate fields of "grade" */
export type Grade_Aggregate_Fields = {
  __typename?: 'grade_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Grade_Max_Fields>;
  min?: Maybe<Grade_Min_Fields>;
};


/** aggregate fields of "grade" */
export type Grade_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Grade_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "grade". All fields are combined with a logical 'AND'. */
export type Grade_Bool_Exp = {
  _and?: InputMaybe<Array<Grade_Bool_Exp>>;
  _not?: InputMaybe<Grade_Bool_Exp>;
  _or?: InputMaybe<Array<Grade_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "grade" */
export enum Grade_Constraint {
  /** unique or primary key constraint */
  GradePkey = 'grade_pkey'
}

export enum Grade_Enum {
  AssistOnly = 'ASSIST_ONLY',
  Fail = 'FAIL',
  ObserveOnly = 'OBSERVE_ONLY',
  Pass = 'PASS'
}

/** Boolean expression to compare columns of type "grade_enum". All fields are combined with logical 'AND'. */
export type Grade_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Grade_Enum>;
  _in?: InputMaybe<Array<Grade_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Grade_Enum>;
  _nin?: InputMaybe<Array<Grade_Enum>>;
};

/** input type for inserting data into table "grade" */
export type Grade_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Grade_Max_Fields = {
  __typename?: 'grade_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Grade_Min_Fields = {
  __typename?: 'grade_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "grade" */
export type Grade_Mutation_Response = {
  __typename?: 'grade_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Grade>;
};

/** on_conflict condition type for table "grade" */
export type Grade_On_Conflict = {
  constraint: Grade_Constraint;
  update_columns?: Array<Grade_Update_Column>;
  where?: InputMaybe<Grade_Bool_Exp>;
};

/** Ordering options when selecting data from "grade". */
export type Grade_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: grade */
export type Grade_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "grade" */
export enum Grade_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "grade" */
export type Grade_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "grade" */
export enum Grade_Update_Column {
  /** column name */
  Name = 'name'
}

/** columns and relationships of "identity" */
export type Identity = {
  __typename?: 'identity';
  id: Scalars['uuid'];
  /** An object relationship */
  identity_type: Identity_Type;
  /** An object relationship */
  profile: Profile;
  profile_id: Scalars['uuid'];
  provider_id: Scalars['String'];
  type: Identity_Type_Enum;
};

/** aggregated selection of "identity" */
export type Identity_Aggregate = {
  __typename?: 'identity_aggregate';
  aggregate?: Maybe<Identity_Aggregate_Fields>;
  nodes: Array<Identity>;
};

/** aggregate fields of "identity" */
export type Identity_Aggregate_Fields = {
  __typename?: 'identity_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Identity_Max_Fields>;
  min?: Maybe<Identity_Min_Fields>;
};


/** aggregate fields of "identity" */
export type Identity_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Identity_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "identity" */
export type Identity_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Identity_Max_Order_By>;
  min?: InputMaybe<Identity_Min_Order_By>;
};

/** input type for inserting array relation for remote table "identity" */
export type Identity_Arr_Rel_Insert_Input = {
  data: Array<Identity_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Identity_On_Conflict>;
};

/** Boolean expression to filter rows from the table "identity". All fields are combined with a logical 'AND'. */
export type Identity_Bool_Exp = {
  _and?: InputMaybe<Array<Identity_Bool_Exp>>;
  _not?: InputMaybe<Identity_Bool_Exp>;
  _or?: InputMaybe<Array<Identity_Bool_Exp>>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  identity_type?: InputMaybe<Identity_Type_Bool_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profile_id?: InputMaybe<Uuid_Comparison_Exp>;
  provider_id?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<Identity_Type_Enum_Comparison_Exp>;
};

/** unique or primary key constraints on table "identity" */
export enum Identity_Constraint {
  /** unique or primary key constraint */
  IdentityPkey = 'identity_pkey',
  /** unique or primary key constraint */
  IdentityProviderIdKey = 'identity_provider_id_key'
}

/** input type for inserting data into table "identity" */
export type Identity_Insert_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  identity_type?: InputMaybe<Identity_Type_Obj_Rel_Insert_Input>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  provider_id?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Identity_Type_Enum>;
};

/** aggregate max on columns */
export type Identity_Max_Fields = {
  __typename?: 'identity_max_fields';
  id?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
  provider_id?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "identity" */
export type Identity_Max_Order_By = {
  id?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  provider_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Identity_Min_Fields = {
  __typename?: 'identity_min_fields';
  id?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
  provider_id?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "identity" */
export type Identity_Min_Order_By = {
  id?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  provider_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "identity" */
export type Identity_Mutation_Response = {
  __typename?: 'identity_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Identity>;
};

/** on_conflict condition type for table "identity" */
export type Identity_On_Conflict = {
  constraint: Identity_Constraint;
  update_columns?: Array<Identity_Update_Column>;
  where?: InputMaybe<Identity_Bool_Exp>;
};

/** Ordering options when selecting data from "identity". */
export type Identity_Order_By = {
  id?: InputMaybe<Order_By>;
  identity_type?: InputMaybe<Identity_Type_Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profile_id?: InputMaybe<Order_By>;
  provider_id?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
};

/** primary key columns input for table: identity */
export type Identity_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "identity" */
export enum Identity_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  ProviderId = 'provider_id',
  /** column name */
  Type = 'type'
}

/** input type for updating data in table "identity" */
export type Identity_Set_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  provider_id?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Identity_Type_Enum>;
};

/** columns and relationships of "identity_type" */
export type Identity_Type = {
  __typename?: 'identity_type';
  /** An array relationship */
  identities: Array<Identity>;
  /** An aggregate relationship */
  identities_aggregate: Identity_Aggregate;
  value: Scalars['String'];
};


/** columns and relationships of "identity_type" */
export type Identity_TypeIdentitiesArgs = {
  distinct_on?: InputMaybe<Array<Identity_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Identity_Order_By>>;
  where?: InputMaybe<Identity_Bool_Exp>;
};


/** columns and relationships of "identity_type" */
export type Identity_TypeIdentities_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Identity_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Identity_Order_By>>;
  where?: InputMaybe<Identity_Bool_Exp>;
};

/** aggregated selection of "identity_type" */
export type Identity_Type_Aggregate = {
  __typename?: 'identity_type_aggregate';
  aggregate?: Maybe<Identity_Type_Aggregate_Fields>;
  nodes: Array<Identity_Type>;
};

/** aggregate fields of "identity_type" */
export type Identity_Type_Aggregate_Fields = {
  __typename?: 'identity_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Identity_Type_Max_Fields>;
  min?: Maybe<Identity_Type_Min_Fields>;
};


/** aggregate fields of "identity_type" */
export type Identity_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Identity_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "identity_type". All fields are combined with a logical 'AND'. */
export type Identity_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Identity_Type_Bool_Exp>>;
  _not?: InputMaybe<Identity_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Identity_Type_Bool_Exp>>;
  identities?: InputMaybe<Identity_Bool_Exp>;
  value?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "identity_type" */
export enum Identity_Type_Constraint {
  /** unique or primary key constraint */
  IdentityTypePkey = 'identity_type_pkey'
}

export enum Identity_Type_Enum {
  Cognito = 'cognito'
}

/** Boolean expression to compare columns of type "identity_type_enum". All fields are combined with logical 'AND'. */
export type Identity_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Identity_Type_Enum>;
  _in?: InputMaybe<Array<Identity_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Identity_Type_Enum>;
  _nin?: InputMaybe<Array<Identity_Type_Enum>>;
};

/** input type for inserting data into table "identity_type" */
export type Identity_Type_Insert_Input = {
  identities?: InputMaybe<Identity_Arr_Rel_Insert_Input>;
  value?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Identity_Type_Max_Fields = {
  __typename?: 'identity_type_max_fields';
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Identity_Type_Min_Fields = {
  __typename?: 'identity_type_min_fields';
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "identity_type" */
export type Identity_Type_Mutation_Response = {
  __typename?: 'identity_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Identity_Type>;
};

/** input type for inserting object relation for remote table "identity_type" */
export type Identity_Type_Obj_Rel_Insert_Input = {
  data: Identity_Type_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Identity_Type_On_Conflict>;
};

/** on_conflict condition type for table "identity_type" */
export type Identity_Type_On_Conflict = {
  constraint: Identity_Type_Constraint;
  update_columns?: Array<Identity_Type_Update_Column>;
  where?: InputMaybe<Identity_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "identity_type". */
export type Identity_Type_Order_By = {
  identities_aggregate?: InputMaybe<Identity_Aggregate_Order_By>;
  value?: InputMaybe<Order_By>;
};

/** primary key columns input for table: identity_type */
export type Identity_Type_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "identity_type" */
export enum Identity_Type_Select_Column {
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "identity_type" */
export type Identity_Type_Set_Input = {
  value?: InputMaybe<Scalars['String']>;
};

/** update columns of table "identity_type" */
export enum Identity_Type_Update_Column {
  /** column name */
  Value = 'value'
}

/** update columns of table "identity" */
export enum Identity_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  ProviderId = 'provider_id',
  /** column name */
  Type = 'type'
}

export type IsUserSubscribedToMembershipResponse = {
  __typename?: 'isUserSubscribedToMembershipResponse';
  isSubscribed: Scalars['Boolean'];
};

/** Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'. */
export type Json_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['json']>;
  _gt?: InputMaybe<Scalars['json']>;
  _gte?: InputMaybe<Scalars['json']>;
  _in?: InputMaybe<Array<Scalars['json']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['json']>;
  _lte?: InputMaybe<Scalars['json']>;
  _neq?: InputMaybe<Scalars['json']>;
  _nin?: InputMaybe<Array<Scalars['json']>>;
};

export type Jsonb_Cast_Exp = {
  String?: InputMaybe<String_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  _cast?: InputMaybe<Jsonb_Cast_Exp>;
  /** is the column contained in the given json value */
  _contained_in?: InputMaybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  _contains?: InputMaybe<Scalars['jsonb']>;
  _eq?: InputMaybe<Scalars['jsonb']>;
  _gt?: InputMaybe<Scalars['jsonb']>;
  _gte?: InputMaybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  _has_key?: InputMaybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all?: InputMaybe<Array<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any?: InputMaybe<Array<Scalars['String']>>;
  _in?: InputMaybe<Array<Scalars['jsonb']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['jsonb']>;
  _lte?: InputMaybe<Scalars['jsonb']>;
  _neq?: InputMaybe<Scalars['jsonb']>;
  _nin?: InputMaybe<Array<Scalars['jsonb']>>;
};

/** columns and relationships of "legacy_certificate" */
export type Legacy_Certificate = {
  __typename?: 'legacy_certificate';
  certificationDate: Scalars['date'];
  /** An object relationship */
  courseCertificate?: Maybe<Course_Certificate>;
  courseCertificateId?: Maybe<Scalars['uuid']>;
  courseName: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  email: Scalars['String'];
  expiryDate: Scalars['date'];
  firstName: Scalars['String'];
  id: Scalars['uuid'];
  lastName: Scalars['String'];
  legacyId: Scalars['Int'];
  number: Scalars['String'];
  originalRecord: Scalars['jsonb'];
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "legacy_certificate" */
export type Legacy_CertificateOriginalRecordArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "legacy_certificate" */
export type Legacy_Certificate_Aggregate = {
  __typename?: 'legacy_certificate_aggregate';
  aggregate?: Maybe<Legacy_Certificate_Aggregate_Fields>;
  nodes: Array<Legacy_Certificate>;
};

/** aggregate fields of "legacy_certificate" */
export type Legacy_Certificate_Aggregate_Fields = {
  __typename?: 'legacy_certificate_aggregate_fields';
  avg?: Maybe<Legacy_Certificate_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Legacy_Certificate_Max_Fields>;
  min?: Maybe<Legacy_Certificate_Min_Fields>;
  stddev?: Maybe<Legacy_Certificate_Stddev_Fields>;
  stddev_pop?: Maybe<Legacy_Certificate_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Legacy_Certificate_Stddev_Samp_Fields>;
  sum?: Maybe<Legacy_Certificate_Sum_Fields>;
  var_pop?: Maybe<Legacy_Certificate_Var_Pop_Fields>;
  var_samp?: Maybe<Legacy_Certificate_Var_Samp_Fields>;
  variance?: Maybe<Legacy_Certificate_Variance_Fields>;
};


/** aggregate fields of "legacy_certificate" */
export type Legacy_Certificate_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Legacy_Certificate_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Legacy_Certificate_Append_Input = {
  originalRecord?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Legacy_Certificate_Avg_Fields = {
  __typename?: 'legacy_certificate_avg_fields';
  legacyId?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "legacy_certificate". All fields are combined with a logical 'AND'. */
export type Legacy_Certificate_Bool_Exp = {
  _and?: InputMaybe<Array<Legacy_Certificate_Bool_Exp>>;
  _not?: InputMaybe<Legacy_Certificate_Bool_Exp>;
  _or?: InputMaybe<Array<Legacy_Certificate_Bool_Exp>>;
  certificationDate?: InputMaybe<Date_Comparison_Exp>;
  courseCertificate?: InputMaybe<Course_Certificate_Bool_Exp>;
  courseCertificateId?: InputMaybe<Uuid_Comparison_Exp>;
  courseName?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  expiryDate?: InputMaybe<Date_Comparison_Exp>;
  firstName?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  lastName?: InputMaybe<String_Comparison_Exp>;
  legacyId?: InputMaybe<Int_Comparison_Exp>;
  number?: InputMaybe<String_Comparison_Exp>;
  originalRecord?: InputMaybe<Jsonb_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "legacy_certificate" */
export enum Legacy_Certificate_Constraint {
  /** unique or primary key constraint */
  LegacyCertificateLegacyIdKey = 'legacy_certificate_legacy_id_key',
  /** unique or primary key constraint */
  LegacyCertificateNumberKey = 'legacy_certificate_number_key',
  /** unique or primary key constraint */
  LegacyCertificatePkey = 'legacy_certificate_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Legacy_Certificate_Delete_At_Path_Input = {
  originalRecord?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Legacy_Certificate_Delete_Elem_Input = {
  originalRecord?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Legacy_Certificate_Delete_Key_Input = {
  originalRecord?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "legacy_certificate" */
export type Legacy_Certificate_Inc_Input = {
  legacyId?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "legacy_certificate" */
export type Legacy_Certificate_Insert_Input = {
  certificationDate?: InputMaybe<Scalars['date']>;
  courseCertificate?: InputMaybe<Course_Certificate_Obj_Rel_Insert_Input>;
  courseCertificateId?: InputMaybe<Scalars['uuid']>;
  courseName?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  expiryDate?: InputMaybe<Scalars['date']>;
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  lastName?: InputMaybe<Scalars['String']>;
  legacyId?: InputMaybe<Scalars['Int']>;
  number?: InputMaybe<Scalars['String']>;
  originalRecord?: InputMaybe<Scalars['jsonb']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Legacy_Certificate_Max_Fields = {
  __typename?: 'legacy_certificate_max_fields';
  certificationDate?: Maybe<Scalars['date']>;
  courseCertificateId?: Maybe<Scalars['uuid']>;
  courseName?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  expiryDate?: Maybe<Scalars['date']>;
  firstName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  lastName?: Maybe<Scalars['String']>;
  legacyId?: Maybe<Scalars['Int']>;
  number?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Legacy_Certificate_Min_Fields = {
  __typename?: 'legacy_certificate_min_fields';
  certificationDate?: Maybe<Scalars['date']>;
  courseCertificateId?: Maybe<Scalars['uuid']>;
  courseName?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  expiryDate?: Maybe<Scalars['date']>;
  firstName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  lastName?: Maybe<Scalars['String']>;
  legacyId?: Maybe<Scalars['Int']>;
  number?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "legacy_certificate" */
export type Legacy_Certificate_Mutation_Response = {
  __typename?: 'legacy_certificate_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Legacy_Certificate>;
};

/** on_conflict condition type for table "legacy_certificate" */
export type Legacy_Certificate_On_Conflict = {
  constraint: Legacy_Certificate_Constraint;
  update_columns?: Array<Legacy_Certificate_Update_Column>;
  where?: InputMaybe<Legacy_Certificate_Bool_Exp>;
};

/** Ordering options when selecting data from "legacy_certificate". */
export type Legacy_Certificate_Order_By = {
  certificationDate?: InputMaybe<Order_By>;
  courseCertificate?: InputMaybe<Course_Certificate_Order_By>;
  courseCertificateId?: InputMaybe<Order_By>;
  courseName?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  expiryDate?: InputMaybe<Order_By>;
  firstName?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lastName?: InputMaybe<Order_By>;
  legacyId?: InputMaybe<Order_By>;
  number?: InputMaybe<Order_By>;
  originalRecord?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: legacy_certificate */
export type Legacy_Certificate_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Legacy_Certificate_Prepend_Input = {
  originalRecord?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "legacy_certificate" */
export enum Legacy_Certificate_Select_Column {
  /** column name */
  CertificationDate = 'certificationDate',
  /** column name */
  CourseCertificateId = 'courseCertificateId',
  /** column name */
  CourseName = 'courseName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  ExpiryDate = 'expiryDate',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  Id = 'id',
  /** column name */
  LastName = 'lastName',
  /** column name */
  LegacyId = 'legacyId',
  /** column name */
  Number = 'number',
  /** column name */
  OriginalRecord = 'originalRecord',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "legacy_certificate" */
export type Legacy_Certificate_Set_Input = {
  certificationDate?: InputMaybe<Scalars['date']>;
  courseCertificateId?: InputMaybe<Scalars['uuid']>;
  courseName?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  expiryDate?: InputMaybe<Scalars['date']>;
  firstName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  lastName?: InputMaybe<Scalars['String']>;
  legacyId?: InputMaybe<Scalars['Int']>;
  number?: InputMaybe<Scalars['String']>;
  originalRecord?: InputMaybe<Scalars['jsonb']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Legacy_Certificate_Stddev_Fields = {
  __typename?: 'legacy_certificate_stddev_fields';
  legacyId?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Legacy_Certificate_Stddev_Pop_Fields = {
  __typename?: 'legacy_certificate_stddev_pop_fields';
  legacyId?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Legacy_Certificate_Stddev_Samp_Fields = {
  __typename?: 'legacy_certificate_stddev_samp_fields';
  legacyId?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Legacy_Certificate_Sum_Fields = {
  __typename?: 'legacy_certificate_sum_fields';
  legacyId?: Maybe<Scalars['Int']>;
};

/** update columns of table "legacy_certificate" */
export enum Legacy_Certificate_Update_Column {
  /** column name */
  CertificationDate = 'certificationDate',
  /** column name */
  CourseCertificateId = 'courseCertificateId',
  /** column name */
  CourseName = 'courseName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  ExpiryDate = 'expiryDate',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  Id = 'id',
  /** column name */
  LastName = 'lastName',
  /** column name */
  LegacyId = 'legacyId',
  /** column name */
  Number = 'number',
  /** column name */
  OriginalRecord = 'originalRecord',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Legacy_Certificate_Var_Pop_Fields = {
  __typename?: 'legacy_certificate_var_pop_fields';
  legacyId?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Legacy_Certificate_Var_Samp_Fields = {
  __typename?: 'legacy_certificate_var_samp_fields';
  legacyId?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Legacy_Certificate_Variance_Fields = {
  __typename?: 'legacy_certificate_variance_fields';
  legacyId?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "module" */
export type Module = {
  __typename?: 'module';
  createdAt: Scalars['timestamptz'];
  description?: Maybe<Scalars['String']>;
  group?: Maybe<Scalars['uuid']>;
  id: Scalars['uuid'];
  level: Course_Level_Enum;
  /** An object relationship */
  moduleGroup?: Maybe<Module_Group>;
  name: Scalars['String'];
  type: Module_Category_Enum;
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "module" */
export type Module_Aggregate = {
  __typename?: 'module_aggregate';
  aggregate?: Maybe<Module_Aggregate_Fields>;
  nodes: Array<Module>;
};

/** aggregate fields of "module" */
export type Module_Aggregate_Fields = {
  __typename?: 'module_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Module_Max_Fields>;
  min?: Maybe<Module_Min_Fields>;
};


/** aggregate fields of "module" */
export type Module_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Module_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "module" */
export type Module_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Module_Max_Order_By>;
  min?: InputMaybe<Module_Min_Order_By>;
};

/** input type for inserting array relation for remote table "module" */
export type Module_Arr_Rel_Insert_Input = {
  data: Array<Module_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Module_On_Conflict>;
};

/** Boolean expression to filter rows from the table "module". All fields are combined with a logical 'AND'. */
export type Module_Bool_Exp = {
  _and?: InputMaybe<Array<Module_Bool_Exp>>;
  _not?: InputMaybe<Module_Bool_Exp>;
  _or?: InputMaybe<Array<Module_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  group?: InputMaybe<Uuid_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  level?: InputMaybe<Course_Level_Enum_Comparison_Exp>;
  moduleGroup?: InputMaybe<Module_Group_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  type?: InputMaybe<Module_Category_Enum_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** columns and relationships of "module_category" */
export type Module_Category = {
  __typename?: 'module_category';
  name: Scalars['String'];
};

/** aggregated selection of "module_category" */
export type Module_Category_Aggregate = {
  __typename?: 'module_category_aggregate';
  aggregate?: Maybe<Module_Category_Aggregate_Fields>;
  nodes: Array<Module_Category>;
};

/** aggregate fields of "module_category" */
export type Module_Category_Aggregate_Fields = {
  __typename?: 'module_category_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Module_Category_Max_Fields>;
  min?: Maybe<Module_Category_Min_Fields>;
};


/** aggregate fields of "module_category" */
export type Module_Category_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Module_Category_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "module_category". All fields are combined with a logical 'AND'. */
export type Module_Category_Bool_Exp = {
  _and?: InputMaybe<Array<Module_Category_Bool_Exp>>;
  _not?: InputMaybe<Module_Category_Bool_Exp>;
  _or?: InputMaybe<Array<Module_Category_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "module_category" */
export enum Module_Category_Constraint {
  /** unique or primary key constraint */
  ModuleCategoryPkey = 'module_category_pkey'
}

export enum Module_Category_Enum {
  Physical = 'PHYSICAL',
  Theory = 'THEORY'
}

/** Boolean expression to compare columns of type "module_category_enum". All fields are combined with logical 'AND'. */
export type Module_Category_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Module_Category_Enum>;
  _in?: InputMaybe<Array<Module_Category_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Module_Category_Enum>;
  _nin?: InputMaybe<Array<Module_Category_Enum>>;
};

/** input type for inserting data into table "module_category" */
export type Module_Category_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Module_Category_Max_Fields = {
  __typename?: 'module_category_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Module_Category_Min_Fields = {
  __typename?: 'module_category_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "module_category" */
export type Module_Category_Mutation_Response = {
  __typename?: 'module_category_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Module_Category>;
};

/** on_conflict condition type for table "module_category" */
export type Module_Category_On_Conflict = {
  constraint: Module_Category_Constraint;
  update_columns?: Array<Module_Category_Update_Column>;
  where?: InputMaybe<Module_Category_Bool_Exp>;
};

/** Ordering options when selecting data from "module_category". */
export type Module_Category_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: module_category */
export type Module_Category_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "module_category" */
export enum Module_Category_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "module_category" */
export type Module_Category_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "module_category" */
export enum Module_Category_Update_Column {
  /** column name */
  Name = 'name'
}

/** unique or primary key constraints on table "module" */
export enum Module_Constraint {
  /** unique or primary key constraint */
  ModulePkey = 'module_pkey'
}

/** columns and relationships of "module_group" */
export type Module_Group = {
  __typename?: 'module_group';
  color: Color_Enum;
  createdAt: Scalars['timestamptz'];
  /** An array relationship */
  durations: Array<Module_Group_Duration>;
  /** An aggregate relationship */
  durations_aggregate: Module_Group_Duration_Aggregate;
  id: Scalars['uuid'];
  level: Course_Level_Enum;
  mandatory: Scalars['Boolean'];
  /** An array relationship */
  modules: Array<Module>;
  /** An aggregate relationship */
  modules_aggregate: Module_Aggregate;
  name: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "module_group" */
export type Module_GroupDurationsArgs = {
  distinct_on?: InputMaybe<Array<Module_Group_Duration_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Group_Duration_Order_By>>;
  where?: InputMaybe<Module_Group_Duration_Bool_Exp>;
};


/** columns and relationships of "module_group" */
export type Module_GroupDurations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Group_Duration_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Group_Duration_Order_By>>;
  where?: InputMaybe<Module_Group_Duration_Bool_Exp>;
};


/** columns and relationships of "module_group" */
export type Module_GroupModulesArgs = {
  distinct_on?: InputMaybe<Array<Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Order_By>>;
  where?: InputMaybe<Module_Bool_Exp>;
};


/** columns and relationships of "module_group" */
export type Module_GroupModules_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Order_By>>;
  where?: InputMaybe<Module_Bool_Exp>;
};

/** aggregated selection of "module_group" */
export type Module_Group_Aggregate = {
  __typename?: 'module_group_aggregate';
  aggregate?: Maybe<Module_Group_Aggregate_Fields>;
  nodes: Array<Module_Group>;
};

/** aggregate fields of "module_group" */
export type Module_Group_Aggregate_Fields = {
  __typename?: 'module_group_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Module_Group_Max_Fields>;
  min?: Maybe<Module_Group_Min_Fields>;
};


/** aggregate fields of "module_group" */
export type Module_Group_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Module_Group_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "module_group". All fields are combined with a logical 'AND'. */
export type Module_Group_Bool_Exp = {
  _and?: InputMaybe<Array<Module_Group_Bool_Exp>>;
  _not?: InputMaybe<Module_Group_Bool_Exp>;
  _or?: InputMaybe<Array<Module_Group_Bool_Exp>>;
  color?: InputMaybe<Color_Enum_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  durations?: InputMaybe<Module_Group_Duration_Bool_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  level?: InputMaybe<Course_Level_Enum_Comparison_Exp>;
  mandatory?: InputMaybe<Boolean_Comparison_Exp>;
  modules?: InputMaybe<Module_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "module_group" */
export enum Module_Group_Constraint {
  /** unique or primary key constraint */
  ModuleGroupPkey = 'module_group_pkey'
}

/** columns and relationships of "module_group_duration" */
export type Module_Group_Duration = {
  __typename?: 'module_group_duration';
  courseDeliveryType: Course_Delivery_Type_Enum;
  createdAt: Scalars['timestamptz'];
  duration: Scalars['Int'];
  go1Integration: Scalars['Boolean'];
  id: Scalars['uuid'];
  /** An object relationship */
  moduleGroup: Module_Group;
  module_group_id: Scalars['uuid'];
  reaccreditation: Scalars['Boolean'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "module_group_duration" */
export type Module_Group_Duration_Aggregate = {
  __typename?: 'module_group_duration_aggregate';
  aggregate?: Maybe<Module_Group_Duration_Aggregate_Fields>;
  nodes: Array<Module_Group_Duration>;
};

/** aggregate fields of "module_group_duration" */
export type Module_Group_Duration_Aggregate_Fields = {
  __typename?: 'module_group_duration_aggregate_fields';
  avg?: Maybe<Module_Group_Duration_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Module_Group_Duration_Max_Fields>;
  min?: Maybe<Module_Group_Duration_Min_Fields>;
  stddev?: Maybe<Module_Group_Duration_Stddev_Fields>;
  stddev_pop?: Maybe<Module_Group_Duration_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Module_Group_Duration_Stddev_Samp_Fields>;
  sum?: Maybe<Module_Group_Duration_Sum_Fields>;
  var_pop?: Maybe<Module_Group_Duration_Var_Pop_Fields>;
  var_samp?: Maybe<Module_Group_Duration_Var_Samp_Fields>;
  variance?: Maybe<Module_Group_Duration_Variance_Fields>;
};


/** aggregate fields of "module_group_duration" */
export type Module_Group_Duration_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Module_Group_Duration_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "module_group_duration" */
export type Module_Group_Duration_Aggregate_Order_By = {
  avg?: InputMaybe<Module_Group_Duration_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Module_Group_Duration_Max_Order_By>;
  min?: InputMaybe<Module_Group_Duration_Min_Order_By>;
  stddev?: InputMaybe<Module_Group_Duration_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Module_Group_Duration_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Module_Group_Duration_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Module_Group_Duration_Sum_Order_By>;
  var_pop?: InputMaybe<Module_Group_Duration_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Module_Group_Duration_Var_Samp_Order_By>;
  variance?: InputMaybe<Module_Group_Duration_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "module_group_duration" */
export type Module_Group_Duration_Arr_Rel_Insert_Input = {
  data: Array<Module_Group_Duration_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Module_Group_Duration_On_Conflict>;
};

/** aggregate avg on columns */
export type Module_Group_Duration_Avg_Fields = {
  __typename?: 'module_group_duration_avg_fields';
  duration?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "module_group_duration" */
export type Module_Group_Duration_Avg_Order_By = {
  duration?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "module_group_duration". All fields are combined with a logical 'AND'. */
export type Module_Group_Duration_Bool_Exp = {
  _and?: InputMaybe<Array<Module_Group_Duration_Bool_Exp>>;
  _not?: InputMaybe<Module_Group_Duration_Bool_Exp>;
  _or?: InputMaybe<Array<Module_Group_Duration_Bool_Exp>>;
  courseDeliveryType?: InputMaybe<Course_Delivery_Type_Enum_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  duration?: InputMaybe<Int_Comparison_Exp>;
  go1Integration?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  moduleGroup?: InputMaybe<Module_Group_Bool_Exp>;
  module_group_id?: InputMaybe<Uuid_Comparison_Exp>;
  reaccreditation?: InputMaybe<Boolean_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "module_group_duration" */
export enum Module_Group_Duration_Constraint {
  /** unique or primary key constraint */
  ModuleGroupDurationPkey = 'module_group_duration_pkey'
}

/** input type for incrementing numeric columns in table "module_group_duration" */
export type Module_Group_Duration_Inc_Input = {
  duration?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "module_group_duration" */
export type Module_Group_Duration_Insert_Input = {
  courseDeliveryType?: InputMaybe<Course_Delivery_Type_Enum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  duration?: InputMaybe<Scalars['Int']>;
  go1Integration?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  moduleGroup?: InputMaybe<Module_Group_Obj_Rel_Insert_Input>;
  module_group_id?: InputMaybe<Scalars['uuid']>;
  reaccreditation?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Module_Group_Duration_Max_Fields = {
  __typename?: 'module_group_duration_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  duration?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  module_group_id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "module_group_duration" */
export type Module_Group_Duration_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  duration?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  module_group_id?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Module_Group_Duration_Min_Fields = {
  __typename?: 'module_group_duration_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  duration?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  module_group_id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "module_group_duration" */
export type Module_Group_Duration_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  duration?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  module_group_id?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "module_group_duration" */
export type Module_Group_Duration_Mutation_Response = {
  __typename?: 'module_group_duration_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Module_Group_Duration>;
};

/** on_conflict condition type for table "module_group_duration" */
export type Module_Group_Duration_On_Conflict = {
  constraint: Module_Group_Duration_Constraint;
  update_columns?: Array<Module_Group_Duration_Update_Column>;
  where?: InputMaybe<Module_Group_Duration_Bool_Exp>;
};

/** Ordering options when selecting data from "module_group_duration". */
export type Module_Group_Duration_Order_By = {
  courseDeliveryType?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  duration?: InputMaybe<Order_By>;
  go1Integration?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  moduleGroup?: InputMaybe<Module_Group_Order_By>;
  module_group_id?: InputMaybe<Order_By>;
  reaccreditation?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: module_group_duration */
export type Module_Group_Duration_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "module_group_duration" */
export enum Module_Group_Duration_Select_Column {
  /** column name */
  CourseDeliveryType = 'courseDeliveryType',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Duration = 'duration',
  /** column name */
  Go1Integration = 'go1Integration',
  /** column name */
  Id = 'id',
  /** column name */
  ModuleGroupId = 'module_group_id',
  /** column name */
  Reaccreditation = 'reaccreditation',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "module_group_duration" */
export type Module_Group_Duration_Set_Input = {
  courseDeliveryType?: InputMaybe<Course_Delivery_Type_Enum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  duration?: InputMaybe<Scalars['Int']>;
  go1Integration?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  module_group_id?: InputMaybe<Scalars['uuid']>;
  reaccreditation?: InputMaybe<Scalars['Boolean']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Module_Group_Duration_Stddev_Fields = {
  __typename?: 'module_group_duration_stddev_fields';
  duration?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "module_group_duration" */
export type Module_Group_Duration_Stddev_Order_By = {
  duration?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Module_Group_Duration_Stddev_Pop_Fields = {
  __typename?: 'module_group_duration_stddev_pop_fields';
  duration?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "module_group_duration" */
export type Module_Group_Duration_Stddev_Pop_Order_By = {
  duration?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Module_Group_Duration_Stddev_Samp_Fields = {
  __typename?: 'module_group_duration_stddev_samp_fields';
  duration?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "module_group_duration" */
export type Module_Group_Duration_Stddev_Samp_Order_By = {
  duration?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Module_Group_Duration_Sum_Fields = {
  __typename?: 'module_group_duration_sum_fields';
  duration?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "module_group_duration" */
export type Module_Group_Duration_Sum_Order_By = {
  duration?: InputMaybe<Order_By>;
};

/** update columns of table "module_group_duration" */
export enum Module_Group_Duration_Update_Column {
  /** column name */
  CourseDeliveryType = 'courseDeliveryType',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Duration = 'duration',
  /** column name */
  Go1Integration = 'go1Integration',
  /** column name */
  Id = 'id',
  /** column name */
  ModuleGroupId = 'module_group_id',
  /** column name */
  Reaccreditation = 'reaccreditation',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Module_Group_Duration_Var_Pop_Fields = {
  __typename?: 'module_group_duration_var_pop_fields';
  duration?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "module_group_duration" */
export type Module_Group_Duration_Var_Pop_Order_By = {
  duration?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Module_Group_Duration_Var_Samp_Fields = {
  __typename?: 'module_group_duration_var_samp_fields';
  duration?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "module_group_duration" */
export type Module_Group_Duration_Var_Samp_Order_By = {
  duration?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Module_Group_Duration_Variance_Fields = {
  __typename?: 'module_group_duration_variance_fields';
  duration?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "module_group_duration" */
export type Module_Group_Duration_Variance_Order_By = {
  duration?: InputMaybe<Order_By>;
};

/** input type for inserting data into table "module_group" */
export type Module_Group_Insert_Input = {
  color?: InputMaybe<Color_Enum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  durations?: InputMaybe<Module_Group_Duration_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['uuid']>;
  level?: InputMaybe<Course_Level_Enum>;
  mandatory?: InputMaybe<Scalars['Boolean']>;
  modules?: InputMaybe<Module_Arr_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Module_Group_Max_Fields = {
  __typename?: 'module_group_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Module_Group_Min_Fields = {
  __typename?: 'module_group_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "module_group" */
export type Module_Group_Mutation_Response = {
  __typename?: 'module_group_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Module_Group>;
};

/** input type for inserting object relation for remote table "module_group" */
export type Module_Group_Obj_Rel_Insert_Input = {
  data: Module_Group_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Module_Group_On_Conflict>;
};

/** on_conflict condition type for table "module_group" */
export type Module_Group_On_Conflict = {
  constraint: Module_Group_Constraint;
  update_columns?: Array<Module_Group_Update_Column>;
  where?: InputMaybe<Module_Group_Bool_Exp>;
};

/** Ordering options when selecting data from "module_group". */
export type Module_Group_Order_By = {
  color?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  durations_aggregate?: InputMaybe<Module_Group_Duration_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  level?: InputMaybe<Order_By>;
  mandatory?: InputMaybe<Order_By>;
  modules_aggregate?: InputMaybe<Module_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: module_group */
export type Module_Group_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "module_group" */
export enum Module_Group_Select_Column {
  /** column name */
  Color = 'color',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Level = 'level',
  /** column name */
  Mandatory = 'mandatory',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "module_group" */
export type Module_Group_Set_Input = {
  color?: InputMaybe<Color_Enum>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  level?: InputMaybe<Course_Level_Enum>;
  mandatory?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "module_group" */
export enum Module_Group_Update_Column {
  /** column name */
  Color = 'color',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Level = 'level',
  /** column name */
  Mandatory = 'mandatory',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for inserting data into table "module" */
export type Module_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  group?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  level?: InputMaybe<Course_Level_Enum>;
  moduleGroup?: InputMaybe<Module_Group_Obj_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Module_Category_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Module_Max_Fields = {
  __typename?: 'module_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  group?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "module" */
export type Module_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  group?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Module_Min_Fields = {
  __typename?: 'module_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  group?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "module" */
export type Module_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  group?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "module" */
export type Module_Mutation_Response = {
  __typename?: 'module_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Module>;
};

/** input type for inserting object relation for remote table "module" */
export type Module_Obj_Rel_Insert_Input = {
  data: Module_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Module_On_Conflict>;
};

/** on_conflict condition type for table "module" */
export type Module_On_Conflict = {
  constraint: Module_Constraint;
  update_columns?: Array<Module_Update_Column>;
  where?: InputMaybe<Module_Bool_Exp>;
};

/** Ordering options when selecting data from "module". */
export type Module_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  group?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  level?: InputMaybe<Order_By>;
  moduleGroup?: InputMaybe<Module_Group_Order_By>;
  name?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: module */
export type Module_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "module" */
export enum Module_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  Group = 'group',
  /** column name */
  Id = 'id',
  /** column name */
  Level = 'level',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "module" */
export type Module_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  description?: InputMaybe<Scalars['String']>;
  group?: InputMaybe<Scalars['uuid']>;
  id?: InputMaybe<Scalars['uuid']>;
  level?: InputMaybe<Course_Level_Enum>;
  name?: InputMaybe<Scalars['String']>;
  type?: InputMaybe<Module_Category_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "module" */
export enum Module_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Description = 'description',
  /** column name */
  Group = 'group',
  /** column name */
  Id = 'id',
  /** column name */
  Level = 'level',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  acceptOrgInvite?: Maybe<AcceptOrgInviteOutput>;
  cancelIndividualFromCourse: Scalars['Boolean'];
  cancelMyselfFromCourse: Scalars['Boolean'];
  /** confirmCreditCardPayment */
  confirmCreditCardPayment?: Maybe<ConfirmCreditCardPaymentOutput>;
  content?: Maybe<RootMutation>;
  /** Attempts to create a new Order */
  createOrder?: Maybe<CreateOrderOutput>;
  /** Creates a membership subscription */
  createStripeSubscription?: Maybe<CreateSubscriptionOutput>;
  createUser: CreateUserOutput;
  declineInvite?: Maybe<DeclineInviteOutput>;
  declineOrgInvite?: Maybe<DeclineOrgInviteOutput>;
  /** delete data from the table: "availability" */
  delete_availability?: Maybe<Availability_Mutation_Response>;
  /** delete single row from the table: "availability" */
  delete_availability_by_pk?: Maybe<Availability>;
  /** delete data from the table: "blended_learning_status" */
  delete_blended_learning_status?: Maybe<Blended_Learning_Status_Mutation_Response>;
  /** delete single row from the table: "blended_learning_status" */
  delete_blended_learning_status_by_pk?: Maybe<Blended_Learning_Status>;
  /** delete data from the table: "certificate_status" */
  delete_certificate_status?: Maybe<Certificate_Status_Mutation_Response>;
  /** delete single row from the table: "certificate_status" */
  delete_certificate_status_by_pk?: Maybe<Certificate_Status>;
  /** delete data from the table: "color" */
  delete_color?: Maybe<Color_Mutation_Response>;
  /** delete single row from the table: "color" */
  delete_color_by_pk?: Maybe<Color>;
  /** delete data from the table: "course" */
  delete_course?: Maybe<Course_Mutation_Response>;
  /** delete data from the table: "course_audit" */
  delete_course_audit?: Maybe<Course_Audit_Mutation_Response>;
  /** delete single row from the table: "course_audit" */
  delete_course_audit_by_pk?: Maybe<Course_Audit>;
  /** delete data from the table: "course_audit_type" */
  delete_course_audit_type?: Maybe<Course_Audit_Type_Mutation_Response>;
  /** delete single row from the table: "course_audit_type" */
  delete_course_audit_type_by_pk?: Maybe<Course_Audit_Type>;
  /** delete single row from the table: "course" */
  delete_course_by_pk?: Maybe<Course>;
  /** delete data from the table: "course_cancellation_request" */
  delete_course_cancellation_request?: Maybe<Course_Cancellation_Request_Mutation_Response>;
  /** delete single row from the table: "course_cancellation_request" */
  delete_course_cancellation_request_by_pk?: Maybe<Course_Cancellation_Request>;
  /** delete data from the table: "course_certificate" */
  delete_course_certificate?: Maybe<Course_Certificate_Mutation_Response>;
  /** delete single row from the table: "course_certificate" */
  delete_course_certificate_by_pk?: Maybe<Course_Certificate>;
  /** delete data from the table: "course_certificate_changelog" */
  delete_course_certificate_changelog?: Maybe<Course_Certificate_Changelog_Mutation_Response>;
  /** delete single row from the table: "course_certificate_changelog" */
  delete_course_certificate_changelog_by_pk?: Maybe<Course_Certificate_Changelog>;
  /** delete data from the table: "course_delivery_type" */
  delete_course_delivery_type?: Maybe<Course_Delivery_Type_Mutation_Response>;
  /** delete single row from the table: "course_delivery_type" */
  delete_course_delivery_type_by_pk?: Maybe<Course_Delivery_Type>;
  /** delete data from the table: "course_draft" */
  delete_course_draft?: Maybe<Course_Draft_Mutation_Response>;
  /** delete single row from the table: "course_draft" */
  delete_course_draft_by_pk?: Maybe<Course_Draft>;
  /** delete data from the table: "course_end_jobs" */
  delete_course_end_jobs?: Maybe<Course_End_Jobs_Mutation_Response>;
  /** delete single row from the table: "course_end_jobs" */
  delete_course_end_jobs_by_pk?: Maybe<Course_End_Jobs>;
  /** delete data from the table: "course_enquiry" */
  delete_course_enquiry?: Maybe<Course_Enquiry_Mutation_Response>;
  /** delete single row from the table: "course_enquiry" */
  delete_course_enquiry_by_pk?: Maybe<Course_Enquiry>;
  /** delete data from the table: "course_evaluation_answers" */
  delete_course_evaluation_answers?: Maybe<Course_Evaluation_Answers_Mutation_Response>;
  /** delete single row from the table: "course_evaluation_answers" */
  delete_course_evaluation_answers_by_pk?: Maybe<Course_Evaluation_Answers>;
  /** delete data from the table: "course_evaluation_question_group" */
  delete_course_evaluation_question_group?: Maybe<Course_Evaluation_Question_Group_Mutation_Response>;
  /** delete single row from the table: "course_evaluation_question_group" */
  delete_course_evaluation_question_group_by_pk?: Maybe<Course_Evaluation_Question_Group>;
  /** delete data from the table: "course_evaluation_question_type" */
  delete_course_evaluation_question_type?: Maybe<Course_Evaluation_Question_Type_Mutation_Response>;
  /** delete single row from the table: "course_evaluation_question_type" */
  delete_course_evaluation_question_type_by_pk?: Maybe<Course_Evaluation_Question_Type>;
  /** delete data from the table: "course_evaluation_questions" */
  delete_course_evaluation_questions?: Maybe<Course_Evaluation_Questions_Mutation_Response>;
  /** delete single row from the table: "course_evaluation_questions" */
  delete_course_evaluation_questions_by_pk?: Maybe<Course_Evaluation_Questions>;
  /** delete data from the table: "course_expenses" */
  delete_course_expenses?: Maybe<Course_Expenses_Mutation_Response>;
  /** delete single row from the table: "course_expenses" */
  delete_course_expenses_by_pk?: Maybe<Course_Expenses>;
  /** delete data from the table: "course_invite_status" */
  delete_course_invite_status?: Maybe<Course_Invite_Status_Mutation_Response>;
  /** delete single row from the table: "course_invite_status" */
  delete_course_invite_status_by_pk?: Maybe<Course_Invite_Status>;
  /** delete data from the table: "course_invites" */
  delete_course_invites?: Maybe<Course_Invites_Mutation_Response>;
  /** delete single row from the table: "course_invites" */
  delete_course_invites_by_pk?: Maybe<Course_Invites>;
  /** delete data from the table: "course_level" */
  delete_course_level?: Maybe<Course_Level_Mutation_Response>;
  /** delete single row from the table: "course_level" */
  delete_course_level_by_pk?: Maybe<Course_Level>;
  /** delete data from the table: "course_level_prefix" */
  delete_course_level_prefix?: Maybe<Course_Level_Prefix_Mutation_Response>;
  /** delete single row from the table: "course_level_prefix" */
  delete_course_level_prefix_by_pk?: Maybe<Course_Level_Prefix>;
  /** delete data from the table: "course_module" */
  delete_course_module?: Maybe<Course_Module_Mutation_Response>;
  /** delete single row from the table: "course_module" */
  delete_course_module_by_pk?: Maybe<Course_Module>;
  /** delete data from the table: "course_participant" */
  delete_course_participant?: Maybe<Course_Participant_Mutation_Response>;
  /** delete data from the table: "course_participant_audit" */
  delete_course_participant_audit?: Maybe<Course_Participant_Audit_Mutation_Response>;
  /** delete single row from the table: "course_participant_audit" */
  delete_course_participant_audit_by_pk?: Maybe<Course_Participant_Audit>;
  /** delete data from the table: "course_participant_audit_type" */
  delete_course_participant_audit_type?: Maybe<Course_Participant_Audit_Type_Mutation_Response>;
  /** delete single row from the table: "course_participant_audit_type" */
  delete_course_participant_audit_type_by_pk?: Maybe<Course_Participant_Audit_Type>;
  /** delete single row from the table: "course_participant" */
  delete_course_participant_by_pk?: Maybe<Course_Participant>;
  /** delete data from the table: "course_participant_cancellation" */
  delete_course_participant_cancellation?: Maybe<Course_Participant_Cancellation_Mutation_Response>;
  /** delete single row from the table: "course_participant_cancellation" */
  delete_course_participant_cancellation_by_pk?: Maybe<Course_Participant_Cancellation>;
  /** delete data from the table: "course_participant_module" */
  delete_course_participant_module?: Maybe<Course_Participant_Module_Mutation_Response>;
  /** delete single row from the table: "course_participant_module" */
  delete_course_participant_module_by_pk?: Maybe<Course_Participant_Module>;
  /** delete data from the table: "course_pricing" */
  delete_course_pricing?: Maybe<Course_Pricing_Mutation_Response>;
  /** delete single row from the table: "course_pricing" */
  delete_course_pricing_by_pk?: Maybe<Course_Pricing>;
  /** delete data from the table: "course_promo_code" */
  delete_course_promo_code?: Maybe<Course_Promo_Code_Mutation_Response>;
  /** delete single row from the table: "course_promo_code" */
  delete_course_promo_code_by_pk?: Maybe<Course_Promo_Code>;
  /** delete data from the table: "course_schedule" */
  delete_course_schedule?: Maybe<Course_Schedule_Mutation_Response>;
  /** delete single row from the table: "course_schedule" */
  delete_course_schedule_by_pk?: Maybe<Course_Schedule>;
  /** delete data from the table: "course_status" */
  delete_course_status?: Maybe<Course_Status_Mutation_Response>;
  /** delete single row from the table: "course_status" */
  delete_course_status_by_pk?: Maybe<Course_Status>;
  /** delete data from the table: "course_trainer" */
  delete_course_trainer?: Maybe<Course_Trainer_Mutation_Response>;
  /** delete single row from the table: "course_trainer" */
  delete_course_trainer_by_pk?: Maybe<Course_Trainer>;
  /** delete data from the table: "course_trainer_type" */
  delete_course_trainer_type?: Maybe<Course_Trainer_Type_Mutation_Response>;
  /** delete single row from the table: "course_trainer_type" */
  delete_course_trainer_type_by_pk?: Maybe<Course_Trainer_Type>;
  /** delete data from the table: "course_type" */
  delete_course_type?: Maybe<Course_Type_Mutation_Response>;
  /** delete single row from the table: "course_type" */
  delete_course_type_by_pk?: Maybe<Course_Type>;
  /** delete data from the table: "course_type_prefix" */
  delete_course_type_prefix?: Maybe<Course_Type_Prefix_Mutation_Response>;
  /** delete single row from the table: "course_type_prefix" */
  delete_course_type_prefix_by_pk?: Maybe<Course_Type_Prefix>;
  /** delete data from the table: "dfe_establishment" */
  delete_dfe_establishment?: Maybe<Dfe_Establishment_Mutation_Response>;
  /** delete single row from the table: "dfe_establishment" */
  delete_dfe_establishment_by_pk?: Maybe<Dfe_Establishment>;
  /** delete data from the table: "expire_go1_license_jobs" */
  delete_expire_go1_license_jobs?: Maybe<Expire_Go1_License_Jobs_Mutation_Response>;
  /** delete single row from the table: "expire_go1_license_jobs" */
  delete_expire_go1_license_jobs_by_pk?: Maybe<Expire_Go1_License_Jobs>;
  /** delete data from the table: "go1_history_events" */
  delete_go1_history_events?: Maybe<Go1_History_Events_Mutation_Response>;
  /** delete single row from the table: "go1_history_events" */
  delete_go1_history_events_by_pk?: Maybe<Go1_History_Events>;
  /** delete data from the table: "go1_licenses" */
  delete_go1_licenses?: Maybe<Go1_Licenses_Mutation_Response>;
  /** delete single row from the table: "go1_licenses" */
  delete_go1_licenses_by_pk?: Maybe<Go1_Licenses>;
  /** delete data from the table: "go1_licenses_history" */
  delete_go1_licenses_history?: Maybe<Go1_Licenses_History_Mutation_Response>;
  /** delete single row from the table: "go1_licenses_history" */
  delete_go1_licenses_history_by_pk?: Maybe<Go1_Licenses_History>;
  /** delete data from the table: "grade" */
  delete_grade?: Maybe<Grade_Mutation_Response>;
  /** delete single row from the table: "grade" */
  delete_grade_by_pk?: Maybe<Grade>;
  /** delete data from the table: "identity" */
  delete_identity?: Maybe<Identity_Mutation_Response>;
  /** delete single row from the table: "identity" */
  delete_identity_by_pk?: Maybe<Identity>;
  /** delete data from the table: "identity_type" */
  delete_identity_type?: Maybe<Identity_Type_Mutation_Response>;
  /** delete single row from the table: "identity_type" */
  delete_identity_type_by_pk?: Maybe<Identity_Type>;
  /** delete data from the table: "legacy_certificate" */
  delete_legacy_certificate?: Maybe<Legacy_Certificate_Mutation_Response>;
  /** delete single row from the table: "legacy_certificate" */
  delete_legacy_certificate_by_pk?: Maybe<Legacy_Certificate>;
  /** delete data from the table: "module" */
  delete_module?: Maybe<Module_Mutation_Response>;
  /** delete single row from the table: "module" */
  delete_module_by_pk?: Maybe<Module>;
  /** delete data from the table: "module_category" */
  delete_module_category?: Maybe<Module_Category_Mutation_Response>;
  /** delete single row from the table: "module_category" */
  delete_module_category_by_pk?: Maybe<Module_Category>;
  /** delete data from the table: "module_group" */
  delete_module_group?: Maybe<Module_Group_Mutation_Response>;
  /** delete single row from the table: "module_group" */
  delete_module_group_by_pk?: Maybe<Module_Group>;
  /** delete data from the table: "module_group_duration" */
  delete_module_group_duration?: Maybe<Module_Group_Duration_Mutation_Response>;
  /** delete single row from the table: "module_group_duration" */
  delete_module_group_duration_by_pk?: Maybe<Module_Group_Duration>;
  /** delete data from the table: "order" */
  delete_order?: Maybe<Order_Mutation_Response>;
  /** delete single row from the table: "order" */
  delete_order_by_pk?: Maybe<Order>;
  /** delete data from the table: "organization" */
  delete_organization?: Maybe<Organization_Mutation_Response>;
  /** delete single row from the table: "organization" */
  delete_organization_by_pk?: Maybe<Organization>;
  /** delete data from the table: "organization_invites" */
  delete_organization_invites?: Maybe<Organization_Invites_Mutation_Response>;
  /** delete single row from the table: "organization_invites" */
  delete_organization_invites_by_pk?: Maybe<Organization_Invites>;
  /** delete data from the table: "organization_member" */
  delete_organization_member?: Maybe<Organization_Member_Mutation_Response>;
  /** delete single row from the table: "organization_member" */
  delete_organization_member_by_pk?: Maybe<Organization_Member>;
  /** delete data from the table: "payment_methods" */
  delete_payment_methods?: Maybe<Payment_Methods_Mutation_Response>;
  /** delete single row from the table: "payment_methods" */
  delete_payment_methods_by_pk?: Maybe<Payment_Methods>;
  /** delete data from the table: "private_course_booking" */
  delete_private_course_booking?: Maybe<Private_Course_Booking_Mutation_Response>;
  /** delete single row from the table: "private_course_booking" */
  delete_private_course_booking_by_pk?: Maybe<Private_Course_Booking>;
  /** delete data from the table: "profile" */
  delete_profile?: Maybe<Profile_Mutation_Response>;
  /** delete single row from the table: "profile" */
  delete_profile_by_pk?: Maybe<Profile>;
  /** delete data from the table: "profile_role" */
  delete_profile_role?: Maybe<Profile_Role_Mutation_Response>;
  /** delete single row from the table: "profile_role" */
  delete_profile_role_by_pk?: Maybe<Profile_Role>;
  /** delete data from the table: "profile_temp" */
  delete_profile_temp?: Maybe<Profile_Temp_Mutation_Response>;
  /** delete single row from the table: "profile_temp" */
  delete_profile_temp_by_pk?: Maybe<Profile_Temp>;
  /** delete data from the table: "profile_trainer_role_type" */
  delete_profile_trainer_role_type?: Maybe<Profile_Trainer_Role_Type_Mutation_Response>;
  /** delete single row from the table: "profile_trainer_role_type" */
  delete_profile_trainer_role_type_by_pk?: Maybe<Profile_Trainer_Role_Type>;
  /** delete data from the table: "promo_code" */
  delete_promo_code?: Maybe<Promo_Code_Mutation_Response>;
  /** delete single row from the table: "promo_code" */
  delete_promo_code_by_pk?: Maybe<Promo_Code>;
  /** delete data from the table: "promo_code_type" */
  delete_promo_code_type?: Maybe<Promo_Code_Type_Mutation_Response>;
  /** delete single row from the table: "promo_code_type" */
  delete_promo_code_type_by_pk?: Maybe<Promo_Code_Type>;
  /** delete data from the table: "role" */
  delete_role?: Maybe<Role_Mutation_Response>;
  /** delete single row from the table: "role" */
  delete_role_by_pk?: Maybe<Role>;
  /** delete data from the table: "trainer_role_type" */
  delete_trainer_role_type?: Maybe<Trainer_Role_Type_Mutation_Response>;
  /** delete single row from the table: "trainer_role_type" */
  delete_trainer_role_type_by_pk?: Maybe<Trainer_Role_Type>;
  /** delete data from the table: "trust_type" */
  delete_trust_type?: Maybe<Trust_Type_Mutation_Response>;
  /** delete single row from the table: "trust_type" */
  delete_trust_type_by_pk?: Maybe<Trust_Type>;
  /** delete data from the table: "venue" */
  delete_venue?: Maybe<Venue_Mutation_Response>;
  /** delete single row from the table: "venue" */
  delete_venue_by_pk?: Maybe<Venue>;
  /** delete data from the table: "waitlist" */
  delete_waitlist?: Maybe<Waitlist_Mutation_Response>;
  /** delete single row from the table: "waitlist" */
  delete_waitlist_by_pk?: Maybe<Waitlist>;
  /** delete data from the table: "xero_credential" */
  delete_xero_credential?: Maybe<Xero_Credential_Mutation_Response>;
  /** delete single row from the table: "xero_credential" */
  delete_xero_credential_by_pk?: Maybe<Xero_Credential>;
  /** go1LicensesChange */
  go1LicensesChange?: Maybe<Go1LicensesChangeOutput>;
  /** insert data into the table: "availability" */
  insert_availability?: Maybe<Availability_Mutation_Response>;
  /** insert a single row into the table: "availability" */
  insert_availability_one?: Maybe<Availability>;
  /** insert data into the table: "blended_learning_status" */
  insert_blended_learning_status?: Maybe<Blended_Learning_Status_Mutation_Response>;
  /** insert a single row into the table: "blended_learning_status" */
  insert_blended_learning_status_one?: Maybe<Blended_Learning_Status>;
  /** insert data into the table: "certificate_status" */
  insert_certificate_status?: Maybe<Certificate_Status_Mutation_Response>;
  /** insert a single row into the table: "certificate_status" */
  insert_certificate_status_one?: Maybe<Certificate_Status>;
  /** insert data into the table: "color" */
  insert_color?: Maybe<Color_Mutation_Response>;
  /** insert a single row into the table: "color" */
  insert_color_one?: Maybe<Color>;
  /** insert data into the table: "course" */
  insert_course?: Maybe<Course_Mutation_Response>;
  /** insert data into the table: "course_audit" */
  insert_course_audit?: Maybe<Course_Audit_Mutation_Response>;
  /** insert a single row into the table: "course_audit" */
  insert_course_audit_one?: Maybe<Course_Audit>;
  /** insert data into the table: "course_audit_type" */
  insert_course_audit_type?: Maybe<Course_Audit_Type_Mutation_Response>;
  /** insert a single row into the table: "course_audit_type" */
  insert_course_audit_type_one?: Maybe<Course_Audit_Type>;
  /** insert data into the table: "course_cancellation_request" */
  insert_course_cancellation_request?: Maybe<Course_Cancellation_Request_Mutation_Response>;
  /** insert a single row into the table: "course_cancellation_request" */
  insert_course_cancellation_request_one?: Maybe<Course_Cancellation_Request>;
  /** insert data into the table: "course_certificate" */
  insert_course_certificate?: Maybe<Course_Certificate_Mutation_Response>;
  /** insert data into the table: "course_certificate_changelog" */
  insert_course_certificate_changelog?: Maybe<Course_Certificate_Changelog_Mutation_Response>;
  /** insert a single row into the table: "course_certificate_changelog" */
  insert_course_certificate_changelog_one?: Maybe<Course_Certificate_Changelog>;
  /** insert a single row into the table: "course_certificate" */
  insert_course_certificate_one?: Maybe<Course_Certificate>;
  /** insert data into the table: "course_delivery_type" */
  insert_course_delivery_type?: Maybe<Course_Delivery_Type_Mutation_Response>;
  /** insert a single row into the table: "course_delivery_type" */
  insert_course_delivery_type_one?: Maybe<Course_Delivery_Type>;
  /** insert data into the table: "course_draft" */
  insert_course_draft?: Maybe<Course_Draft_Mutation_Response>;
  /** insert a single row into the table: "course_draft" */
  insert_course_draft_one?: Maybe<Course_Draft>;
  /** insert data into the table: "course_end_jobs" */
  insert_course_end_jobs?: Maybe<Course_End_Jobs_Mutation_Response>;
  /** insert a single row into the table: "course_end_jobs" */
  insert_course_end_jobs_one?: Maybe<Course_End_Jobs>;
  /** insert data into the table: "course_enquiry" */
  insert_course_enquiry?: Maybe<Course_Enquiry_Mutation_Response>;
  /** insert a single row into the table: "course_enquiry" */
  insert_course_enquiry_one?: Maybe<Course_Enquiry>;
  /** insert data into the table: "course_evaluation_answers" */
  insert_course_evaluation_answers?: Maybe<Course_Evaluation_Answers_Mutation_Response>;
  /** insert a single row into the table: "course_evaluation_answers" */
  insert_course_evaluation_answers_one?: Maybe<Course_Evaluation_Answers>;
  /** insert data into the table: "course_evaluation_question_group" */
  insert_course_evaluation_question_group?: Maybe<Course_Evaluation_Question_Group_Mutation_Response>;
  /** insert a single row into the table: "course_evaluation_question_group" */
  insert_course_evaluation_question_group_one?: Maybe<Course_Evaluation_Question_Group>;
  /** insert data into the table: "course_evaluation_question_type" */
  insert_course_evaluation_question_type?: Maybe<Course_Evaluation_Question_Type_Mutation_Response>;
  /** insert a single row into the table: "course_evaluation_question_type" */
  insert_course_evaluation_question_type_one?: Maybe<Course_Evaluation_Question_Type>;
  /** insert data into the table: "course_evaluation_questions" */
  insert_course_evaluation_questions?: Maybe<Course_Evaluation_Questions_Mutation_Response>;
  /** insert a single row into the table: "course_evaluation_questions" */
  insert_course_evaluation_questions_one?: Maybe<Course_Evaluation_Questions>;
  /** insert data into the table: "course_expenses" */
  insert_course_expenses?: Maybe<Course_Expenses_Mutation_Response>;
  /** insert a single row into the table: "course_expenses" */
  insert_course_expenses_one?: Maybe<Course_Expenses>;
  /** insert data into the table: "course_invite_status" */
  insert_course_invite_status?: Maybe<Course_Invite_Status_Mutation_Response>;
  /** insert a single row into the table: "course_invite_status" */
  insert_course_invite_status_one?: Maybe<Course_Invite_Status>;
  /** insert data into the table: "course_invites" */
  insert_course_invites?: Maybe<Course_Invites_Mutation_Response>;
  /** insert a single row into the table: "course_invites" */
  insert_course_invites_one?: Maybe<Course_Invites>;
  /** insert data into the table: "course_level" */
  insert_course_level?: Maybe<Course_Level_Mutation_Response>;
  /** insert a single row into the table: "course_level" */
  insert_course_level_one?: Maybe<Course_Level>;
  /** insert data into the table: "course_level_prefix" */
  insert_course_level_prefix?: Maybe<Course_Level_Prefix_Mutation_Response>;
  /** insert a single row into the table: "course_level_prefix" */
  insert_course_level_prefix_one?: Maybe<Course_Level_Prefix>;
  /** insert data into the table: "course_module" */
  insert_course_module?: Maybe<Course_Module_Mutation_Response>;
  /** insert a single row into the table: "course_module" */
  insert_course_module_one?: Maybe<Course_Module>;
  /** insert a single row into the table: "course" */
  insert_course_one?: Maybe<Course>;
  /** insert data into the table: "course_participant" */
  insert_course_participant?: Maybe<Course_Participant_Mutation_Response>;
  /** insert data into the table: "course_participant_audit" */
  insert_course_participant_audit?: Maybe<Course_Participant_Audit_Mutation_Response>;
  /** insert a single row into the table: "course_participant_audit" */
  insert_course_participant_audit_one?: Maybe<Course_Participant_Audit>;
  /** insert data into the table: "course_participant_audit_type" */
  insert_course_participant_audit_type?: Maybe<Course_Participant_Audit_Type_Mutation_Response>;
  /** insert a single row into the table: "course_participant_audit_type" */
  insert_course_participant_audit_type_one?: Maybe<Course_Participant_Audit_Type>;
  /** insert data into the table: "course_participant_cancellation" */
  insert_course_participant_cancellation?: Maybe<Course_Participant_Cancellation_Mutation_Response>;
  /** insert a single row into the table: "course_participant_cancellation" */
  insert_course_participant_cancellation_one?: Maybe<Course_Participant_Cancellation>;
  /** insert data into the table: "course_participant_module" */
  insert_course_participant_module?: Maybe<Course_Participant_Module_Mutation_Response>;
  /** insert a single row into the table: "course_participant_module" */
  insert_course_participant_module_one?: Maybe<Course_Participant_Module>;
  /** insert a single row into the table: "course_participant" */
  insert_course_participant_one?: Maybe<Course_Participant>;
  /** insert data into the table: "course_pricing" */
  insert_course_pricing?: Maybe<Course_Pricing_Mutation_Response>;
  /** insert a single row into the table: "course_pricing" */
  insert_course_pricing_one?: Maybe<Course_Pricing>;
  /** insert data into the table: "course_promo_code" */
  insert_course_promo_code?: Maybe<Course_Promo_Code_Mutation_Response>;
  /** insert a single row into the table: "course_promo_code" */
  insert_course_promo_code_one?: Maybe<Course_Promo_Code>;
  /** insert data into the table: "course_schedule" */
  insert_course_schedule?: Maybe<Course_Schedule_Mutation_Response>;
  /** insert a single row into the table: "course_schedule" */
  insert_course_schedule_one?: Maybe<Course_Schedule>;
  /** insert data into the table: "course_status" */
  insert_course_status?: Maybe<Course_Status_Mutation_Response>;
  /** insert a single row into the table: "course_status" */
  insert_course_status_one?: Maybe<Course_Status>;
  /** insert data into the table: "course_trainer" */
  insert_course_trainer?: Maybe<Course_Trainer_Mutation_Response>;
  /** insert a single row into the table: "course_trainer" */
  insert_course_trainer_one?: Maybe<Course_Trainer>;
  /** insert data into the table: "course_trainer_type" */
  insert_course_trainer_type?: Maybe<Course_Trainer_Type_Mutation_Response>;
  /** insert a single row into the table: "course_trainer_type" */
  insert_course_trainer_type_one?: Maybe<Course_Trainer_Type>;
  /** insert data into the table: "course_type" */
  insert_course_type?: Maybe<Course_Type_Mutation_Response>;
  /** insert a single row into the table: "course_type" */
  insert_course_type_one?: Maybe<Course_Type>;
  /** insert data into the table: "course_type_prefix" */
  insert_course_type_prefix?: Maybe<Course_Type_Prefix_Mutation_Response>;
  /** insert a single row into the table: "course_type_prefix" */
  insert_course_type_prefix_one?: Maybe<Course_Type_Prefix>;
  /** insert data into the table: "dfe_establishment" */
  insert_dfe_establishment?: Maybe<Dfe_Establishment_Mutation_Response>;
  /** insert a single row into the table: "dfe_establishment" */
  insert_dfe_establishment_one?: Maybe<Dfe_Establishment>;
  /** insert data into the table: "expire_go1_license_jobs" */
  insert_expire_go1_license_jobs?: Maybe<Expire_Go1_License_Jobs_Mutation_Response>;
  /** insert a single row into the table: "expire_go1_license_jobs" */
  insert_expire_go1_license_jobs_one?: Maybe<Expire_Go1_License_Jobs>;
  /** insert data into the table: "go1_history_events" */
  insert_go1_history_events?: Maybe<Go1_History_Events_Mutation_Response>;
  /** insert a single row into the table: "go1_history_events" */
  insert_go1_history_events_one?: Maybe<Go1_History_Events>;
  /** insert data into the table: "go1_licenses" */
  insert_go1_licenses?: Maybe<Go1_Licenses_Mutation_Response>;
  /** insert data into the table: "go1_licenses_history" */
  insert_go1_licenses_history?: Maybe<Go1_Licenses_History_Mutation_Response>;
  /** insert a single row into the table: "go1_licenses_history" */
  insert_go1_licenses_history_one?: Maybe<Go1_Licenses_History>;
  /** insert a single row into the table: "go1_licenses" */
  insert_go1_licenses_one?: Maybe<Go1_Licenses>;
  /** insert data into the table: "grade" */
  insert_grade?: Maybe<Grade_Mutation_Response>;
  /** insert a single row into the table: "grade" */
  insert_grade_one?: Maybe<Grade>;
  /** insert data into the table: "identity" */
  insert_identity?: Maybe<Identity_Mutation_Response>;
  /** insert a single row into the table: "identity" */
  insert_identity_one?: Maybe<Identity>;
  /** insert data into the table: "identity_type" */
  insert_identity_type?: Maybe<Identity_Type_Mutation_Response>;
  /** insert a single row into the table: "identity_type" */
  insert_identity_type_one?: Maybe<Identity_Type>;
  /** insert data into the table: "legacy_certificate" */
  insert_legacy_certificate?: Maybe<Legacy_Certificate_Mutation_Response>;
  /** insert a single row into the table: "legacy_certificate" */
  insert_legacy_certificate_one?: Maybe<Legacy_Certificate>;
  /** insert data into the table: "module" */
  insert_module?: Maybe<Module_Mutation_Response>;
  /** insert data into the table: "module_category" */
  insert_module_category?: Maybe<Module_Category_Mutation_Response>;
  /** insert a single row into the table: "module_category" */
  insert_module_category_one?: Maybe<Module_Category>;
  /** insert data into the table: "module_group" */
  insert_module_group?: Maybe<Module_Group_Mutation_Response>;
  /** insert data into the table: "module_group_duration" */
  insert_module_group_duration?: Maybe<Module_Group_Duration_Mutation_Response>;
  /** insert a single row into the table: "module_group_duration" */
  insert_module_group_duration_one?: Maybe<Module_Group_Duration>;
  /** insert a single row into the table: "module_group" */
  insert_module_group_one?: Maybe<Module_Group>;
  /** insert a single row into the table: "module" */
  insert_module_one?: Maybe<Module>;
  /** insert data into the table: "order" */
  insert_order?: Maybe<Order_Mutation_Response>;
  /** insert a single row into the table: "order" */
  insert_order_one?: Maybe<Order>;
  /** insert data into the table: "organization" */
  insert_organization?: Maybe<Organization_Mutation_Response>;
  /** insert data into the table: "organization_invites" */
  insert_organization_invites?: Maybe<Organization_Invites_Mutation_Response>;
  /** insert a single row into the table: "organization_invites" */
  insert_organization_invites_one?: Maybe<Organization_Invites>;
  /** insert data into the table: "organization_member" */
  insert_organization_member?: Maybe<Organization_Member_Mutation_Response>;
  /** insert a single row into the table: "organization_member" */
  insert_organization_member_one?: Maybe<Organization_Member>;
  /** insert a single row into the table: "organization" */
  insert_organization_one?: Maybe<Organization>;
  /** insert data into the table: "payment_methods" */
  insert_payment_methods?: Maybe<Payment_Methods_Mutation_Response>;
  /** insert a single row into the table: "payment_methods" */
  insert_payment_methods_one?: Maybe<Payment_Methods>;
  /** insert data into the table: "private_course_booking" */
  insert_private_course_booking?: Maybe<Private_Course_Booking_Mutation_Response>;
  /** insert a single row into the table: "private_course_booking" */
  insert_private_course_booking_one?: Maybe<Private_Course_Booking>;
  /** insert data into the table: "profile" */
  insert_profile?: Maybe<Profile_Mutation_Response>;
  /** insert a single row into the table: "profile" */
  insert_profile_one?: Maybe<Profile>;
  /** insert data into the table: "profile_role" */
  insert_profile_role?: Maybe<Profile_Role_Mutation_Response>;
  /** insert a single row into the table: "profile_role" */
  insert_profile_role_one?: Maybe<Profile_Role>;
  /** insert data into the table: "profile_temp" */
  insert_profile_temp?: Maybe<Profile_Temp_Mutation_Response>;
  /** insert a single row into the table: "profile_temp" */
  insert_profile_temp_one?: Maybe<Profile_Temp>;
  /** insert data into the table: "profile_trainer_role_type" */
  insert_profile_trainer_role_type?: Maybe<Profile_Trainer_Role_Type_Mutation_Response>;
  /** insert a single row into the table: "profile_trainer_role_type" */
  insert_profile_trainer_role_type_one?: Maybe<Profile_Trainer_Role_Type>;
  /** insert data into the table: "promo_code" */
  insert_promo_code?: Maybe<Promo_Code_Mutation_Response>;
  /** insert a single row into the table: "promo_code" */
  insert_promo_code_one?: Maybe<Promo_Code>;
  /** insert data into the table: "promo_code_type" */
  insert_promo_code_type?: Maybe<Promo_Code_Type_Mutation_Response>;
  /** insert a single row into the table: "promo_code_type" */
  insert_promo_code_type_one?: Maybe<Promo_Code_Type>;
  /** insert data into the table: "role" */
  insert_role?: Maybe<Role_Mutation_Response>;
  /** insert a single row into the table: "role" */
  insert_role_one?: Maybe<Role>;
  /** insert data into the table: "trainer_role_type" */
  insert_trainer_role_type?: Maybe<Trainer_Role_Type_Mutation_Response>;
  /** insert a single row into the table: "trainer_role_type" */
  insert_trainer_role_type_one?: Maybe<Trainer_Role_Type>;
  /** insert data into the table: "trust_type" */
  insert_trust_type?: Maybe<Trust_Type_Mutation_Response>;
  /** insert a single row into the table: "trust_type" */
  insert_trust_type_one?: Maybe<Trust_Type>;
  /** insert data into the table: "venue" */
  insert_venue?: Maybe<Venue_Mutation_Response>;
  /** insert a single row into the table: "venue" */
  insert_venue_one?: Maybe<Venue>;
  /** insert data into the table: "waitlist" */
  insert_waitlist?: Maybe<Waitlist_Mutation_Response>;
  /** insert a single row into the table: "waitlist" */
  insert_waitlist_one?: Maybe<Waitlist>;
  /** insert data into the table: "xero_credential" */
  insert_xero_credential?: Maybe<Xero_Credential_Mutation_Response>;
  /** insert a single row into the table: "xero_credential" */
  insert_xero_credential_one?: Maybe<Xero_Credential>;
  /** Creates a membership plan */
  plansCreate?: Maybe<PlansCreateResult>;
  /** replaceParticipant */
  replaceParticipant?: Maybe<ReplaceParticipantOutput>;
  resendPassword: Scalars['Boolean'];
  stripeCreatePaymentIntent?: Maybe<StripeCreatePaymentIntentOutput>;
  /** transferParticipant */
  transferParticipant?: Maybe<TransferParticipantOutput>;
  updateAvatar?: Maybe<UpdateAvatarResponse>;
  /** update data of the table: "availability" */
  update_availability?: Maybe<Availability_Mutation_Response>;
  /** update single row of the table: "availability" */
  update_availability_by_pk?: Maybe<Availability>;
  /** update data of the table: "blended_learning_status" */
  update_blended_learning_status?: Maybe<Blended_Learning_Status_Mutation_Response>;
  /** update single row of the table: "blended_learning_status" */
  update_blended_learning_status_by_pk?: Maybe<Blended_Learning_Status>;
  /** update data of the table: "certificate_status" */
  update_certificate_status?: Maybe<Certificate_Status_Mutation_Response>;
  /** update single row of the table: "certificate_status" */
  update_certificate_status_by_pk?: Maybe<Certificate_Status>;
  /** update data of the table: "color" */
  update_color?: Maybe<Color_Mutation_Response>;
  /** update single row of the table: "color" */
  update_color_by_pk?: Maybe<Color>;
  /** update data of the table: "course" */
  update_course?: Maybe<Course_Mutation_Response>;
  /** update data of the table: "course_audit" */
  update_course_audit?: Maybe<Course_Audit_Mutation_Response>;
  /** update single row of the table: "course_audit" */
  update_course_audit_by_pk?: Maybe<Course_Audit>;
  /** update data of the table: "course_audit_type" */
  update_course_audit_type?: Maybe<Course_Audit_Type_Mutation_Response>;
  /** update single row of the table: "course_audit_type" */
  update_course_audit_type_by_pk?: Maybe<Course_Audit_Type>;
  /** update single row of the table: "course" */
  update_course_by_pk?: Maybe<Course>;
  /** update data of the table: "course_cancellation_request" */
  update_course_cancellation_request?: Maybe<Course_Cancellation_Request_Mutation_Response>;
  /** update single row of the table: "course_cancellation_request" */
  update_course_cancellation_request_by_pk?: Maybe<Course_Cancellation_Request>;
  /** update data of the table: "course_certificate" */
  update_course_certificate?: Maybe<Course_Certificate_Mutation_Response>;
  /** update single row of the table: "course_certificate" */
  update_course_certificate_by_pk?: Maybe<Course_Certificate>;
  /** update data of the table: "course_certificate_changelog" */
  update_course_certificate_changelog?: Maybe<Course_Certificate_Changelog_Mutation_Response>;
  /** update single row of the table: "course_certificate_changelog" */
  update_course_certificate_changelog_by_pk?: Maybe<Course_Certificate_Changelog>;
  /** update data of the table: "course_delivery_type" */
  update_course_delivery_type?: Maybe<Course_Delivery_Type_Mutation_Response>;
  /** update single row of the table: "course_delivery_type" */
  update_course_delivery_type_by_pk?: Maybe<Course_Delivery_Type>;
  /** update data of the table: "course_draft" */
  update_course_draft?: Maybe<Course_Draft_Mutation_Response>;
  /** update single row of the table: "course_draft" */
  update_course_draft_by_pk?: Maybe<Course_Draft>;
  /** update data of the table: "course_end_jobs" */
  update_course_end_jobs?: Maybe<Course_End_Jobs_Mutation_Response>;
  /** update single row of the table: "course_end_jobs" */
  update_course_end_jobs_by_pk?: Maybe<Course_End_Jobs>;
  /** update data of the table: "course_enquiry" */
  update_course_enquiry?: Maybe<Course_Enquiry_Mutation_Response>;
  /** update single row of the table: "course_enquiry" */
  update_course_enquiry_by_pk?: Maybe<Course_Enquiry>;
  /** update data of the table: "course_evaluation_answers" */
  update_course_evaluation_answers?: Maybe<Course_Evaluation_Answers_Mutation_Response>;
  /** update single row of the table: "course_evaluation_answers" */
  update_course_evaluation_answers_by_pk?: Maybe<Course_Evaluation_Answers>;
  /** update data of the table: "course_evaluation_question_group" */
  update_course_evaluation_question_group?: Maybe<Course_Evaluation_Question_Group_Mutation_Response>;
  /** update single row of the table: "course_evaluation_question_group" */
  update_course_evaluation_question_group_by_pk?: Maybe<Course_Evaluation_Question_Group>;
  /** update data of the table: "course_evaluation_question_type" */
  update_course_evaluation_question_type?: Maybe<Course_Evaluation_Question_Type_Mutation_Response>;
  /** update single row of the table: "course_evaluation_question_type" */
  update_course_evaluation_question_type_by_pk?: Maybe<Course_Evaluation_Question_Type>;
  /** update data of the table: "course_evaluation_questions" */
  update_course_evaluation_questions?: Maybe<Course_Evaluation_Questions_Mutation_Response>;
  /** update single row of the table: "course_evaluation_questions" */
  update_course_evaluation_questions_by_pk?: Maybe<Course_Evaluation_Questions>;
  /** update data of the table: "course_expenses" */
  update_course_expenses?: Maybe<Course_Expenses_Mutation_Response>;
  /** update single row of the table: "course_expenses" */
  update_course_expenses_by_pk?: Maybe<Course_Expenses>;
  /** update data of the table: "course_invite_status" */
  update_course_invite_status?: Maybe<Course_Invite_Status_Mutation_Response>;
  /** update single row of the table: "course_invite_status" */
  update_course_invite_status_by_pk?: Maybe<Course_Invite_Status>;
  /** update data of the table: "course_invites" */
  update_course_invites?: Maybe<Course_Invites_Mutation_Response>;
  /** update single row of the table: "course_invites" */
  update_course_invites_by_pk?: Maybe<Course_Invites>;
  /** update data of the table: "course_level" */
  update_course_level?: Maybe<Course_Level_Mutation_Response>;
  /** update single row of the table: "course_level" */
  update_course_level_by_pk?: Maybe<Course_Level>;
  /** update data of the table: "course_level_prefix" */
  update_course_level_prefix?: Maybe<Course_Level_Prefix_Mutation_Response>;
  /** update single row of the table: "course_level_prefix" */
  update_course_level_prefix_by_pk?: Maybe<Course_Level_Prefix>;
  /** update data of the table: "course_module" */
  update_course_module?: Maybe<Course_Module_Mutation_Response>;
  /** update single row of the table: "course_module" */
  update_course_module_by_pk?: Maybe<Course_Module>;
  /** update data of the table: "course_participant" */
  update_course_participant?: Maybe<Course_Participant_Mutation_Response>;
  /** update data of the table: "course_participant_audit" */
  update_course_participant_audit?: Maybe<Course_Participant_Audit_Mutation_Response>;
  /** update single row of the table: "course_participant_audit" */
  update_course_participant_audit_by_pk?: Maybe<Course_Participant_Audit>;
  /** update data of the table: "course_participant_audit_type" */
  update_course_participant_audit_type?: Maybe<Course_Participant_Audit_Type_Mutation_Response>;
  /** update single row of the table: "course_participant_audit_type" */
  update_course_participant_audit_type_by_pk?: Maybe<Course_Participant_Audit_Type>;
  /** update single row of the table: "course_participant" */
  update_course_participant_by_pk?: Maybe<Course_Participant>;
  /** update data of the table: "course_participant_cancellation" */
  update_course_participant_cancellation?: Maybe<Course_Participant_Cancellation_Mutation_Response>;
  /** update single row of the table: "course_participant_cancellation" */
  update_course_participant_cancellation_by_pk?: Maybe<Course_Participant_Cancellation>;
  /** update data of the table: "course_participant_module" */
  update_course_participant_module?: Maybe<Course_Participant_Module_Mutation_Response>;
  /** update single row of the table: "course_participant_module" */
  update_course_participant_module_by_pk?: Maybe<Course_Participant_Module>;
  /** update data of the table: "course_pricing" */
  update_course_pricing?: Maybe<Course_Pricing_Mutation_Response>;
  /** update single row of the table: "course_pricing" */
  update_course_pricing_by_pk?: Maybe<Course_Pricing>;
  /** update data of the table: "course_promo_code" */
  update_course_promo_code?: Maybe<Course_Promo_Code_Mutation_Response>;
  /** update single row of the table: "course_promo_code" */
  update_course_promo_code_by_pk?: Maybe<Course_Promo_Code>;
  /** update data of the table: "course_schedule" */
  update_course_schedule?: Maybe<Course_Schedule_Mutation_Response>;
  /** update single row of the table: "course_schedule" */
  update_course_schedule_by_pk?: Maybe<Course_Schedule>;
  /** update data of the table: "course_status" */
  update_course_status?: Maybe<Course_Status_Mutation_Response>;
  /** update single row of the table: "course_status" */
  update_course_status_by_pk?: Maybe<Course_Status>;
  /** update data of the table: "course_trainer" */
  update_course_trainer?: Maybe<Course_Trainer_Mutation_Response>;
  /** update single row of the table: "course_trainer" */
  update_course_trainer_by_pk?: Maybe<Course_Trainer>;
  /** update data of the table: "course_trainer_type" */
  update_course_trainer_type?: Maybe<Course_Trainer_Type_Mutation_Response>;
  /** update single row of the table: "course_trainer_type" */
  update_course_trainer_type_by_pk?: Maybe<Course_Trainer_Type>;
  /** update data of the table: "course_type" */
  update_course_type?: Maybe<Course_Type_Mutation_Response>;
  /** update single row of the table: "course_type" */
  update_course_type_by_pk?: Maybe<Course_Type>;
  /** update data of the table: "course_type_prefix" */
  update_course_type_prefix?: Maybe<Course_Type_Prefix_Mutation_Response>;
  /** update single row of the table: "course_type_prefix" */
  update_course_type_prefix_by_pk?: Maybe<Course_Type_Prefix>;
  /** update data of the table: "dfe_establishment" */
  update_dfe_establishment?: Maybe<Dfe_Establishment_Mutation_Response>;
  /** update single row of the table: "dfe_establishment" */
  update_dfe_establishment_by_pk?: Maybe<Dfe_Establishment>;
  /** update data of the table: "expire_go1_license_jobs" */
  update_expire_go1_license_jobs?: Maybe<Expire_Go1_License_Jobs_Mutation_Response>;
  /** update single row of the table: "expire_go1_license_jobs" */
  update_expire_go1_license_jobs_by_pk?: Maybe<Expire_Go1_License_Jobs>;
  /** update data of the table: "go1_history_events" */
  update_go1_history_events?: Maybe<Go1_History_Events_Mutation_Response>;
  /** update single row of the table: "go1_history_events" */
  update_go1_history_events_by_pk?: Maybe<Go1_History_Events>;
  /** update data of the table: "go1_licenses" */
  update_go1_licenses?: Maybe<Go1_Licenses_Mutation_Response>;
  /** update single row of the table: "go1_licenses" */
  update_go1_licenses_by_pk?: Maybe<Go1_Licenses>;
  /** update data of the table: "go1_licenses_history" */
  update_go1_licenses_history?: Maybe<Go1_Licenses_History_Mutation_Response>;
  /** update single row of the table: "go1_licenses_history" */
  update_go1_licenses_history_by_pk?: Maybe<Go1_Licenses_History>;
  /** update data of the table: "grade" */
  update_grade?: Maybe<Grade_Mutation_Response>;
  /** update single row of the table: "grade" */
  update_grade_by_pk?: Maybe<Grade>;
  /** update data of the table: "identity" */
  update_identity?: Maybe<Identity_Mutation_Response>;
  /** update single row of the table: "identity" */
  update_identity_by_pk?: Maybe<Identity>;
  /** update data of the table: "identity_type" */
  update_identity_type?: Maybe<Identity_Type_Mutation_Response>;
  /** update single row of the table: "identity_type" */
  update_identity_type_by_pk?: Maybe<Identity_Type>;
  /** update data of the table: "legacy_certificate" */
  update_legacy_certificate?: Maybe<Legacy_Certificate_Mutation_Response>;
  /** update single row of the table: "legacy_certificate" */
  update_legacy_certificate_by_pk?: Maybe<Legacy_Certificate>;
  /** update data of the table: "module" */
  update_module?: Maybe<Module_Mutation_Response>;
  /** update single row of the table: "module" */
  update_module_by_pk?: Maybe<Module>;
  /** update data of the table: "module_category" */
  update_module_category?: Maybe<Module_Category_Mutation_Response>;
  /** update single row of the table: "module_category" */
  update_module_category_by_pk?: Maybe<Module_Category>;
  /** update data of the table: "module_group" */
  update_module_group?: Maybe<Module_Group_Mutation_Response>;
  /** update single row of the table: "module_group" */
  update_module_group_by_pk?: Maybe<Module_Group>;
  /** update data of the table: "module_group_duration" */
  update_module_group_duration?: Maybe<Module_Group_Duration_Mutation_Response>;
  /** update single row of the table: "module_group_duration" */
  update_module_group_duration_by_pk?: Maybe<Module_Group_Duration>;
  /** update data of the table: "order" */
  update_order?: Maybe<Order_Mutation_Response>;
  /** update single row of the table: "order" */
  update_order_by_pk?: Maybe<Order>;
  /** update data of the table: "organization" */
  update_organization?: Maybe<Organization_Mutation_Response>;
  /** update single row of the table: "organization" */
  update_organization_by_pk?: Maybe<Organization>;
  /** update data of the table: "organization_invites" */
  update_organization_invites?: Maybe<Organization_Invites_Mutation_Response>;
  /** update single row of the table: "organization_invites" */
  update_organization_invites_by_pk?: Maybe<Organization_Invites>;
  /** update data of the table: "organization_member" */
  update_organization_member?: Maybe<Organization_Member_Mutation_Response>;
  /** update single row of the table: "organization_member" */
  update_organization_member_by_pk?: Maybe<Organization_Member>;
  /** update data of the table: "payment_methods" */
  update_payment_methods?: Maybe<Payment_Methods_Mutation_Response>;
  /** update single row of the table: "payment_methods" */
  update_payment_methods_by_pk?: Maybe<Payment_Methods>;
  /** update data of the table: "private_course_booking" */
  update_private_course_booking?: Maybe<Private_Course_Booking_Mutation_Response>;
  /** update single row of the table: "private_course_booking" */
  update_private_course_booking_by_pk?: Maybe<Private_Course_Booking>;
  /** update data of the table: "profile" */
  update_profile?: Maybe<Profile_Mutation_Response>;
  /** update single row of the table: "profile" */
  update_profile_by_pk?: Maybe<Profile>;
  /** update data of the table: "profile_role" */
  update_profile_role?: Maybe<Profile_Role_Mutation_Response>;
  /** update single row of the table: "profile_role" */
  update_profile_role_by_pk?: Maybe<Profile_Role>;
  /** update data of the table: "profile_temp" */
  update_profile_temp?: Maybe<Profile_Temp_Mutation_Response>;
  /** update single row of the table: "profile_temp" */
  update_profile_temp_by_pk?: Maybe<Profile_Temp>;
  /** update data of the table: "profile_trainer_role_type" */
  update_profile_trainer_role_type?: Maybe<Profile_Trainer_Role_Type_Mutation_Response>;
  /** update single row of the table: "profile_trainer_role_type" */
  update_profile_trainer_role_type_by_pk?: Maybe<Profile_Trainer_Role_Type>;
  /** update data of the table: "promo_code" */
  update_promo_code?: Maybe<Promo_Code_Mutation_Response>;
  /** update single row of the table: "promo_code" */
  update_promo_code_by_pk?: Maybe<Promo_Code>;
  /** update data of the table: "promo_code_type" */
  update_promo_code_type?: Maybe<Promo_Code_Type_Mutation_Response>;
  /** update single row of the table: "promo_code_type" */
  update_promo_code_type_by_pk?: Maybe<Promo_Code_Type>;
  /** update data of the table: "role" */
  update_role?: Maybe<Role_Mutation_Response>;
  /** update single row of the table: "role" */
  update_role_by_pk?: Maybe<Role>;
  /** update data of the table: "trainer_role_type" */
  update_trainer_role_type?: Maybe<Trainer_Role_Type_Mutation_Response>;
  /** update single row of the table: "trainer_role_type" */
  update_trainer_role_type_by_pk?: Maybe<Trainer_Role_Type>;
  /** update data of the table: "trust_type" */
  update_trust_type?: Maybe<Trust_Type_Mutation_Response>;
  /** update single row of the table: "trust_type" */
  update_trust_type_by_pk?: Maybe<Trust_Type>;
  /** update data of the table: "venue" */
  update_venue?: Maybe<Venue_Mutation_Response>;
  /** update single row of the table: "venue" */
  update_venue_by_pk?: Maybe<Venue>;
  /** update data of the table: "waitlist" */
  update_waitlist?: Maybe<Waitlist_Mutation_Response>;
  /** update single row of the table: "waitlist" */
  update_waitlist_by_pk?: Maybe<Waitlist>;
  /** update data of the table: "xero_credential" */
  update_xero_credential?: Maybe<Xero_Credential_Mutation_Response>;
  /** update single row of the table: "xero_credential" */
  update_xero_credential_by_pk?: Maybe<Xero_Credential>;
  /** Creates or updates Zoom meeting with start date */
  upsertZoomMeeting?: Maybe<UpsertZoomMeetingPayload>;
  verifyUser: Scalars['Boolean'];
  xeroCallback?: Maybe<XeroCallbackOutput>;
  xeroDisconnect?: Maybe<XeroDisconnectOutput>;
};


/** mutation root */
export type Mutation_RootAcceptOrgInviteArgs = {
  profileId: Scalars['String'];
};


/** mutation root */
export type Mutation_RootCancelIndividualFromCourseArgs = {
  courseId: Scalars['Int'];
  fee: Scalars['Int'];
  profileId: Scalars['uuid'];
  reason: Scalars['String'];
};


/** mutation root */
export type Mutation_RootCancelMyselfFromCourseArgs = {
  courseId: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootConfirmCreditCardPaymentArgs = {
  orderId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootCreateOrderArgs = {
  input: CreateOrderInput;
};


/** mutation root */
export type Mutation_RootCreateStripeSubscriptionArgs = {
  customerId: Scalars['String'];
  priceId: Scalars['String'];
};


/** mutation root */
export type Mutation_RootCreateUserArgs = {
  input: CreateAppUserInput;
};


/** mutation root */
export type Mutation_RootDeclineInviteArgs = {
  note?: InputMaybe<Scalars['String']>;
};


/** mutation root */
export type Mutation_RootDelete_AvailabilityArgs = {
  where: Availability_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Availability_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Blended_Learning_StatusArgs = {
  where: Blended_Learning_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Blended_Learning_Status_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Certificate_StatusArgs = {
  where: Certificate_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Certificate_Status_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_ColorArgs = {
  where: Color_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Color_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_CourseArgs = {
  where: Course_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_AuditArgs = {
  where: Course_Audit_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Audit_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Audit_TypeArgs = {
  where: Course_Audit_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Audit_Type_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Course_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Cancellation_RequestArgs = {
  where: Course_Cancellation_Request_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Cancellation_Request_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_CertificateArgs = {
  where: Course_Certificate_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Certificate_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Certificate_ChangelogArgs = {
  where: Course_Certificate_Changelog_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Certificate_Changelog_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Delivery_TypeArgs = {
  where: Course_Delivery_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Delivery_Type_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Course_DraftArgs = {
  where: Course_Draft_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Draft_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_End_JobsArgs = {
  where: Course_End_Jobs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_End_Jobs_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_EnquiryArgs = {
  where: Course_Enquiry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Enquiry_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Evaluation_AnswersArgs = {
  where: Course_Evaluation_Answers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Evaluation_Answers_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Evaluation_Question_GroupArgs = {
  where: Course_Evaluation_Question_Group_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Evaluation_Question_Group_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Evaluation_Question_TypeArgs = {
  where: Course_Evaluation_Question_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Evaluation_Question_Type_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Evaluation_QuestionsArgs = {
  where: Course_Evaluation_Questions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Evaluation_Questions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_ExpensesArgs = {
  where: Course_Expenses_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Expenses_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Invite_StatusArgs = {
  where: Course_Invite_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Invite_Status_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Course_InvitesArgs = {
  where: Course_Invites_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Invites_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_LevelArgs = {
  where: Course_Level_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Level_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Level_PrefixArgs = {
  where: Course_Level_Prefix_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Level_Prefix_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_ModuleArgs = {
  where: Course_Module_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Module_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_ParticipantArgs = {
  where: Course_Participant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Participant_AuditArgs = {
  where: Course_Participant_Audit_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Participant_Audit_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Participant_Audit_TypeArgs = {
  where: Course_Participant_Audit_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Participant_Audit_Type_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Participant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Participant_CancellationArgs = {
  where: Course_Participant_Cancellation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Participant_Cancellation_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Participant_ModuleArgs = {
  where: Course_Participant_Module_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Participant_Module_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_PricingArgs = {
  where: Course_Pricing_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Pricing_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Promo_CodeArgs = {
  where: Course_Promo_Code_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Promo_Code_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_ScheduleArgs = {
  where: Course_Schedule_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Schedule_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_StatusArgs = {
  where: Course_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Status_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Course_TrainerArgs = {
  where: Course_Trainer_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Trainer_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Trainer_TypeArgs = {
  where: Course_Trainer_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Trainer_Type_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Course_TypeArgs = {
  where: Course_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Type_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Course_Type_PrefixArgs = {
  where: Course_Type_Prefix_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Course_Type_Prefix_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Dfe_EstablishmentArgs = {
  where: Dfe_Establishment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Dfe_Establishment_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Expire_Go1_License_JobsArgs = {
  where: Expire_Go1_License_Jobs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Expire_Go1_License_Jobs_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Go1_History_EventsArgs = {
  where: Go1_History_Events_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Go1_History_Events_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Go1_LicensesArgs = {
  where: Go1_Licenses_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Go1_Licenses_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Go1_Licenses_HistoryArgs = {
  where: Go1_Licenses_History_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Go1_Licenses_History_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_GradeArgs = {
  where: Grade_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Grade_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_IdentityArgs = {
  where: Identity_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Identity_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Identity_TypeArgs = {
  where: Identity_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Identity_Type_By_PkArgs = {
  value: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Legacy_CertificateArgs = {
  where: Legacy_Certificate_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Legacy_Certificate_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ModuleArgs = {
  where: Module_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Module_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Module_CategoryArgs = {
  where: Module_Category_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Module_Category_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Module_GroupArgs = {
  where: Module_Group_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Module_Group_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Module_Group_DurationArgs = {
  where: Module_Group_Duration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Module_Group_Duration_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_OrderArgs = {
  where: Order_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Order_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_OrganizationArgs = {
  where: Organization_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Organization_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Organization_InvitesArgs = {
  where: Organization_Invites_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Organization_Invites_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Organization_MemberArgs = {
  where: Organization_Member_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Organization_Member_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Payment_MethodsArgs = {
  where: Payment_Methods_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Payment_Methods_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Private_Course_BookingArgs = {
  where: Private_Course_Booking_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Private_Course_Booking_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ProfileArgs = {
  where: Profile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Profile_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Profile_RoleArgs = {
  where: Profile_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Profile_Role_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Profile_TempArgs = {
  where: Profile_Temp_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Profile_Temp_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Profile_Trainer_Role_TypeArgs = {
  where: Profile_Trainer_Role_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Profile_Trainer_Role_Type_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Promo_CodeArgs = {
  where: Promo_Code_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Promo_Code_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Promo_Code_TypeArgs = {
  where: Promo_Code_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Promo_Code_Type_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_RoleArgs = {
  where: Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Role_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Trainer_Role_TypeArgs = {
  where: Trainer_Role_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Trainer_Role_Type_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Trust_TypeArgs = {
  where: Trust_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Trust_Type_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_VenueArgs = {
  where: Venue_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Venue_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_WaitlistArgs = {
  where: Waitlist_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Waitlist_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Xero_CredentialArgs = {
  where: Xero_Credential_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Xero_Credential_By_PkArgs = {
  client_id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootGo1LicensesChangeArgs = {
  input: Go1LicensesChangeInput;
};


/** mutation root */
export type Mutation_RootInsert_AvailabilityArgs = {
  objects: Array<Availability_Insert_Input>;
  on_conflict?: InputMaybe<Availability_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Availability_OneArgs = {
  object: Availability_Insert_Input;
  on_conflict?: InputMaybe<Availability_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Blended_Learning_StatusArgs = {
  objects: Array<Blended_Learning_Status_Insert_Input>;
  on_conflict?: InputMaybe<Blended_Learning_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Blended_Learning_Status_OneArgs = {
  object: Blended_Learning_Status_Insert_Input;
  on_conflict?: InputMaybe<Blended_Learning_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Certificate_StatusArgs = {
  objects: Array<Certificate_Status_Insert_Input>;
  on_conflict?: InputMaybe<Certificate_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Certificate_Status_OneArgs = {
  object: Certificate_Status_Insert_Input;
  on_conflict?: InputMaybe<Certificate_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ColorArgs = {
  objects: Array<Color_Insert_Input>;
  on_conflict?: InputMaybe<Color_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Color_OneArgs = {
  object: Color_Insert_Input;
  on_conflict?: InputMaybe<Color_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CourseArgs = {
  objects: Array<Course_Insert_Input>;
  on_conflict?: InputMaybe<Course_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_AuditArgs = {
  objects: Array<Course_Audit_Insert_Input>;
  on_conflict?: InputMaybe<Course_Audit_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Audit_OneArgs = {
  object: Course_Audit_Insert_Input;
  on_conflict?: InputMaybe<Course_Audit_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Audit_TypeArgs = {
  objects: Array<Course_Audit_Type_Insert_Input>;
  on_conflict?: InputMaybe<Course_Audit_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Audit_Type_OneArgs = {
  object: Course_Audit_Type_Insert_Input;
  on_conflict?: InputMaybe<Course_Audit_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Cancellation_RequestArgs = {
  objects: Array<Course_Cancellation_Request_Insert_Input>;
  on_conflict?: InputMaybe<Course_Cancellation_Request_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Cancellation_Request_OneArgs = {
  object: Course_Cancellation_Request_Insert_Input;
  on_conflict?: InputMaybe<Course_Cancellation_Request_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_CertificateArgs = {
  objects: Array<Course_Certificate_Insert_Input>;
  on_conflict?: InputMaybe<Course_Certificate_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Certificate_ChangelogArgs = {
  objects: Array<Course_Certificate_Changelog_Insert_Input>;
  on_conflict?: InputMaybe<Course_Certificate_Changelog_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Certificate_Changelog_OneArgs = {
  object: Course_Certificate_Changelog_Insert_Input;
  on_conflict?: InputMaybe<Course_Certificate_Changelog_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Certificate_OneArgs = {
  object: Course_Certificate_Insert_Input;
  on_conflict?: InputMaybe<Course_Certificate_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Delivery_TypeArgs = {
  objects: Array<Course_Delivery_Type_Insert_Input>;
  on_conflict?: InputMaybe<Course_Delivery_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Delivery_Type_OneArgs = {
  object: Course_Delivery_Type_Insert_Input;
  on_conflict?: InputMaybe<Course_Delivery_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_DraftArgs = {
  objects: Array<Course_Draft_Insert_Input>;
  on_conflict?: InputMaybe<Course_Draft_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Draft_OneArgs = {
  object: Course_Draft_Insert_Input;
  on_conflict?: InputMaybe<Course_Draft_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_End_JobsArgs = {
  objects: Array<Course_End_Jobs_Insert_Input>;
  on_conflict?: InputMaybe<Course_End_Jobs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_End_Jobs_OneArgs = {
  object: Course_End_Jobs_Insert_Input;
  on_conflict?: InputMaybe<Course_End_Jobs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_EnquiryArgs = {
  objects: Array<Course_Enquiry_Insert_Input>;
  on_conflict?: InputMaybe<Course_Enquiry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Enquiry_OneArgs = {
  object: Course_Enquiry_Insert_Input;
  on_conflict?: InputMaybe<Course_Enquiry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Evaluation_AnswersArgs = {
  objects: Array<Course_Evaluation_Answers_Insert_Input>;
  on_conflict?: InputMaybe<Course_Evaluation_Answers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Evaluation_Answers_OneArgs = {
  object: Course_Evaluation_Answers_Insert_Input;
  on_conflict?: InputMaybe<Course_Evaluation_Answers_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Evaluation_Question_GroupArgs = {
  objects: Array<Course_Evaluation_Question_Group_Insert_Input>;
  on_conflict?: InputMaybe<Course_Evaluation_Question_Group_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Evaluation_Question_Group_OneArgs = {
  object: Course_Evaluation_Question_Group_Insert_Input;
  on_conflict?: InputMaybe<Course_Evaluation_Question_Group_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Evaluation_Question_TypeArgs = {
  objects: Array<Course_Evaluation_Question_Type_Insert_Input>;
  on_conflict?: InputMaybe<Course_Evaluation_Question_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Evaluation_Question_Type_OneArgs = {
  object: Course_Evaluation_Question_Type_Insert_Input;
  on_conflict?: InputMaybe<Course_Evaluation_Question_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Evaluation_QuestionsArgs = {
  objects: Array<Course_Evaluation_Questions_Insert_Input>;
  on_conflict?: InputMaybe<Course_Evaluation_Questions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Evaluation_Questions_OneArgs = {
  object: Course_Evaluation_Questions_Insert_Input;
  on_conflict?: InputMaybe<Course_Evaluation_Questions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_ExpensesArgs = {
  objects: Array<Course_Expenses_Insert_Input>;
  on_conflict?: InputMaybe<Course_Expenses_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Expenses_OneArgs = {
  object: Course_Expenses_Insert_Input;
  on_conflict?: InputMaybe<Course_Expenses_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Invite_StatusArgs = {
  objects: Array<Course_Invite_Status_Insert_Input>;
  on_conflict?: InputMaybe<Course_Invite_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Invite_Status_OneArgs = {
  object: Course_Invite_Status_Insert_Input;
  on_conflict?: InputMaybe<Course_Invite_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_InvitesArgs = {
  objects: Array<Course_Invites_Insert_Input>;
  on_conflict?: InputMaybe<Course_Invites_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Invites_OneArgs = {
  object: Course_Invites_Insert_Input;
  on_conflict?: InputMaybe<Course_Invites_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_LevelArgs = {
  objects: Array<Course_Level_Insert_Input>;
  on_conflict?: InputMaybe<Course_Level_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Level_OneArgs = {
  object: Course_Level_Insert_Input;
  on_conflict?: InputMaybe<Course_Level_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Level_PrefixArgs = {
  objects: Array<Course_Level_Prefix_Insert_Input>;
  on_conflict?: InputMaybe<Course_Level_Prefix_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Level_Prefix_OneArgs = {
  object: Course_Level_Prefix_Insert_Input;
  on_conflict?: InputMaybe<Course_Level_Prefix_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_ModuleArgs = {
  objects: Array<Course_Module_Insert_Input>;
  on_conflict?: InputMaybe<Course_Module_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Module_OneArgs = {
  object: Course_Module_Insert_Input;
  on_conflict?: InputMaybe<Course_Module_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_OneArgs = {
  object: Course_Insert_Input;
  on_conflict?: InputMaybe<Course_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_ParticipantArgs = {
  objects: Array<Course_Participant_Insert_Input>;
  on_conflict?: InputMaybe<Course_Participant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Participant_AuditArgs = {
  objects: Array<Course_Participant_Audit_Insert_Input>;
  on_conflict?: InputMaybe<Course_Participant_Audit_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Participant_Audit_OneArgs = {
  object: Course_Participant_Audit_Insert_Input;
  on_conflict?: InputMaybe<Course_Participant_Audit_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Participant_Audit_TypeArgs = {
  objects: Array<Course_Participant_Audit_Type_Insert_Input>;
  on_conflict?: InputMaybe<Course_Participant_Audit_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Participant_Audit_Type_OneArgs = {
  object: Course_Participant_Audit_Type_Insert_Input;
  on_conflict?: InputMaybe<Course_Participant_Audit_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Participant_CancellationArgs = {
  objects: Array<Course_Participant_Cancellation_Insert_Input>;
  on_conflict?: InputMaybe<Course_Participant_Cancellation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Participant_Cancellation_OneArgs = {
  object: Course_Participant_Cancellation_Insert_Input;
  on_conflict?: InputMaybe<Course_Participant_Cancellation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Participant_ModuleArgs = {
  objects: Array<Course_Participant_Module_Insert_Input>;
  on_conflict?: InputMaybe<Course_Participant_Module_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Participant_Module_OneArgs = {
  object: Course_Participant_Module_Insert_Input;
  on_conflict?: InputMaybe<Course_Participant_Module_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Participant_OneArgs = {
  object: Course_Participant_Insert_Input;
  on_conflict?: InputMaybe<Course_Participant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_PricingArgs = {
  objects: Array<Course_Pricing_Insert_Input>;
  on_conflict?: InputMaybe<Course_Pricing_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Pricing_OneArgs = {
  object: Course_Pricing_Insert_Input;
  on_conflict?: InputMaybe<Course_Pricing_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Promo_CodeArgs = {
  objects: Array<Course_Promo_Code_Insert_Input>;
  on_conflict?: InputMaybe<Course_Promo_Code_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Promo_Code_OneArgs = {
  object: Course_Promo_Code_Insert_Input;
  on_conflict?: InputMaybe<Course_Promo_Code_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_ScheduleArgs = {
  objects: Array<Course_Schedule_Insert_Input>;
  on_conflict?: InputMaybe<Course_Schedule_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Schedule_OneArgs = {
  object: Course_Schedule_Insert_Input;
  on_conflict?: InputMaybe<Course_Schedule_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_StatusArgs = {
  objects: Array<Course_Status_Insert_Input>;
  on_conflict?: InputMaybe<Course_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Status_OneArgs = {
  object: Course_Status_Insert_Input;
  on_conflict?: InputMaybe<Course_Status_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_TrainerArgs = {
  objects: Array<Course_Trainer_Insert_Input>;
  on_conflict?: InputMaybe<Course_Trainer_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Trainer_OneArgs = {
  object: Course_Trainer_Insert_Input;
  on_conflict?: InputMaybe<Course_Trainer_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Trainer_TypeArgs = {
  objects: Array<Course_Trainer_Type_Insert_Input>;
  on_conflict?: InputMaybe<Course_Trainer_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Trainer_Type_OneArgs = {
  object: Course_Trainer_Type_Insert_Input;
  on_conflict?: InputMaybe<Course_Trainer_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_TypeArgs = {
  objects: Array<Course_Type_Insert_Input>;
  on_conflict?: InputMaybe<Course_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Type_OneArgs = {
  object: Course_Type_Insert_Input;
  on_conflict?: InputMaybe<Course_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Type_PrefixArgs = {
  objects: Array<Course_Type_Prefix_Insert_Input>;
  on_conflict?: InputMaybe<Course_Type_Prefix_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Course_Type_Prefix_OneArgs = {
  object: Course_Type_Prefix_Insert_Input;
  on_conflict?: InputMaybe<Course_Type_Prefix_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Dfe_EstablishmentArgs = {
  objects: Array<Dfe_Establishment_Insert_Input>;
  on_conflict?: InputMaybe<Dfe_Establishment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Dfe_Establishment_OneArgs = {
  object: Dfe_Establishment_Insert_Input;
  on_conflict?: InputMaybe<Dfe_Establishment_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Expire_Go1_License_JobsArgs = {
  objects: Array<Expire_Go1_License_Jobs_Insert_Input>;
  on_conflict?: InputMaybe<Expire_Go1_License_Jobs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Expire_Go1_License_Jobs_OneArgs = {
  object: Expire_Go1_License_Jobs_Insert_Input;
  on_conflict?: InputMaybe<Expire_Go1_License_Jobs_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Go1_History_EventsArgs = {
  objects: Array<Go1_History_Events_Insert_Input>;
  on_conflict?: InputMaybe<Go1_History_Events_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Go1_History_Events_OneArgs = {
  object: Go1_History_Events_Insert_Input;
  on_conflict?: InputMaybe<Go1_History_Events_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Go1_LicensesArgs = {
  objects: Array<Go1_Licenses_Insert_Input>;
  on_conflict?: InputMaybe<Go1_Licenses_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Go1_Licenses_HistoryArgs = {
  objects: Array<Go1_Licenses_History_Insert_Input>;
  on_conflict?: InputMaybe<Go1_Licenses_History_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Go1_Licenses_History_OneArgs = {
  object: Go1_Licenses_History_Insert_Input;
  on_conflict?: InputMaybe<Go1_Licenses_History_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Go1_Licenses_OneArgs = {
  object: Go1_Licenses_Insert_Input;
  on_conflict?: InputMaybe<Go1_Licenses_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_GradeArgs = {
  objects: Array<Grade_Insert_Input>;
  on_conflict?: InputMaybe<Grade_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Grade_OneArgs = {
  object: Grade_Insert_Input;
  on_conflict?: InputMaybe<Grade_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_IdentityArgs = {
  objects: Array<Identity_Insert_Input>;
  on_conflict?: InputMaybe<Identity_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Identity_OneArgs = {
  object: Identity_Insert_Input;
  on_conflict?: InputMaybe<Identity_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Identity_TypeArgs = {
  objects: Array<Identity_Type_Insert_Input>;
  on_conflict?: InputMaybe<Identity_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Identity_Type_OneArgs = {
  object: Identity_Type_Insert_Input;
  on_conflict?: InputMaybe<Identity_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Legacy_CertificateArgs = {
  objects: Array<Legacy_Certificate_Insert_Input>;
  on_conflict?: InputMaybe<Legacy_Certificate_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Legacy_Certificate_OneArgs = {
  object: Legacy_Certificate_Insert_Input;
  on_conflict?: InputMaybe<Legacy_Certificate_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ModuleArgs = {
  objects: Array<Module_Insert_Input>;
  on_conflict?: InputMaybe<Module_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Module_CategoryArgs = {
  objects: Array<Module_Category_Insert_Input>;
  on_conflict?: InputMaybe<Module_Category_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Module_Category_OneArgs = {
  object: Module_Category_Insert_Input;
  on_conflict?: InputMaybe<Module_Category_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Module_GroupArgs = {
  objects: Array<Module_Group_Insert_Input>;
  on_conflict?: InputMaybe<Module_Group_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Module_Group_DurationArgs = {
  objects: Array<Module_Group_Duration_Insert_Input>;
  on_conflict?: InputMaybe<Module_Group_Duration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Module_Group_Duration_OneArgs = {
  object: Module_Group_Duration_Insert_Input;
  on_conflict?: InputMaybe<Module_Group_Duration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Module_Group_OneArgs = {
  object: Module_Group_Insert_Input;
  on_conflict?: InputMaybe<Module_Group_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Module_OneArgs = {
  object: Module_Insert_Input;
  on_conflict?: InputMaybe<Module_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OrderArgs = {
  objects: Array<Order_Insert_Input>;
  on_conflict?: InputMaybe<Order_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Order_OneArgs = {
  object: Order_Insert_Input;
  on_conflict?: InputMaybe<Order_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OrganizationArgs = {
  objects: Array<Organization_Insert_Input>;
  on_conflict?: InputMaybe<Organization_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Organization_InvitesArgs = {
  objects: Array<Organization_Invites_Insert_Input>;
  on_conflict?: InputMaybe<Organization_Invites_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Organization_Invites_OneArgs = {
  object: Organization_Invites_Insert_Input;
  on_conflict?: InputMaybe<Organization_Invites_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Organization_MemberArgs = {
  objects: Array<Organization_Member_Insert_Input>;
  on_conflict?: InputMaybe<Organization_Member_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Organization_Member_OneArgs = {
  object: Organization_Member_Insert_Input;
  on_conflict?: InputMaybe<Organization_Member_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Organization_OneArgs = {
  object: Organization_Insert_Input;
  on_conflict?: InputMaybe<Organization_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Payment_MethodsArgs = {
  objects: Array<Payment_Methods_Insert_Input>;
  on_conflict?: InputMaybe<Payment_Methods_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Payment_Methods_OneArgs = {
  object: Payment_Methods_Insert_Input;
  on_conflict?: InputMaybe<Payment_Methods_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Private_Course_BookingArgs = {
  objects: Array<Private_Course_Booking_Insert_Input>;
  on_conflict?: InputMaybe<Private_Course_Booking_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Private_Course_Booking_OneArgs = {
  object: Private_Course_Booking_Insert_Input;
  on_conflict?: InputMaybe<Private_Course_Booking_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ProfileArgs = {
  objects: Array<Profile_Insert_Input>;
  on_conflict?: InputMaybe<Profile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Profile_OneArgs = {
  object: Profile_Insert_Input;
  on_conflict?: InputMaybe<Profile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Profile_RoleArgs = {
  objects: Array<Profile_Role_Insert_Input>;
  on_conflict?: InputMaybe<Profile_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Profile_Role_OneArgs = {
  object: Profile_Role_Insert_Input;
  on_conflict?: InputMaybe<Profile_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Profile_TempArgs = {
  objects: Array<Profile_Temp_Insert_Input>;
  on_conflict?: InputMaybe<Profile_Temp_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Profile_Temp_OneArgs = {
  object: Profile_Temp_Insert_Input;
  on_conflict?: InputMaybe<Profile_Temp_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Profile_Trainer_Role_TypeArgs = {
  objects: Array<Profile_Trainer_Role_Type_Insert_Input>;
  on_conflict?: InputMaybe<Profile_Trainer_Role_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Profile_Trainer_Role_Type_OneArgs = {
  object: Profile_Trainer_Role_Type_Insert_Input;
  on_conflict?: InputMaybe<Profile_Trainer_Role_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Promo_CodeArgs = {
  objects: Array<Promo_Code_Insert_Input>;
  on_conflict?: InputMaybe<Promo_Code_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Promo_Code_OneArgs = {
  object: Promo_Code_Insert_Input;
  on_conflict?: InputMaybe<Promo_Code_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Promo_Code_TypeArgs = {
  objects: Array<Promo_Code_Type_Insert_Input>;
  on_conflict?: InputMaybe<Promo_Code_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Promo_Code_Type_OneArgs = {
  object: Promo_Code_Type_Insert_Input;
  on_conflict?: InputMaybe<Promo_Code_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoleArgs = {
  objects: Array<Role_Insert_Input>;
  on_conflict?: InputMaybe<Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Role_OneArgs = {
  object: Role_Insert_Input;
  on_conflict?: InputMaybe<Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Trainer_Role_TypeArgs = {
  objects: Array<Trainer_Role_Type_Insert_Input>;
  on_conflict?: InputMaybe<Trainer_Role_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Trainer_Role_Type_OneArgs = {
  object: Trainer_Role_Type_Insert_Input;
  on_conflict?: InputMaybe<Trainer_Role_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Trust_TypeArgs = {
  objects: Array<Trust_Type_Insert_Input>;
  on_conflict?: InputMaybe<Trust_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Trust_Type_OneArgs = {
  object: Trust_Type_Insert_Input;
  on_conflict?: InputMaybe<Trust_Type_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_VenueArgs = {
  objects: Array<Venue_Insert_Input>;
  on_conflict?: InputMaybe<Venue_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Venue_OneArgs = {
  object: Venue_Insert_Input;
  on_conflict?: InputMaybe<Venue_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_WaitlistArgs = {
  objects: Array<Waitlist_Insert_Input>;
  on_conflict?: InputMaybe<Waitlist_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Waitlist_OneArgs = {
  object: Waitlist_Insert_Input;
  on_conflict?: InputMaybe<Waitlist_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Xero_CredentialArgs = {
  objects: Array<Xero_Credential_Insert_Input>;
  on_conflict?: InputMaybe<Xero_Credential_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Xero_Credential_OneArgs = {
  object: Xero_Credential_Insert_Input;
  on_conflict?: InputMaybe<Xero_Credential_On_Conflict>;
};


/** mutation root */
export type Mutation_RootPlansCreateArgs = {
  data: PlansCreateInput;
};


/** mutation root */
export type Mutation_RootReplaceParticipantArgs = {
  input: ReplaceParticipantInput;
};


/** mutation root */
export type Mutation_RootResendPasswordArgs = {
  email: Scalars['String'];
};


/** mutation root */
export type Mutation_RootStripeCreatePaymentIntentArgs = {
  input: StripeCreatePaymentIntentInput;
};


/** mutation root */
export type Mutation_RootTransferParticipantArgs = {
  input: TransferInput;
};


/** mutation root */
export type Mutation_RootUpdateAvatarArgs = {
  avatar: Scalars['bytea'];
};


/** mutation root */
export type Mutation_RootUpdate_AvailabilityArgs = {
  _set?: InputMaybe<Availability_Set_Input>;
  where: Availability_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Availability_By_PkArgs = {
  _set?: InputMaybe<Availability_Set_Input>;
  pk_columns: Availability_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Blended_Learning_StatusArgs = {
  _set?: InputMaybe<Blended_Learning_Status_Set_Input>;
  where: Blended_Learning_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Blended_Learning_Status_By_PkArgs = {
  _set?: InputMaybe<Blended_Learning_Status_Set_Input>;
  pk_columns: Blended_Learning_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Certificate_StatusArgs = {
  _set?: InputMaybe<Certificate_Status_Set_Input>;
  where: Certificate_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Certificate_Status_By_PkArgs = {
  _set?: InputMaybe<Certificate_Status_Set_Input>;
  pk_columns: Certificate_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ColorArgs = {
  _set?: InputMaybe<Color_Set_Input>;
  where: Color_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Color_By_PkArgs = {
  _set?: InputMaybe<Color_Set_Input>;
  pk_columns: Color_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_CourseArgs = {
  _inc?: InputMaybe<Course_Inc_Input>;
  _set?: InputMaybe<Course_Set_Input>;
  where: Course_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_AuditArgs = {
  _append?: InputMaybe<Course_Audit_Append_Input>;
  _delete_at_path?: InputMaybe<Course_Audit_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Course_Audit_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Course_Audit_Delete_Key_Input>;
  _inc?: InputMaybe<Course_Audit_Inc_Input>;
  _prepend?: InputMaybe<Course_Audit_Prepend_Input>;
  _set?: InputMaybe<Course_Audit_Set_Input>;
  where: Course_Audit_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Audit_By_PkArgs = {
  _append?: InputMaybe<Course_Audit_Append_Input>;
  _delete_at_path?: InputMaybe<Course_Audit_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Course_Audit_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Course_Audit_Delete_Key_Input>;
  _inc?: InputMaybe<Course_Audit_Inc_Input>;
  _prepend?: InputMaybe<Course_Audit_Prepend_Input>;
  _set?: InputMaybe<Course_Audit_Set_Input>;
  pk_columns: Course_Audit_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Audit_TypeArgs = {
  _set?: InputMaybe<Course_Audit_Type_Set_Input>;
  where: Course_Audit_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Audit_Type_By_PkArgs = {
  _set?: InputMaybe<Course_Audit_Type_Set_Input>;
  pk_columns: Course_Audit_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_By_PkArgs = {
  _inc?: InputMaybe<Course_Inc_Input>;
  _set?: InputMaybe<Course_Set_Input>;
  pk_columns: Course_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Cancellation_RequestArgs = {
  _inc?: InputMaybe<Course_Cancellation_Request_Inc_Input>;
  _set?: InputMaybe<Course_Cancellation_Request_Set_Input>;
  where: Course_Cancellation_Request_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Cancellation_Request_By_PkArgs = {
  _inc?: InputMaybe<Course_Cancellation_Request_Inc_Input>;
  _set?: InputMaybe<Course_Cancellation_Request_Set_Input>;
  pk_columns: Course_Cancellation_Request_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_CertificateArgs = {
  _inc?: InputMaybe<Course_Certificate_Inc_Input>;
  _set?: InputMaybe<Course_Certificate_Set_Input>;
  where: Course_Certificate_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Certificate_By_PkArgs = {
  _inc?: InputMaybe<Course_Certificate_Inc_Input>;
  _set?: InputMaybe<Course_Certificate_Set_Input>;
  pk_columns: Course_Certificate_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Certificate_ChangelogArgs = {
  _set?: InputMaybe<Course_Certificate_Changelog_Set_Input>;
  where: Course_Certificate_Changelog_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Certificate_Changelog_By_PkArgs = {
  _set?: InputMaybe<Course_Certificate_Changelog_Set_Input>;
  pk_columns: Course_Certificate_Changelog_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Delivery_TypeArgs = {
  _set?: InputMaybe<Course_Delivery_Type_Set_Input>;
  where: Course_Delivery_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Delivery_Type_By_PkArgs = {
  _set?: InputMaybe<Course_Delivery_Type_Set_Input>;
  pk_columns: Course_Delivery_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_DraftArgs = {
  _append?: InputMaybe<Course_Draft_Append_Input>;
  _delete_at_path?: InputMaybe<Course_Draft_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Course_Draft_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Course_Draft_Delete_Key_Input>;
  _prepend?: InputMaybe<Course_Draft_Prepend_Input>;
  _set?: InputMaybe<Course_Draft_Set_Input>;
  where: Course_Draft_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Draft_By_PkArgs = {
  _append?: InputMaybe<Course_Draft_Append_Input>;
  _delete_at_path?: InputMaybe<Course_Draft_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Course_Draft_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Course_Draft_Delete_Key_Input>;
  _prepend?: InputMaybe<Course_Draft_Prepend_Input>;
  _set?: InputMaybe<Course_Draft_Set_Input>;
  pk_columns: Course_Draft_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_End_JobsArgs = {
  _inc?: InputMaybe<Course_End_Jobs_Inc_Input>;
  _set?: InputMaybe<Course_End_Jobs_Set_Input>;
  where: Course_End_Jobs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_End_Jobs_By_PkArgs = {
  _inc?: InputMaybe<Course_End_Jobs_Inc_Input>;
  _set?: InputMaybe<Course_End_Jobs_Set_Input>;
  pk_columns: Course_End_Jobs_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_EnquiryArgs = {
  _inc?: InputMaybe<Course_Enquiry_Inc_Input>;
  _set?: InputMaybe<Course_Enquiry_Set_Input>;
  where: Course_Enquiry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Enquiry_By_PkArgs = {
  _inc?: InputMaybe<Course_Enquiry_Inc_Input>;
  _set?: InputMaybe<Course_Enquiry_Set_Input>;
  pk_columns: Course_Enquiry_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Evaluation_AnswersArgs = {
  _inc?: InputMaybe<Course_Evaluation_Answers_Inc_Input>;
  _set?: InputMaybe<Course_Evaluation_Answers_Set_Input>;
  where: Course_Evaluation_Answers_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Evaluation_Answers_By_PkArgs = {
  _inc?: InputMaybe<Course_Evaluation_Answers_Inc_Input>;
  _set?: InputMaybe<Course_Evaluation_Answers_Set_Input>;
  pk_columns: Course_Evaluation_Answers_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Evaluation_Question_GroupArgs = {
  _set?: InputMaybe<Course_Evaluation_Question_Group_Set_Input>;
  where: Course_Evaluation_Question_Group_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Evaluation_Question_Group_By_PkArgs = {
  _set?: InputMaybe<Course_Evaluation_Question_Group_Set_Input>;
  pk_columns: Course_Evaluation_Question_Group_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Evaluation_Question_TypeArgs = {
  _set?: InputMaybe<Course_Evaluation_Question_Type_Set_Input>;
  where: Course_Evaluation_Question_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Evaluation_Question_Type_By_PkArgs = {
  _set?: InputMaybe<Course_Evaluation_Question_Type_Set_Input>;
  pk_columns: Course_Evaluation_Question_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Evaluation_QuestionsArgs = {
  _inc?: InputMaybe<Course_Evaluation_Questions_Inc_Input>;
  _set?: InputMaybe<Course_Evaluation_Questions_Set_Input>;
  where: Course_Evaluation_Questions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Evaluation_Questions_By_PkArgs = {
  _inc?: InputMaybe<Course_Evaluation_Questions_Inc_Input>;
  _set?: InputMaybe<Course_Evaluation_Questions_Set_Input>;
  pk_columns: Course_Evaluation_Questions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_ExpensesArgs = {
  _append?: InputMaybe<Course_Expenses_Append_Input>;
  _delete_at_path?: InputMaybe<Course_Expenses_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Course_Expenses_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Course_Expenses_Delete_Key_Input>;
  _inc?: InputMaybe<Course_Expenses_Inc_Input>;
  _prepend?: InputMaybe<Course_Expenses_Prepend_Input>;
  _set?: InputMaybe<Course_Expenses_Set_Input>;
  where: Course_Expenses_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Expenses_By_PkArgs = {
  _append?: InputMaybe<Course_Expenses_Append_Input>;
  _delete_at_path?: InputMaybe<Course_Expenses_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Course_Expenses_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Course_Expenses_Delete_Key_Input>;
  _inc?: InputMaybe<Course_Expenses_Inc_Input>;
  _prepend?: InputMaybe<Course_Expenses_Prepend_Input>;
  _set?: InputMaybe<Course_Expenses_Set_Input>;
  pk_columns: Course_Expenses_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Invite_StatusArgs = {
  _set?: InputMaybe<Course_Invite_Status_Set_Input>;
  where: Course_Invite_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Invite_Status_By_PkArgs = {
  _set?: InputMaybe<Course_Invite_Status_Set_Input>;
  pk_columns: Course_Invite_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_InvitesArgs = {
  _inc?: InputMaybe<Course_Invites_Inc_Input>;
  _set?: InputMaybe<Course_Invites_Set_Input>;
  where: Course_Invites_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Invites_By_PkArgs = {
  _inc?: InputMaybe<Course_Invites_Inc_Input>;
  _set?: InputMaybe<Course_Invites_Set_Input>;
  pk_columns: Course_Invites_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_LevelArgs = {
  _set?: InputMaybe<Course_Level_Set_Input>;
  where: Course_Level_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Level_By_PkArgs = {
  _set?: InputMaybe<Course_Level_Set_Input>;
  pk_columns: Course_Level_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Level_PrefixArgs = {
  _set?: InputMaybe<Course_Level_Prefix_Set_Input>;
  where: Course_Level_Prefix_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Level_Prefix_By_PkArgs = {
  _set?: InputMaybe<Course_Level_Prefix_Set_Input>;
  pk_columns: Course_Level_Prefix_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_ModuleArgs = {
  _inc?: InputMaybe<Course_Module_Inc_Input>;
  _set?: InputMaybe<Course_Module_Set_Input>;
  where: Course_Module_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Module_By_PkArgs = {
  _inc?: InputMaybe<Course_Module_Inc_Input>;
  _set?: InputMaybe<Course_Module_Set_Input>;
  pk_columns: Course_Module_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_ParticipantArgs = {
  _inc?: InputMaybe<Course_Participant_Inc_Input>;
  _set?: InputMaybe<Course_Participant_Set_Input>;
  where: Course_Participant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Participant_AuditArgs = {
  _append?: InputMaybe<Course_Participant_Audit_Append_Input>;
  _delete_at_path?: InputMaybe<Course_Participant_Audit_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Course_Participant_Audit_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Course_Participant_Audit_Delete_Key_Input>;
  _inc?: InputMaybe<Course_Participant_Audit_Inc_Input>;
  _prepend?: InputMaybe<Course_Participant_Audit_Prepend_Input>;
  _set?: InputMaybe<Course_Participant_Audit_Set_Input>;
  where: Course_Participant_Audit_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Participant_Audit_By_PkArgs = {
  _append?: InputMaybe<Course_Participant_Audit_Append_Input>;
  _delete_at_path?: InputMaybe<Course_Participant_Audit_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Course_Participant_Audit_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Course_Participant_Audit_Delete_Key_Input>;
  _inc?: InputMaybe<Course_Participant_Audit_Inc_Input>;
  _prepend?: InputMaybe<Course_Participant_Audit_Prepend_Input>;
  _set?: InputMaybe<Course_Participant_Audit_Set_Input>;
  pk_columns: Course_Participant_Audit_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Participant_Audit_TypeArgs = {
  _set?: InputMaybe<Course_Participant_Audit_Type_Set_Input>;
  where: Course_Participant_Audit_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Participant_Audit_Type_By_PkArgs = {
  _set?: InputMaybe<Course_Participant_Audit_Type_Set_Input>;
  pk_columns: Course_Participant_Audit_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Participant_By_PkArgs = {
  _inc?: InputMaybe<Course_Participant_Inc_Input>;
  _set?: InputMaybe<Course_Participant_Set_Input>;
  pk_columns: Course_Participant_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Participant_CancellationArgs = {
  _inc?: InputMaybe<Course_Participant_Cancellation_Inc_Input>;
  _set?: InputMaybe<Course_Participant_Cancellation_Set_Input>;
  where: Course_Participant_Cancellation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Participant_Cancellation_By_PkArgs = {
  _inc?: InputMaybe<Course_Participant_Cancellation_Inc_Input>;
  _set?: InputMaybe<Course_Participant_Cancellation_Set_Input>;
  pk_columns: Course_Participant_Cancellation_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Participant_ModuleArgs = {
  _set?: InputMaybe<Course_Participant_Module_Set_Input>;
  where: Course_Participant_Module_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Participant_Module_By_PkArgs = {
  _set?: InputMaybe<Course_Participant_Module_Set_Input>;
  pk_columns: Course_Participant_Module_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_PricingArgs = {
  _inc?: InputMaybe<Course_Pricing_Inc_Input>;
  _set?: InputMaybe<Course_Pricing_Set_Input>;
  where: Course_Pricing_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Pricing_By_PkArgs = {
  _inc?: InputMaybe<Course_Pricing_Inc_Input>;
  _set?: InputMaybe<Course_Pricing_Set_Input>;
  pk_columns: Course_Pricing_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Promo_CodeArgs = {
  _inc?: InputMaybe<Course_Promo_Code_Inc_Input>;
  _set?: InputMaybe<Course_Promo_Code_Set_Input>;
  where: Course_Promo_Code_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Promo_Code_By_PkArgs = {
  _inc?: InputMaybe<Course_Promo_Code_Inc_Input>;
  _set?: InputMaybe<Course_Promo_Code_Set_Input>;
  pk_columns: Course_Promo_Code_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_ScheduleArgs = {
  _inc?: InputMaybe<Course_Schedule_Inc_Input>;
  _set?: InputMaybe<Course_Schedule_Set_Input>;
  where: Course_Schedule_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Schedule_By_PkArgs = {
  _inc?: InputMaybe<Course_Schedule_Inc_Input>;
  _set?: InputMaybe<Course_Schedule_Set_Input>;
  pk_columns: Course_Schedule_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_StatusArgs = {
  _set?: InputMaybe<Course_Status_Set_Input>;
  where: Course_Status_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Status_By_PkArgs = {
  _set?: InputMaybe<Course_Status_Set_Input>;
  pk_columns: Course_Status_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_TrainerArgs = {
  _inc?: InputMaybe<Course_Trainer_Inc_Input>;
  _set?: InputMaybe<Course_Trainer_Set_Input>;
  where: Course_Trainer_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Trainer_By_PkArgs = {
  _inc?: InputMaybe<Course_Trainer_Inc_Input>;
  _set?: InputMaybe<Course_Trainer_Set_Input>;
  pk_columns: Course_Trainer_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Trainer_TypeArgs = {
  _set?: InputMaybe<Course_Trainer_Type_Set_Input>;
  where: Course_Trainer_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Trainer_Type_By_PkArgs = {
  _set?: InputMaybe<Course_Trainer_Type_Set_Input>;
  pk_columns: Course_Trainer_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_TypeArgs = {
  _set?: InputMaybe<Course_Type_Set_Input>;
  where: Course_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Type_By_PkArgs = {
  _set?: InputMaybe<Course_Type_Set_Input>;
  pk_columns: Course_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Type_PrefixArgs = {
  _set?: InputMaybe<Course_Type_Prefix_Set_Input>;
  where: Course_Type_Prefix_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Course_Type_Prefix_By_PkArgs = {
  _set?: InputMaybe<Course_Type_Prefix_Set_Input>;
  pk_columns: Course_Type_Prefix_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Dfe_EstablishmentArgs = {
  _set?: InputMaybe<Dfe_Establishment_Set_Input>;
  where: Dfe_Establishment_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Dfe_Establishment_By_PkArgs = {
  _set?: InputMaybe<Dfe_Establishment_Set_Input>;
  pk_columns: Dfe_Establishment_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Expire_Go1_License_JobsArgs = {
  _set?: InputMaybe<Expire_Go1_License_Jobs_Set_Input>;
  where: Expire_Go1_License_Jobs_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Expire_Go1_License_Jobs_By_PkArgs = {
  _set?: InputMaybe<Expire_Go1_License_Jobs_Set_Input>;
  pk_columns: Expire_Go1_License_Jobs_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Go1_History_EventsArgs = {
  _set?: InputMaybe<Go1_History_Events_Set_Input>;
  where: Go1_History_Events_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Go1_History_Events_By_PkArgs = {
  _set?: InputMaybe<Go1_History_Events_Set_Input>;
  pk_columns: Go1_History_Events_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Go1_LicensesArgs = {
  _set?: InputMaybe<Go1_Licenses_Set_Input>;
  where: Go1_Licenses_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Go1_Licenses_By_PkArgs = {
  _set?: InputMaybe<Go1_Licenses_Set_Input>;
  pk_columns: Go1_Licenses_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Go1_Licenses_HistoryArgs = {
  _append?: InputMaybe<Go1_Licenses_History_Append_Input>;
  _delete_at_path?: InputMaybe<Go1_Licenses_History_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Go1_Licenses_History_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Go1_Licenses_History_Delete_Key_Input>;
  _inc?: InputMaybe<Go1_Licenses_History_Inc_Input>;
  _prepend?: InputMaybe<Go1_Licenses_History_Prepend_Input>;
  _set?: InputMaybe<Go1_Licenses_History_Set_Input>;
  where: Go1_Licenses_History_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Go1_Licenses_History_By_PkArgs = {
  _append?: InputMaybe<Go1_Licenses_History_Append_Input>;
  _delete_at_path?: InputMaybe<Go1_Licenses_History_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Go1_Licenses_History_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Go1_Licenses_History_Delete_Key_Input>;
  _inc?: InputMaybe<Go1_Licenses_History_Inc_Input>;
  _prepend?: InputMaybe<Go1_Licenses_History_Prepend_Input>;
  _set?: InputMaybe<Go1_Licenses_History_Set_Input>;
  pk_columns: Go1_Licenses_History_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_GradeArgs = {
  _set?: InputMaybe<Grade_Set_Input>;
  where: Grade_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Grade_By_PkArgs = {
  _set?: InputMaybe<Grade_Set_Input>;
  pk_columns: Grade_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_IdentityArgs = {
  _set?: InputMaybe<Identity_Set_Input>;
  where: Identity_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Identity_By_PkArgs = {
  _set?: InputMaybe<Identity_Set_Input>;
  pk_columns: Identity_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Identity_TypeArgs = {
  _set?: InputMaybe<Identity_Type_Set_Input>;
  where: Identity_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Identity_Type_By_PkArgs = {
  _set?: InputMaybe<Identity_Type_Set_Input>;
  pk_columns: Identity_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Legacy_CertificateArgs = {
  _append?: InputMaybe<Legacy_Certificate_Append_Input>;
  _delete_at_path?: InputMaybe<Legacy_Certificate_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Legacy_Certificate_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Legacy_Certificate_Delete_Key_Input>;
  _inc?: InputMaybe<Legacy_Certificate_Inc_Input>;
  _prepend?: InputMaybe<Legacy_Certificate_Prepend_Input>;
  _set?: InputMaybe<Legacy_Certificate_Set_Input>;
  where: Legacy_Certificate_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Legacy_Certificate_By_PkArgs = {
  _append?: InputMaybe<Legacy_Certificate_Append_Input>;
  _delete_at_path?: InputMaybe<Legacy_Certificate_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Legacy_Certificate_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Legacy_Certificate_Delete_Key_Input>;
  _inc?: InputMaybe<Legacy_Certificate_Inc_Input>;
  _prepend?: InputMaybe<Legacy_Certificate_Prepend_Input>;
  _set?: InputMaybe<Legacy_Certificate_Set_Input>;
  pk_columns: Legacy_Certificate_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ModuleArgs = {
  _set?: InputMaybe<Module_Set_Input>;
  where: Module_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Module_By_PkArgs = {
  _set?: InputMaybe<Module_Set_Input>;
  pk_columns: Module_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Module_CategoryArgs = {
  _set?: InputMaybe<Module_Category_Set_Input>;
  where: Module_Category_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Module_Category_By_PkArgs = {
  _set?: InputMaybe<Module_Category_Set_Input>;
  pk_columns: Module_Category_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Module_GroupArgs = {
  _set?: InputMaybe<Module_Group_Set_Input>;
  where: Module_Group_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Module_Group_By_PkArgs = {
  _set?: InputMaybe<Module_Group_Set_Input>;
  pk_columns: Module_Group_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Module_Group_DurationArgs = {
  _inc?: InputMaybe<Module_Group_Duration_Inc_Input>;
  _set?: InputMaybe<Module_Group_Duration_Set_Input>;
  where: Module_Group_Duration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Module_Group_Duration_By_PkArgs = {
  _inc?: InputMaybe<Module_Group_Duration_Inc_Input>;
  _set?: InputMaybe<Module_Group_Duration_Set_Input>;
  pk_columns: Module_Group_Duration_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_OrderArgs = {
  _append?: InputMaybe<Order_Append_Input>;
  _delete_at_path?: InputMaybe<Order_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Order_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Order_Delete_Key_Input>;
  _inc?: InputMaybe<Order_Inc_Input>;
  _prepend?: InputMaybe<Order_Prepend_Input>;
  _set?: InputMaybe<Order_Set_Input>;
  where: Order_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Order_By_PkArgs = {
  _append?: InputMaybe<Order_Append_Input>;
  _delete_at_path?: InputMaybe<Order_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Order_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Order_Delete_Key_Input>;
  _inc?: InputMaybe<Order_Inc_Input>;
  _prepend?: InputMaybe<Order_Prepend_Input>;
  _set?: InputMaybe<Order_Set_Input>;
  pk_columns: Order_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_OrganizationArgs = {
  _append?: InputMaybe<Organization_Append_Input>;
  _delete_at_path?: InputMaybe<Organization_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Organization_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Organization_Delete_Key_Input>;
  _inc?: InputMaybe<Organization_Inc_Input>;
  _prepend?: InputMaybe<Organization_Prepend_Input>;
  _set?: InputMaybe<Organization_Set_Input>;
  where: Organization_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Organization_By_PkArgs = {
  _append?: InputMaybe<Organization_Append_Input>;
  _delete_at_path?: InputMaybe<Organization_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Organization_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Organization_Delete_Key_Input>;
  _inc?: InputMaybe<Organization_Inc_Input>;
  _prepend?: InputMaybe<Organization_Prepend_Input>;
  _set?: InputMaybe<Organization_Set_Input>;
  pk_columns: Organization_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Organization_InvitesArgs = {
  _set?: InputMaybe<Organization_Invites_Set_Input>;
  where: Organization_Invites_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Organization_Invites_By_PkArgs = {
  _set?: InputMaybe<Organization_Invites_Set_Input>;
  pk_columns: Organization_Invites_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Organization_MemberArgs = {
  _set?: InputMaybe<Organization_Member_Set_Input>;
  where: Organization_Member_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Organization_Member_By_PkArgs = {
  _set?: InputMaybe<Organization_Member_Set_Input>;
  pk_columns: Organization_Member_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Payment_MethodsArgs = {
  _set?: InputMaybe<Payment_Methods_Set_Input>;
  where: Payment_Methods_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Payment_Methods_By_PkArgs = {
  _set?: InputMaybe<Payment_Methods_Set_Input>;
  pk_columns: Payment_Methods_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Private_Course_BookingArgs = {
  _inc?: InputMaybe<Private_Course_Booking_Inc_Input>;
  _set?: InputMaybe<Private_Course_Booking_Set_Input>;
  where: Private_Course_Booking_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Private_Course_Booking_By_PkArgs = {
  _inc?: InputMaybe<Private_Course_Booking_Inc_Input>;
  _set?: InputMaybe<Private_Course_Booking_Set_Input>;
  pk_columns: Private_Course_Booking_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ProfileArgs = {
  _append?: InputMaybe<Profile_Append_Input>;
  _delete_at_path?: InputMaybe<Profile_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Profile_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Profile_Delete_Key_Input>;
  _inc?: InputMaybe<Profile_Inc_Input>;
  _prepend?: InputMaybe<Profile_Prepend_Input>;
  _set?: InputMaybe<Profile_Set_Input>;
  where: Profile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Profile_By_PkArgs = {
  _append?: InputMaybe<Profile_Append_Input>;
  _delete_at_path?: InputMaybe<Profile_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Profile_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Profile_Delete_Key_Input>;
  _inc?: InputMaybe<Profile_Inc_Input>;
  _prepend?: InputMaybe<Profile_Prepend_Input>;
  _set?: InputMaybe<Profile_Set_Input>;
  pk_columns: Profile_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Profile_RoleArgs = {
  _set?: InputMaybe<Profile_Role_Set_Input>;
  where: Profile_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Profile_Role_By_PkArgs = {
  _set?: InputMaybe<Profile_Role_Set_Input>;
  pk_columns: Profile_Role_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Profile_TempArgs = {
  _inc?: InputMaybe<Profile_Temp_Inc_Input>;
  _set?: InputMaybe<Profile_Temp_Set_Input>;
  where: Profile_Temp_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Profile_Temp_By_PkArgs = {
  _inc?: InputMaybe<Profile_Temp_Inc_Input>;
  _set?: InputMaybe<Profile_Temp_Set_Input>;
  pk_columns: Profile_Temp_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Profile_Trainer_Role_TypeArgs = {
  _set?: InputMaybe<Profile_Trainer_Role_Type_Set_Input>;
  where: Profile_Trainer_Role_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Profile_Trainer_Role_Type_By_PkArgs = {
  _set?: InputMaybe<Profile_Trainer_Role_Type_Set_Input>;
  pk_columns: Profile_Trainer_Role_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Promo_CodeArgs = {
  _append?: InputMaybe<Promo_Code_Append_Input>;
  _delete_at_path?: InputMaybe<Promo_Code_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Promo_Code_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Promo_Code_Delete_Key_Input>;
  _inc?: InputMaybe<Promo_Code_Inc_Input>;
  _prepend?: InputMaybe<Promo_Code_Prepend_Input>;
  _set?: InputMaybe<Promo_Code_Set_Input>;
  where: Promo_Code_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Promo_Code_By_PkArgs = {
  _append?: InputMaybe<Promo_Code_Append_Input>;
  _delete_at_path?: InputMaybe<Promo_Code_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Promo_Code_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Promo_Code_Delete_Key_Input>;
  _inc?: InputMaybe<Promo_Code_Inc_Input>;
  _prepend?: InputMaybe<Promo_Code_Prepend_Input>;
  _set?: InputMaybe<Promo_Code_Set_Input>;
  pk_columns: Promo_Code_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Promo_Code_TypeArgs = {
  _set?: InputMaybe<Promo_Code_Type_Set_Input>;
  where: Promo_Code_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Promo_Code_Type_By_PkArgs = {
  _set?: InputMaybe<Promo_Code_Type_Set_Input>;
  pk_columns: Promo_Code_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RoleArgs = {
  _append?: InputMaybe<Role_Append_Input>;
  _delete_at_path?: InputMaybe<Role_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Role_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Role_Delete_Key_Input>;
  _inc?: InputMaybe<Role_Inc_Input>;
  _prepend?: InputMaybe<Role_Prepend_Input>;
  _set?: InputMaybe<Role_Set_Input>;
  where: Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Role_By_PkArgs = {
  _append?: InputMaybe<Role_Append_Input>;
  _delete_at_path?: InputMaybe<Role_Delete_At_Path_Input>;
  _delete_elem?: InputMaybe<Role_Delete_Elem_Input>;
  _delete_key?: InputMaybe<Role_Delete_Key_Input>;
  _inc?: InputMaybe<Role_Inc_Input>;
  _prepend?: InputMaybe<Role_Prepend_Input>;
  _set?: InputMaybe<Role_Set_Input>;
  pk_columns: Role_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Trainer_Role_TypeArgs = {
  _set?: InputMaybe<Trainer_Role_Type_Set_Input>;
  where: Trainer_Role_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Trainer_Role_Type_By_PkArgs = {
  _set?: InputMaybe<Trainer_Role_Type_Set_Input>;
  pk_columns: Trainer_Role_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Trust_TypeArgs = {
  _set?: InputMaybe<Trust_Type_Set_Input>;
  where: Trust_Type_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Trust_Type_By_PkArgs = {
  _set?: InputMaybe<Trust_Type_Set_Input>;
  pk_columns: Trust_Type_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_VenueArgs = {
  _set?: InputMaybe<Venue_Set_Input>;
  where: Venue_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Venue_By_PkArgs = {
  _set?: InputMaybe<Venue_Set_Input>;
  pk_columns: Venue_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_WaitlistArgs = {
  _inc?: InputMaybe<Waitlist_Inc_Input>;
  _set?: InputMaybe<Waitlist_Set_Input>;
  where: Waitlist_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Waitlist_By_PkArgs = {
  _inc?: InputMaybe<Waitlist_Inc_Input>;
  _set?: InputMaybe<Waitlist_Set_Input>;
  pk_columns: Waitlist_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Xero_CredentialArgs = {
  _set?: InputMaybe<Xero_Credential_Set_Input>;
  where: Xero_Credential_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Xero_Credential_By_PkArgs = {
  _set?: InputMaybe<Xero_Credential_Set_Input>;
  pk_columns: Xero_Credential_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpsertZoomMeetingArgs = {
  input?: InputMaybe<UpsertZoomMeetingInput>;
};


/** mutation root */
export type Mutation_RootVerifyUserArgs = {
  inviteId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootXeroCallbackArgs = {
  input: XeroCallbackInput;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type Numeric_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['numeric']>;
  _gt?: InputMaybe<Scalars['numeric']>;
  _gte?: InputMaybe<Scalars['numeric']>;
  _in?: InputMaybe<Array<Scalars['numeric']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['numeric']>;
  _lte?: InputMaybe<Scalars['numeric']>;
  _neq?: InputMaybe<Scalars['numeric']>;
  _nin?: InputMaybe<Array<Scalars['numeric']>>;
};

/** columns and relationships of "order" */
export type Order = {
  __typename?: 'order';
  billingAddress: Scalars['String'];
  billingEmail: Scalars['String'];
  billingFamilyName: Scalars['String'];
  billingGivenName: Scalars['String'];
  billingPhone: Scalars['String'];
  clientPurchaseOrder?: Maybe<Scalars['String']>;
  /** An object relationship */
  course: Course;
  courseId: Scalars['Int'];
  createdAt: Scalars['timestamptz'];
  currency?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  orderDue?: Maybe<Scalars['float8']>;
  orderTotal?: Maybe<Scalars['float8']>;
  /** An object relationship */
  organization: Organization;
  organizationId: Scalars['uuid'];
  paymentMethod: Payment_Methods_Enum;
  price?: Maybe<Scalars['float8']>;
  /** An object relationship */
  profile: Profile;
  profileId: Scalars['uuid'];
  promoCodes?: Maybe<Scalars['jsonb']>;
  quantity: Scalars['Int'];
  registrants: Scalars['json'];
  stripePaymentId?: Maybe<Scalars['String']>;
  vat?: Maybe<Scalars['float8']>;
  xeroInvoiceNumber?: Maybe<Scalars['String']>;
};


/** columns and relationships of "order" */
export type OrderPromoCodesArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "order" */
export type OrderRegistrantsArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "order" */
export type Order_Aggregate = {
  __typename?: 'order_aggregate';
  aggregate?: Maybe<Order_Aggregate_Fields>;
  nodes: Array<Order>;
};

/** aggregate fields of "order" */
export type Order_Aggregate_Fields = {
  __typename?: 'order_aggregate_fields';
  avg?: Maybe<Order_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Order_Max_Fields>;
  min?: Maybe<Order_Min_Fields>;
  stddev?: Maybe<Order_Stddev_Fields>;
  stddev_pop?: Maybe<Order_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Order_Stddev_Samp_Fields>;
  sum?: Maybe<Order_Sum_Fields>;
  var_pop?: Maybe<Order_Var_Pop_Fields>;
  var_samp?: Maybe<Order_Var_Samp_Fields>;
  variance?: Maybe<Order_Variance_Fields>;
};


/** aggregate fields of "order" */
export type Order_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Order_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "order" */
export type Order_Aggregate_Order_By = {
  avg?: InputMaybe<Order_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Order_Max_Order_By>;
  min?: InputMaybe<Order_Min_Order_By>;
  stddev?: InputMaybe<Order_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Order_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Order_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Order_Sum_Order_By>;
  var_pop?: InputMaybe<Order_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Order_Var_Samp_Order_By>;
  variance?: InputMaybe<Order_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Order_Append_Input = {
  promoCodes?: InputMaybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "order" */
export type Order_Arr_Rel_Insert_Input = {
  data: Array<Order_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Order_On_Conflict>;
};

/** aggregate avg on columns */
export type Order_Avg_Fields = {
  __typename?: 'order_avg_fields';
  courseId?: Maybe<Scalars['Float']>;
  orderDue?: Maybe<Scalars['Float']>;
  orderTotal?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  vat?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "order" */
export type Order_Avg_Order_By = {
  courseId?: InputMaybe<Order_By>;
  orderDue?: InputMaybe<Order_By>;
  orderTotal?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  vat?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "order". All fields are combined with a logical 'AND'. */
export type Order_Bool_Exp = {
  _and?: InputMaybe<Array<Order_Bool_Exp>>;
  _not?: InputMaybe<Order_Bool_Exp>;
  _or?: InputMaybe<Array<Order_Bool_Exp>>;
  billingAddress?: InputMaybe<String_Comparison_Exp>;
  billingEmail?: InputMaybe<String_Comparison_Exp>;
  billingFamilyName?: InputMaybe<String_Comparison_Exp>;
  billingGivenName?: InputMaybe<String_Comparison_Exp>;
  billingPhone?: InputMaybe<String_Comparison_Exp>;
  clientPurchaseOrder?: InputMaybe<String_Comparison_Exp>;
  course?: InputMaybe<Course_Bool_Exp>;
  courseId?: InputMaybe<Int_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  currency?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  orderDue?: InputMaybe<Float8_Comparison_Exp>;
  orderTotal?: InputMaybe<Float8_Comparison_Exp>;
  organization?: InputMaybe<Organization_Bool_Exp>;
  organizationId?: InputMaybe<Uuid_Comparison_Exp>;
  paymentMethod?: InputMaybe<Payment_Methods_Enum_Comparison_Exp>;
  price?: InputMaybe<Float8_Comparison_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profileId?: InputMaybe<Uuid_Comparison_Exp>;
  promoCodes?: InputMaybe<Jsonb_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  registrants?: InputMaybe<Json_Comparison_Exp>;
  stripePaymentId?: InputMaybe<String_Comparison_Exp>;
  vat?: InputMaybe<Float8_Comparison_Exp>;
  xeroInvoiceNumber?: InputMaybe<String_Comparison_Exp>;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** unique or primary key constraints on table "order" */
export enum Order_Constraint {
  /** unique or primary key constraint */
  OrderPkey = 'order_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Order_Delete_At_Path_Input = {
  promoCodes?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Order_Delete_Elem_Input = {
  promoCodes?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Order_Delete_Key_Input = {
  promoCodes?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "order" */
export type Order_Inc_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
  orderDue?: InputMaybe<Scalars['float8']>;
  orderTotal?: InputMaybe<Scalars['float8']>;
  price?: InputMaybe<Scalars['float8']>;
  quantity?: InputMaybe<Scalars['Int']>;
  vat?: InputMaybe<Scalars['float8']>;
};

/** input type for inserting data into table "order" */
export type Order_Insert_Input = {
  billingAddress?: InputMaybe<Scalars['String']>;
  billingEmail?: InputMaybe<Scalars['String']>;
  billingFamilyName?: InputMaybe<Scalars['String']>;
  billingGivenName?: InputMaybe<Scalars['String']>;
  billingPhone?: InputMaybe<Scalars['String']>;
  clientPurchaseOrder?: InputMaybe<Scalars['String']>;
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  courseId?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  orderDue?: InputMaybe<Scalars['float8']>;
  orderTotal?: InputMaybe<Scalars['float8']>;
  organization?: InputMaybe<Organization_Obj_Rel_Insert_Input>;
  organizationId?: InputMaybe<Scalars['uuid']>;
  paymentMethod?: InputMaybe<Payment_Methods_Enum>;
  price?: InputMaybe<Scalars['float8']>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profileId?: InputMaybe<Scalars['uuid']>;
  promoCodes?: InputMaybe<Scalars['jsonb']>;
  quantity?: InputMaybe<Scalars['Int']>;
  registrants?: InputMaybe<Scalars['json']>;
  stripePaymentId?: InputMaybe<Scalars['String']>;
  vat?: InputMaybe<Scalars['float8']>;
  xeroInvoiceNumber?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Order_Max_Fields = {
  __typename?: 'order_max_fields';
  billingAddress?: Maybe<Scalars['String']>;
  billingEmail?: Maybe<Scalars['String']>;
  billingFamilyName?: Maybe<Scalars['String']>;
  billingGivenName?: Maybe<Scalars['String']>;
  billingPhone?: Maybe<Scalars['String']>;
  clientPurchaseOrder?: Maybe<Scalars['String']>;
  courseId?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  orderDue?: Maybe<Scalars['float8']>;
  orderTotal?: Maybe<Scalars['float8']>;
  organizationId?: Maybe<Scalars['uuid']>;
  price?: Maybe<Scalars['float8']>;
  profileId?: Maybe<Scalars['uuid']>;
  quantity?: Maybe<Scalars['Int']>;
  stripePaymentId?: Maybe<Scalars['String']>;
  vat?: Maybe<Scalars['float8']>;
  xeroInvoiceNumber?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "order" */
export type Order_Max_Order_By = {
  billingAddress?: InputMaybe<Order_By>;
  billingEmail?: InputMaybe<Order_By>;
  billingFamilyName?: InputMaybe<Order_By>;
  billingGivenName?: InputMaybe<Order_By>;
  billingPhone?: InputMaybe<Order_By>;
  clientPurchaseOrder?: InputMaybe<Order_By>;
  courseId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  currency?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  orderDue?: InputMaybe<Order_By>;
  orderTotal?: InputMaybe<Order_By>;
  organizationId?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  profileId?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  stripePaymentId?: InputMaybe<Order_By>;
  vat?: InputMaybe<Order_By>;
  xeroInvoiceNumber?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Order_Min_Fields = {
  __typename?: 'order_min_fields';
  billingAddress?: Maybe<Scalars['String']>;
  billingEmail?: Maybe<Scalars['String']>;
  billingFamilyName?: Maybe<Scalars['String']>;
  billingGivenName?: Maybe<Scalars['String']>;
  billingPhone?: Maybe<Scalars['String']>;
  clientPurchaseOrder?: Maybe<Scalars['String']>;
  courseId?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  currency?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  orderDue?: Maybe<Scalars['float8']>;
  orderTotal?: Maybe<Scalars['float8']>;
  organizationId?: Maybe<Scalars['uuid']>;
  price?: Maybe<Scalars['float8']>;
  profileId?: Maybe<Scalars['uuid']>;
  quantity?: Maybe<Scalars['Int']>;
  stripePaymentId?: Maybe<Scalars['String']>;
  vat?: Maybe<Scalars['float8']>;
  xeroInvoiceNumber?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "order" */
export type Order_Min_Order_By = {
  billingAddress?: InputMaybe<Order_By>;
  billingEmail?: InputMaybe<Order_By>;
  billingFamilyName?: InputMaybe<Order_By>;
  billingGivenName?: InputMaybe<Order_By>;
  billingPhone?: InputMaybe<Order_By>;
  clientPurchaseOrder?: InputMaybe<Order_By>;
  courseId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  currency?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  orderDue?: InputMaybe<Order_By>;
  orderTotal?: InputMaybe<Order_By>;
  organizationId?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  profileId?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  stripePaymentId?: InputMaybe<Order_By>;
  vat?: InputMaybe<Order_By>;
  xeroInvoiceNumber?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "order" */
export type Order_Mutation_Response = {
  __typename?: 'order_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Order>;
};

/** on_conflict condition type for table "order" */
export type Order_On_Conflict = {
  constraint: Order_Constraint;
  update_columns?: Array<Order_Update_Column>;
  where?: InputMaybe<Order_Bool_Exp>;
};

/** Ordering options when selecting data from "order". */
export type Order_Order_By = {
  billingAddress?: InputMaybe<Order_By>;
  billingEmail?: InputMaybe<Order_By>;
  billingFamilyName?: InputMaybe<Order_By>;
  billingGivenName?: InputMaybe<Order_By>;
  billingPhone?: InputMaybe<Order_By>;
  clientPurchaseOrder?: InputMaybe<Order_By>;
  course?: InputMaybe<Course_Order_By>;
  courseId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  currency?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  orderDue?: InputMaybe<Order_By>;
  orderTotal?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organization_Order_By>;
  organizationId?: InputMaybe<Order_By>;
  paymentMethod?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profileId?: InputMaybe<Order_By>;
  promoCodes?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  registrants?: InputMaybe<Order_By>;
  stripePaymentId?: InputMaybe<Order_By>;
  vat?: InputMaybe<Order_By>;
  xeroInvoiceNumber?: InputMaybe<Order_By>;
};

/** primary key columns input for table: order */
export type Order_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Order_Prepend_Input = {
  promoCodes?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "order" */
export enum Order_Select_Column {
  /** column name */
  BillingAddress = 'billingAddress',
  /** column name */
  BillingEmail = 'billingEmail',
  /** column name */
  BillingFamilyName = 'billingFamilyName',
  /** column name */
  BillingGivenName = 'billingGivenName',
  /** column name */
  BillingPhone = 'billingPhone',
  /** column name */
  ClientPurchaseOrder = 'clientPurchaseOrder',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  Id = 'id',
  /** column name */
  OrderDue = 'orderDue',
  /** column name */
  OrderTotal = 'orderTotal',
  /** column name */
  OrganizationId = 'organizationId',
  /** column name */
  PaymentMethod = 'paymentMethod',
  /** column name */
  Price = 'price',
  /** column name */
  ProfileId = 'profileId',
  /** column name */
  PromoCodes = 'promoCodes',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  Registrants = 'registrants',
  /** column name */
  StripePaymentId = 'stripePaymentId',
  /** column name */
  Vat = 'vat',
  /** column name */
  XeroInvoiceNumber = 'xeroInvoiceNumber'
}

/** input type for updating data in table "order" */
export type Order_Set_Input = {
  billingAddress?: InputMaybe<Scalars['String']>;
  billingEmail?: InputMaybe<Scalars['String']>;
  billingFamilyName?: InputMaybe<Scalars['String']>;
  billingGivenName?: InputMaybe<Scalars['String']>;
  billingPhone?: InputMaybe<Scalars['String']>;
  clientPurchaseOrder?: InputMaybe<Scalars['String']>;
  courseId?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  currency?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  orderDue?: InputMaybe<Scalars['float8']>;
  orderTotal?: InputMaybe<Scalars['float8']>;
  organizationId?: InputMaybe<Scalars['uuid']>;
  paymentMethod?: InputMaybe<Payment_Methods_Enum>;
  price?: InputMaybe<Scalars['float8']>;
  profileId?: InputMaybe<Scalars['uuid']>;
  promoCodes?: InputMaybe<Scalars['jsonb']>;
  quantity?: InputMaybe<Scalars['Int']>;
  registrants?: InputMaybe<Scalars['json']>;
  stripePaymentId?: InputMaybe<Scalars['String']>;
  vat?: InputMaybe<Scalars['float8']>;
  xeroInvoiceNumber?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Order_Stddev_Fields = {
  __typename?: 'order_stddev_fields';
  courseId?: Maybe<Scalars['Float']>;
  orderDue?: Maybe<Scalars['Float']>;
  orderTotal?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  vat?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "order" */
export type Order_Stddev_Order_By = {
  courseId?: InputMaybe<Order_By>;
  orderDue?: InputMaybe<Order_By>;
  orderTotal?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  vat?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Order_Stddev_Pop_Fields = {
  __typename?: 'order_stddev_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
  orderDue?: Maybe<Scalars['Float']>;
  orderTotal?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  vat?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "order" */
export type Order_Stddev_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
  orderDue?: InputMaybe<Order_By>;
  orderTotal?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  vat?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Order_Stddev_Samp_Fields = {
  __typename?: 'order_stddev_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
  orderDue?: Maybe<Scalars['Float']>;
  orderTotal?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  vat?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "order" */
export type Order_Stddev_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
  orderDue?: InputMaybe<Order_By>;
  orderTotal?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  vat?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Order_Sum_Fields = {
  __typename?: 'order_sum_fields';
  courseId?: Maybe<Scalars['Int']>;
  orderDue?: Maybe<Scalars['float8']>;
  orderTotal?: Maybe<Scalars['float8']>;
  price?: Maybe<Scalars['float8']>;
  quantity?: Maybe<Scalars['Int']>;
  vat?: Maybe<Scalars['float8']>;
};

/** order by sum() on columns of table "order" */
export type Order_Sum_Order_By = {
  courseId?: InputMaybe<Order_By>;
  orderDue?: InputMaybe<Order_By>;
  orderTotal?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  vat?: InputMaybe<Order_By>;
};

/** update columns of table "order" */
export enum Order_Update_Column {
  /** column name */
  BillingAddress = 'billingAddress',
  /** column name */
  BillingEmail = 'billingEmail',
  /** column name */
  BillingFamilyName = 'billingFamilyName',
  /** column name */
  BillingGivenName = 'billingGivenName',
  /** column name */
  BillingPhone = 'billingPhone',
  /** column name */
  ClientPurchaseOrder = 'clientPurchaseOrder',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Currency = 'currency',
  /** column name */
  Id = 'id',
  /** column name */
  OrderDue = 'orderDue',
  /** column name */
  OrderTotal = 'orderTotal',
  /** column name */
  OrganizationId = 'organizationId',
  /** column name */
  PaymentMethod = 'paymentMethod',
  /** column name */
  Price = 'price',
  /** column name */
  ProfileId = 'profileId',
  /** column name */
  PromoCodes = 'promoCodes',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  Registrants = 'registrants',
  /** column name */
  StripePaymentId = 'stripePaymentId',
  /** column name */
  Vat = 'vat',
  /** column name */
  XeroInvoiceNumber = 'xeroInvoiceNumber'
}

/** aggregate var_pop on columns */
export type Order_Var_Pop_Fields = {
  __typename?: 'order_var_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
  orderDue?: Maybe<Scalars['Float']>;
  orderTotal?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  vat?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "order" */
export type Order_Var_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
  orderDue?: InputMaybe<Order_By>;
  orderTotal?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  vat?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Order_Var_Samp_Fields = {
  __typename?: 'order_var_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
  orderDue?: Maybe<Scalars['Float']>;
  orderTotal?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  vat?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "order" */
export type Order_Var_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
  orderDue?: InputMaybe<Order_By>;
  orderTotal?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  vat?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Order_Variance_Fields = {
  __typename?: 'order_variance_fields';
  courseId?: Maybe<Scalars['Float']>;
  orderDue?: Maybe<Scalars['Float']>;
  orderTotal?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  vat?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "order" */
export type Order_Variance_Order_By = {
  courseId?: InputMaybe<Order_By>;
  orderDue?: InputMaybe<Order_By>;
  orderTotal?: InputMaybe<Order_By>;
  price?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  vat?: InputMaybe<Order_By>;
};

/** columns and relationships of "organization" */
export type Organization = {
  __typename?: 'organization';
  address: Scalars['jsonb'];
  attributes: Scalars['jsonb'];
  contactDetails: Scalars['jsonb'];
  createdAt: Scalars['timestamptz'];
  geoCoordinates?: Maybe<Scalars['point']>;
  go1Licenses?: Maybe<Scalars['Int']>;
  /** An array relationship */
  go1LicensesHistory: Array<Go1_Licenses_History>;
  /** An aggregate relationship */
  go1LicensesHistory_aggregate: Go1_Licenses_History_Aggregate;
  id: Scalars['uuid'];
  /** An array relationship */
  invites: Array<Organization_Invites>;
  /** An aggregate relationship */
  invites_aggregate: Organization_Invites_Aggregate;
  /** An array relationship */
  members: Array<Organization_Member>;
  /** An aggregate relationship */
  members_aggregate: Organization_Member_Aggregate;
  name: Scalars['String'];
  original_record?: Maybe<Scalars['jsonb']>;
  preferences: Scalars['jsonb'];
  region?: Maybe<Scalars['String']>;
  reservedGo1Licenses?: Maybe<Scalars['Int']>;
  sector?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['jsonb']>;
  trustName?: Maybe<Scalars['String']>;
  trustType?: Maybe<Trust_Type_Enum>;
  updatedAt: Scalars['timestamptz'];
  xeroContactId?: Maybe<Scalars['String']>;
};


/** columns and relationships of "organization" */
export type OrganizationAddressArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "organization" */
export type OrganizationAttributesArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "organization" */
export type OrganizationContactDetailsArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "organization" */
export type OrganizationGo1LicensesHistoryArgs = {
  distinct_on?: InputMaybe<Array<Go1_Licenses_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_Licenses_History_Order_By>>;
  where?: InputMaybe<Go1_Licenses_History_Bool_Exp>;
};


/** columns and relationships of "organization" */
export type OrganizationGo1LicensesHistory_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Go1_Licenses_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_Licenses_History_Order_By>>;
  where?: InputMaybe<Go1_Licenses_History_Bool_Exp>;
};


/** columns and relationships of "organization" */
export type OrganizationInvitesArgs = {
  distinct_on?: InputMaybe<Array<Organization_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Invites_Order_By>>;
  where?: InputMaybe<Organization_Invites_Bool_Exp>;
};


/** columns and relationships of "organization" */
export type OrganizationInvites_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Invites_Order_By>>;
  where?: InputMaybe<Organization_Invites_Bool_Exp>;
};


/** columns and relationships of "organization" */
export type OrganizationMembersArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Order_By>>;
  where?: InputMaybe<Organization_Member_Bool_Exp>;
};


/** columns and relationships of "organization" */
export type OrganizationMembers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Order_By>>;
  where?: InputMaybe<Organization_Member_Bool_Exp>;
};


/** columns and relationships of "organization" */
export type OrganizationOriginal_RecordArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "organization" */
export type OrganizationPreferencesArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "organization" */
export type OrganizationTagsArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "organization" */
export type Organization_Aggregate = {
  __typename?: 'organization_aggregate';
  aggregate?: Maybe<Organization_Aggregate_Fields>;
  nodes: Array<Organization>;
};

/** aggregate fields of "organization" */
export type Organization_Aggregate_Fields = {
  __typename?: 'organization_aggregate_fields';
  avg?: Maybe<Organization_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Organization_Max_Fields>;
  min?: Maybe<Organization_Min_Fields>;
  stddev?: Maybe<Organization_Stddev_Fields>;
  stddev_pop?: Maybe<Organization_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Organization_Stddev_Samp_Fields>;
  sum?: Maybe<Organization_Sum_Fields>;
  var_pop?: Maybe<Organization_Var_Pop_Fields>;
  var_samp?: Maybe<Organization_Var_Samp_Fields>;
  variance?: Maybe<Organization_Variance_Fields>;
};


/** aggregate fields of "organization" */
export type Organization_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Organization_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Organization_Append_Input = {
  address?: InputMaybe<Scalars['jsonb']>;
  attributes?: InputMaybe<Scalars['jsonb']>;
  contactDetails?: InputMaybe<Scalars['jsonb']>;
  original_record?: InputMaybe<Scalars['jsonb']>;
  preferences?: InputMaybe<Scalars['jsonb']>;
  tags?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Organization_Avg_Fields = {
  __typename?: 'organization_avg_fields';
  go1Licenses?: Maybe<Scalars['Float']>;
  reservedGo1Licenses?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "organization". All fields are combined with a logical 'AND'. */
export type Organization_Bool_Exp = {
  _and?: InputMaybe<Array<Organization_Bool_Exp>>;
  _not?: InputMaybe<Organization_Bool_Exp>;
  _or?: InputMaybe<Array<Organization_Bool_Exp>>;
  address?: InputMaybe<Jsonb_Comparison_Exp>;
  attributes?: InputMaybe<Jsonb_Comparison_Exp>;
  contactDetails?: InputMaybe<Jsonb_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  geoCoordinates?: InputMaybe<Point_Comparison_Exp>;
  go1Licenses?: InputMaybe<Int_Comparison_Exp>;
  go1LicensesHistory?: InputMaybe<Go1_Licenses_History_Bool_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  invites?: InputMaybe<Organization_Invites_Bool_Exp>;
  members?: InputMaybe<Organization_Member_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  original_record?: InputMaybe<Jsonb_Comparison_Exp>;
  preferences?: InputMaybe<Jsonb_Comparison_Exp>;
  region?: InputMaybe<String_Comparison_Exp>;
  reservedGo1Licenses?: InputMaybe<Int_Comparison_Exp>;
  sector?: InputMaybe<String_Comparison_Exp>;
  tags?: InputMaybe<Jsonb_Comparison_Exp>;
  trustName?: InputMaybe<String_Comparison_Exp>;
  trustType?: InputMaybe<Trust_Type_Enum_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  xeroContactId?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "organization" */
export enum Organization_Constraint {
  /** unique or primary key constraint */
  OrganizationPkey = 'organization_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Organization_Delete_At_Path_Input = {
  address?: InputMaybe<Array<Scalars['String']>>;
  attributes?: InputMaybe<Array<Scalars['String']>>;
  contactDetails?: InputMaybe<Array<Scalars['String']>>;
  original_record?: InputMaybe<Array<Scalars['String']>>;
  preferences?: InputMaybe<Array<Scalars['String']>>;
  tags?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Organization_Delete_Elem_Input = {
  address?: InputMaybe<Scalars['Int']>;
  attributes?: InputMaybe<Scalars['Int']>;
  contactDetails?: InputMaybe<Scalars['Int']>;
  original_record?: InputMaybe<Scalars['Int']>;
  preferences?: InputMaybe<Scalars['Int']>;
  tags?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Organization_Delete_Key_Input = {
  address?: InputMaybe<Scalars['String']>;
  attributes?: InputMaybe<Scalars['String']>;
  contactDetails?: InputMaybe<Scalars['String']>;
  original_record?: InputMaybe<Scalars['String']>;
  preferences?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "organization" */
export type Organization_Inc_Input = {
  go1Licenses?: InputMaybe<Scalars['Int']>;
  reservedGo1Licenses?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "organization" */
export type Organization_Insert_Input = {
  address?: InputMaybe<Scalars['jsonb']>;
  attributes?: InputMaybe<Scalars['jsonb']>;
  contactDetails?: InputMaybe<Scalars['jsonb']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  geoCoordinates?: InputMaybe<Scalars['point']>;
  go1Licenses?: InputMaybe<Scalars['Int']>;
  go1LicensesHistory?: InputMaybe<Go1_Licenses_History_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['uuid']>;
  invites?: InputMaybe<Organization_Invites_Arr_Rel_Insert_Input>;
  members?: InputMaybe<Organization_Member_Arr_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']>;
  original_record?: InputMaybe<Scalars['jsonb']>;
  preferences?: InputMaybe<Scalars['jsonb']>;
  region?: InputMaybe<Scalars['String']>;
  reservedGo1Licenses?: InputMaybe<Scalars['Int']>;
  sector?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['jsonb']>;
  trustName?: InputMaybe<Scalars['String']>;
  trustType?: InputMaybe<Trust_Type_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  xeroContactId?: InputMaybe<Scalars['String']>;
};

/** columns and relationships of "organization_invites" */
export type Organization_Invites = {
  __typename?: 'organization_invites';
  createdAt: Scalars['timestamptz'];
  email: Scalars['String'];
  id: Scalars['uuid'];
  isAdmin: Scalars['Boolean'];
  orgId: Scalars['uuid'];
  /** An object relationship */
  organization: Organization;
  /** An object relationship */
  profile?: Maybe<Profile>;
  profileId?: Maybe<Scalars['uuid']>;
  status: Scalars['String'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "organization_invites" */
export type Organization_Invites_Aggregate = {
  __typename?: 'organization_invites_aggregate';
  aggregate?: Maybe<Organization_Invites_Aggregate_Fields>;
  nodes: Array<Organization_Invites>;
};

/** aggregate fields of "organization_invites" */
export type Organization_Invites_Aggregate_Fields = {
  __typename?: 'organization_invites_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Organization_Invites_Max_Fields>;
  min?: Maybe<Organization_Invites_Min_Fields>;
};


/** aggregate fields of "organization_invites" */
export type Organization_Invites_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Organization_Invites_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "organization_invites" */
export type Organization_Invites_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Organization_Invites_Max_Order_By>;
  min?: InputMaybe<Organization_Invites_Min_Order_By>;
};

/** input type for inserting array relation for remote table "organization_invites" */
export type Organization_Invites_Arr_Rel_Insert_Input = {
  data: Array<Organization_Invites_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Organization_Invites_On_Conflict>;
};

/** Boolean expression to filter rows from the table "organization_invites". All fields are combined with a logical 'AND'. */
export type Organization_Invites_Bool_Exp = {
  _and?: InputMaybe<Array<Organization_Invites_Bool_Exp>>;
  _not?: InputMaybe<Organization_Invites_Bool_Exp>;
  _or?: InputMaybe<Array<Organization_Invites_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  isAdmin?: InputMaybe<Boolean_Comparison_Exp>;
  orgId?: InputMaybe<Uuid_Comparison_Exp>;
  organization?: InputMaybe<Organization_Bool_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profileId?: InputMaybe<Uuid_Comparison_Exp>;
  status?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "organization_invites" */
export enum Organization_Invites_Constraint {
  /** unique or primary key constraint */
  OrganizationInvitesOrgIdEmailKey = 'organization_invites_org_id_email_key',
  /** unique or primary key constraint */
  OrganizationInvitesOrgIdProfileIdKey = 'organization_invites_org_id_profile_id_key',
  /** unique or primary key constraint */
  OrganizationInvitesPkey = 'organization_invites_pkey'
}

/** input type for inserting data into table "organization_invites" */
export type Organization_Invites_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isAdmin?: InputMaybe<Scalars['Boolean']>;
  orgId?: InputMaybe<Scalars['uuid']>;
  organization?: InputMaybe<Organization_Obj_Rel_Insert_Input>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profileId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Organization_Invites_Max_Fields = {
  __typename?: 'organization_invites_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  orgId?: Maybe<Scalars['uuid']>;
  profileId?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "organization_invites" */
export type Organization_Invites_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  orgId?: InputMaybe<Order_By>;
  profileId?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Organization_Invites_Min_Fields = {
  __typename?: 'organization_invites_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  orgId?: Maybe<Scalars['uuid']>;
  profileId?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "organization_invites" */
export type Organization_Invites_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  orgId?: InputMaybe<Order_By>;
  profileId?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "organization_invites" */
export type Organization_Invites_Mutation_Response = {
  __typename?: 'organization_invites_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Organization_Invites>;
};

/** on_conflict condition type for table "organization_invites" */
export type Organization_Invites_On_Conflict = {
  constraint: Organization_Invites_Constraint;
  update_columns?: Array<Organization_Invites_Update_Column>;
  where?: InputMaybe<Organization_Invites_Bool_Exp>;
};

/** Ordering options when selecting data from "organization_invites". */
export type Organization_Invites_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  isAdmin?: InputMaybe<Order_By>;
  orgId?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organization_Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profileId?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: organization_invites */
export type Organization_Invites_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "organization_invites" */
export enum Organization_Invites_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  IsAdmin = 'isAdmin',
  /** column name */
  OrgId = 'orgId',
  /** column name */
  ProfileId = 'profileId',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "organization_invites" */
export type Organization_Invites_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  isAdmin?: InputMaybe<Scalars['Boolean']>;
  orgId?: InputMaybe<Scalars['uuid']>;
  profileId?: InputMaybe<Scalars['uuid']>;
  status?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "organization_invites" */
export enum Organization_Invites_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  IsAdmin = 'isAdmin',
  /** column name */
  OrgId = 'orgId',
  /** column name */
  ProfileId = 'profileId',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate max on columns */
export type Organization_Max_Fields = {
  __typename?: 'organization_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  go1Licenses?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  reservedGo1Licenses?: Maybe<Scalars['Int']>;
  sector?: Maybe<Scalars['String']>;
  trustName?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  xeroContactId?: Maybe<Scalars['String']>;
};

/** columns and relationships of "organization_member" */
export type Organization_Member = {
  __typename?: 'organization_member';
  _source?: Maybe<Scalars['String']>;
  createdAt: Scalars['timestamptz'];
  id: Scalars['uuid'];
  isAdmin?: Maybe<Scalars['Boolean']>;
  memberType?: Maybe<Scalars['String']>;
  /** An object relationship */
  organization: Organization;
  organization_id: Scalars['uuid'];
  position?: Maybe<Scalars['String']>;
  /** An object relationship */
  profile: Profile;
  profile_id: Scalars['uuid'];
  updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "organization_member" */
export type Organization_Member_Aggregate = {
  __typename?: 'organization_member_aggregate';
  aggregate?: Maybe<Organization_Member_Aggregate_Fields>;
  nodes: Array<Organization_Member>;
};

/** aggregate fields of "organization_member" */
export type Organization_Member_Aggregate_Fields = {
  __typename?: 'organization_member_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Organization_Member_Max_Fields>;
  min?: Maybe<Organization_Member_Min_Fields>;
};


/** aggregate fields of "organization_member" */
export type Organization_Member_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Organization_Member_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "organization_member" */
export type Organization_Member_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Organization_Member_Max_Order_By>;
  min?: InputMaybe<Organization_Member_Min_Order_By>;
};

/** input type for inserting array relation for remote table "organization_member" */
export type Organization_Member_Arr_Rel_Insert_Input = {
  data: Array<Organization_Member_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Organization_Member_On_Conflict>;
};

/** Boolean expression to filter rows from the table "organization_member". All fields are combined with a logical 'AND'. */
export type Organization_Member_Bool_Exp = {
  _and?: InputMaybe<Array<Organization_Member_Bool_Exp>>;
  _not?: InputMaybe<Organization_Member_Bool_Exp>;
  _or?: InputMaybe<Array<Organization_Member_Bool_Exp>>;
  _source?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  isAdmin?: InputMaybe<Boolean_Comparison_Exp>;
  memberType?: InputMaybe<String_Comparison_Exp>;
  organization?: InputMaybe<Organization_Bool_Exp>;
  organization_id?: InputMaybe<Uuid_Comparison_Exp>;
  position?: InputMaybe<String_Comparison_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profile_id?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "organization_member" */
export enum Organization_Member_Constraint {
  /** unique or primary key constraint */
  OrganizationMemberPkey = 'organization_member_pkey',
  /** unique or primary key constraint */
  OrganizationMemberProfileIdOrganizationIdKey = 'organization_member_profile_id_organization_id_key'
}

/** input type for inserting data into table "organization_member" */
export type Organization_Member_Insert_Input = {
  _source?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  isAdmin?: InputMaybe<Scalars['Boolean']>;
  memberType?: InputMaybe<Scalars['String']>;
  organization?: InputMaybe<Organization_Obj_Rel_Insert_Input>;
  organization_id?: InputMaybe<Scalars['uuid']>;
  position?: InputMaybe<Scalars['String']>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Organization_Member_Max_Fields = {
  __typename?: 'organization_member_max_fields';
  _source?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  memberType?: Maybe<Scalars['String']>;
  organization_id?: Maybe<Scalars['uuid']>;
  position?: Maybe<Scalars['String']>;
  profile_id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "organization_member" */
export type Organization_Member_Max_Order_By = {
  _source?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  memberType?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Organization_Member_Min_Fields = {
  __typename?: 'organization_member_min_fields';
  _source?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  memberType?: Maybe<Scalars['String']>;
  organization_id?: Maybe<Scalars['uuid']>;
  position?: Maybe<Scalars['String']>;
  profile_id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "organization_member" */
export type Organization_Member_Min_Order_By = {
  _source?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  memberType?: InputMaybe<Order_By>;
  organization_id?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "organization_member" */
export type Organization_Member_Mutation_Response = {
  __typename?: 'organization_member_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Organization_Member>;
};

/** on_conflict condition type for table "organization_member" */
export type Organization_Member_On_Conflict = {
  constraint: Organization_Member_Constraint;
  update_columns?: Array<Organization_Member_Update_Column>;
  where?: InputMaybe<Organization_Member_Bool_Exp>;
};

/** Ordering options when selecting data from "organization_member". */
export type Organization_Member_Order_By = {
  _source?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  isAdmin?: InputMaybe<Order_By>;
  memberType?: InputMaybe<Order_By>;
  organization?: InputMaybe<Organization_Order_By>;
  organization_id?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profile_id?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: organization_member */
export type Organization_Member_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "organization_member" */
export enum Organization_Member_Select_Column {
  /** column name */
  Source = '_source',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsAdmin = 'isAdmin',
  /** column name */
  MemberType = 'memberType',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  Position = 'position',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "organization_member" */
export type Organization_Member_Set_Input = {
  _source?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  isAdmin?: InputMaybe<Scalars['Boolean']>;
  memberType?: InputMaybe<Scalars['String']>;
  organization_id?: InputMaybe<Scalars['uuid']>;
  position?: InputMaybe<Scalars['String']>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "organization_member" */
export enum Organization_Member_Update_Column {
  /** column name */
  Source = '_source',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsAdmin = 'isAdmin',
  /** column name */
  MemberType = 'memberType',
  /** column name */
  OrganizationId = 'organization_id',
  /** column name */
  Position = 'position',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate min on columns */
export type Organization_Min_Fields = {
  __typename?: 'organization_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']>;
  go1Licenses?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  reservedGo1Licenses?: Maybe<Scalars['Int']>;
  sector?: Maybe<Scalars['String']>;
  trustName?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  xeroContactId?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "organization" */
export type Organization_Mutation_Response = {
  __typename?: 'organization_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Organization>;
};

/** input type for inserting object relation for remote table "organization" */
export type Organization_Obj_Rel_Insert_Input = {
  data: Organization_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Organization_On_Conflict>;
};

/** on_conflict condition type for table "organization" */
export type Organization_On_Conflict = {
  constraint: Organization_Constraint;
  update_columns?: Array<Organization_Update_Column>;
  where?: InputMaybe<Organization_Bool_Exp>;
};

/** Ordering options when selecting data from "organization". */
export type Organization_Order_By = {
  address?: InputMaybe<Order_By>;
  attributes?: InputMaybe<Order_By>;
  contactDetails?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  geoCoordinates?: InputMaybe<Order_By>;
  go1Licenses?: InputMaybe<Order_By>;
  go1LicensesHistory_aggregate?: InputMaybe<Go1_Licenses_History_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  invites_aggregate?: InputMaybe<Organization_Invites_Aggregate_Order_By>;
  members_aggregate?: InputMaybe<Organization_Member_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  original_record?: InputMaybe<Order_By>;
  preferences?: InputMaybe<Order_By>;
  region?: InputMaybe<Order_By>;
  reservedGo1Licenses?: InputMaybe<Order_By>;
  sector?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  trustName?: InputMaybe<Order_By>;
  trustType?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  xeroContactId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: organization */
export type Organization_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Organization_Prepend_Input = {
  address?: InputMaybe<Scalars['jsonb']>;
  attributes?: InputMaybe<Scalars['jsonb']>;
  contactDetails?: InputMaybe<Scalars['jsonb']>;
  original_record?: InputMaybe<Scalars['jsonb']>;
  preferences?: InputMaybe<Scalars['jsonb']>;
  tags?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "organization" */
export enum Organization_Select_Column {
  /** column name */
  Address = 'address',
  /** column name */
  Attributes = 'attributes',
  /** column name */
  ContactDetails = 'contactDetails',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GeoCoordinates = 'geoCoordinates',
  /** column name */
  Go1Licenses = 'go1Licenses',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginalRecord = 'original_record',
  /** column name */
  Preferences = 'preferences',
  /** column name */
  Region = 'region',
  /** column name */
  ReservedGo1Licenses = 'reservedGo1Licenses',
  /** column name */
  Sector = 'sector',
  /** column name */
  Tags = 'tags',
  /** column name */
  TrustName = 'trustName',
  /** column name */
  TrustType = 'trustType',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  XeroContactId = 'xeroContactId'
}

/** input type for updating data in table "organization" */
export type Organization_Set_Input = {
  address?: InputMaybe<Scalars['jsonb']>;
  attributes?: InputMaybe<Scalars['jsonb']>;
  contactDetails?: InputMaybe<Scalars['jsonb']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  geoCoordinates?: InputMaybe<Scalars['point']>;
  go1Licenses?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  original_record?: InputMaybe<Scalars['jsonb']>;
  preferences?: InputMaybe<Scalars['jsonb']>;
  region?: InputMaybe<Scalars['String']>;
  reservedGo1Licenses?: InputMaybe<Scalars['Int']>;
  sector?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['jsonb']>;
  trustName?: InputMaybe<Scalars['String']>;
  trustType?: InputMaybe<Trust_Type_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  xeroContactId?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Organization_Stddev_Fields = {
  __typename?: 'organization_stddev_fields';
  go1Licenses?: Maybe<Scalars['Float']>;
  reservedGo1Licenses?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Organization_Stddev_Pop_Fields = {
  __typename?: 'organization_stddev_pop_fields';
  go1Licenses?: Maybe<Scalars['Float']>;
  reservedGo1Licenses?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Organization_Stddev_Samp_Fields = {
  __typename?: 'organization_stddev_samp_fields';
  go1Licenses?: Maybe<Scalars['Float']>;
  reservedGo1Licenses?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Organization_Sum_Fields = {
  __typename?: 'organization_sum_fields';
  go1Licenses?: Maybe<Scalars['Int']>;
  reservedGo1Licenses?: Maybe<Scalars['Int']>;
};

/** update columns of table "organization" */
export enum Organization_Update_Column {
  /** column name */
  Address = 'address',
  /** column name */
  Attributes = 'attributes',
  /** column name */
  ContactDetails = 'contactDetails',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GeoCoordinates = 'geoCoordinates',
  /** column name */
  Go1Licenses = 'go1Licenses',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginalRecord = 'original_record',
  /** column name */
  Preferences = 'preferences',
  /** column name */
  Region = 'region',
  /** column name */
  ReservedGo1Licenses = 'reservedGo1Licenses',
  /** column name */
  Sector = 'sector',
  /** column name */
  Tags = 'tags',
  /** column name */
  TrustName = 'trustName',
  /** column name */
  TrustType = 'trustType',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  XeroContactId = 'xeroContactId'
}

/** aggregate var_pop on columns */
export type Organization_Var_Pop_Fields = {
  __typename?: 'organization_var_pop_fields';
  go1Licenses?: Maybe<Scalars['Float']>;
  reservedGo1Licenses?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Organization_Var_Samp_Fields = {
  __typename?: 'organization_var_samp_fields';
  go1Licenses?: Maybe<Scalars['Float']>;
  reservedGo1Licenses?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Organization_Variance_Fields = {
  __typename?: 'organization_variance_fields';
  go1Licenses?: Maybe<Scalars['Float']>;
  reservedGo1Licenses?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "payment_methods" */
export type Payment_Methods = {
  __typename?: 'payment_methods';
  name: Scalars['String'];
};

/** aggregated selection of "payment_methods" */
export type Payment_Methods_Aggregate = {
  __typename?: 'payment_methods_aggregate';
  aggregate?: Maybe<Payment_Methods_Aggregate_Fields>;
  nodes: Array<Payment_Methods>;
};

/** aggregate fields of "payment_methods" */
export type Payment_Methods_Aggregate_Fields = {
  __typename?: 'payment_methods_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Payment_Methods_Max_Fields>;
  min?: Maybe<Payment_Methods_Min_Fields>;
};


/** aggregate fields of "payment_methods" */
export type Payment_Methods_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Payment_Methods_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "payment_methods". All fields are combined with a logical 'AND'. */
export type Payment_Methods_Bool_Exp = {
  _and?: InputMaybe<Array<Payment_Methods_Bool_Exp>>;
  _not?: InputMaybe<Payment_Methods_Bool_Exp>;
  _or?: InputMaybe<Array<Payment_Methods_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "payment_methods" */
export enum Payment_Methods_Constraint {
  /** unique or primary key constraint */
  PaymentMethodsPkey = 'payment_methods_pkey'
}

export enum Payment_Methods_Enum {
  Cc = 'CC',
  Invoice = 'INVOICE'
}

/** Boolean expression to compare columns of type "payment_methods_enum". All fields are combined with logical 'AND'. */
export type Payment_Methods_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Payment_Methods_Enum>;
  _in?: InputMaybe<Array<Payment_Methods_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Payment_Methods_Enum>;
  _nin?: InputMaybe<Array<Payment_Methods_Enum>>;
};

/** input type for inserting data into table "payment_methods" */
export type Payment_Methods_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Payment_Methods_Max_Fields = {
  __typename?: 'payment_methods_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Payment_Methods_Min_Fields = {
  __typename?: 'payment_methods_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "payment_methods" */
export type Payment_Methods_Mutation_Response = {
  __typename?: 'payment_methods_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Payment_Methods>;
};

/** on_conflict condition type for table "payment_methods" */
export type Payment_Methods_On_Conflict = {
  constraint: Payment_Methods_Constraint;
  update_columns?: Array<Payment_Methods_Update_Column>;
  where?: InputMaybe<Payment_Methods_Bool_Exp>;
};

/** Ordering options when selecting data from "payment_methods". */
export type Payment_Methods_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: payment_methods */
export type Payment_Methods_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "payment_methods" */
export enum Payment_Methods_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "payment_methods" */
export type Payment_Methods_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "payment_methods" */
export enum Payment_Methods_Update_Column {
  /** column name */
  Name = 'name'
}

/** Boolean expression to compare columns of type "point". All fields are combined with logical 'AND'. */
export type Point_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['point']>;
  _gt?: InputMaybe<Scalars['point']>;
  _gte?: InputMaybe<Scalars['point']>;
  _in?: InputMaybe<Array<Scalars['point']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['point']>;
  _lte?: InputMaybe<Scalars['point']>;
  _neq?: InputMaybe<Scalars['point']>;
  _nin?: InputMaybe<Array<Scalars['point']>>;
};

/** Private course booking enquiry */
export type Private_Course_Booking = {
  __typename?: 'private_course_booking';
  courseId: Scalars['Int'];
  createdAt?: Maybe<Scalars['timestamptz']>;
  email: Scalars['String'];
  familyName: Scalars['String'];
  givenName: Scalars['String'];
  id: Scalars['uuid'];
  message?: Maybe<Scalars['String']>;
  numParticipants: Scalars['Int'];
  orgName: Scalars['String'];
  phone: Scalars['String'];
  sector: Scalars['String'];
  source?: Maybe<Scalars['String']>;
};

/** aggregated selection of "private_course_booking" */
export type Private_Course_Booking_Aggregate = {
  __typename?: 'private_course_booking_aggregate';
  aggregate?: Maybe<Private_Course_Booking_Aggregate_Fields>;
  nodes: Array<Private_Course_Booking>;
};

/** aggregate fields of "private_course_booking" */
export type Private_Course_Booking_Aggregate_Fields = {
  __typename?: 'private_course_booking_aggregate_fields';
  avg?: Maybe<Private_Course_Booking_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Private_Course_Booking_Max_Fields>;
  min?: Maybe<Private_Course_Booking_Min_Fields>;
  stddev?: Maybe<Private_Course_Booking_Stddev_Fields>;
  stddev_pop?: Maybe<Private_Course_Booking_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Private_Course_Booking_Stddev_Samp_Fields>;
  sum?: Maybe<Private_Course_Booking_Sum_Fields>;
  var_pop?: Maybe<Private_Course_Booking_Var_Pop_Fields>;
  var_samp?: Maybe<Private_Course_Booking_Var_Samp_Fields>;
  variance?: Maybe<Private_Course_Booking_Variance_Fields>;
};


/** aggregate fields of "private_course_booking" */
export type Private_Course_Booking_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Private_Course_Booking_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Private_Course_Booking_Avg_Fields = {
  __typename?: 'private_course_booking_avg_fields';
  courseId?: Maybe<Scalars['Float']>;
  numParticipants?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "private_course_booking". All fields are combined with a logical 'AND'. */
export type Private_Course_Booking_Bool_Exp = {
  _and?: InputMaybe<Array<Private_Course_Booking_Bool_Exp>>;
  _not?: InputMaybe<Private_Course_Booking_Bool_Exp>;
  _or?: InputMaybe<Array<Private_Course_Booking_Bool_Exp>>;
  courseId?: InputMaybe<Int_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  familyName?: InputMaybe<String_Comparison_Exp>;
  givenName?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  message?: InputMaybe<String_Comparison_Exp>;
  numParticipants?: InputMaybe<Int_Comparison_Exp>;
  orgName?: InputMaybe<String_Comparison_Exp>;
  phone?: InputMaybe<String_Comparison_Exp>;
  sector?: InputMaybe<String_Comparison_Exp>;
  source?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "private_course_booking" */
export enum Private_Course_Booking_Constraint {
  /** unique or primary key constraint */
  PrivateCourseBookingCourseIdEmailKey = 'private_course_booking_course_id_email_key',
  /** unique or primary key constraint */
  PrivateCourseBookingPkey = 'private_course_booking_pkey'
}

/** input type for incrementing numeric columns in table "private_course_booking" */
export type Private_Course_Booking_Inc_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
  numParticipants?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "private_course_booking" */
export type Private_Course_Booking_Insert_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  familyName?: InputMaybe<Scalars['String']>;
  givenName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  message?: InputMaybe<Scalars['String']>;
  numParticipants?: InputMaybe<Scalars['Int']>;
  orgName?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  sector?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Private_Course_Booking_Max_Fields = {
  __typename?: 'private_course_booking_max_fields';
  courseId?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  givenName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  numParticipants?: Maybe<Scalars['Int']>;
  orgName?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  sector?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Private_Course_Booking_Min_Fields = {
  __typename?: 'private_course_booking_min_fields';
  courseId?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  givenName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  numParticipants?: Maybe<Scalars['Int']>;
  orgName?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  sector?: Maybe<Scalars['String']>;
  source?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "private_course_booking" */
export type Private_Course_Booking_Mutation_Response = {
  __typename?: 'private_course_booking_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Private_Course_Booking>;
};

/** on_conflict condition type for table "private_course_booking" */
export type Private_Course_Booking_On_Conflict = {
  constraint: Private_Course_Booking_Constraint;
  update_columns?: Array<Private_Course_Booking_Update_Column>;
  where?: InputMaybe<Private_Course_Booking_Bool_Exp>;
};

/** Ordering options when selecting data from "private_course_booking". */
export type Private_Course_Booking_Order_By = {
  courseId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  familyName?: InputMaybe<Order_By>;
  givenName?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  message?: InputMaybe<Order_By>;
  numParticipants?: InputMaybe<Order_By>;
  orgName?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
  sector?: InputMaybe<Order_By>;
  source?: InputMaybe<Order_By>;
};

/** primary key columns input for table: private_course_booking */
export type Private_Course_Booking_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "private_course_booking" */
export enum Private_Course_Booking_Select_Column {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  FamilyName = 'familyName',
  /** column name */
  GivenName = 'givenName',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message',
  /** column name */
  NumParticipants = 'numParticipants',
  /** column name */
  OrgName = 'orgName',
  /** column name */
  Phone = 'phone',
  /** column name */
  Sector = 'sector',
  /** column name */
  Source = 'source'
}

/** input type for updating data in table "private_course_booking" */
export type Private_Course_Booking_Set_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  familyName?: InputMaybe<Scalars['String']>;
  givenName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  message?: InputMaybe<Scalars['String']>;
  numParticipants?: InputMaybe<Scalars['Int']>;
  orgName?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
  sector?: InputMaybe<Scalars['String']>;
  source?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Private_Course_Booking_Stddev_Fields = {
  __typename?: 'private_course_booking_stddev_fields';
  courseId?: Maybe<Scalars['Float']>;
  numParticipants?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Private_Course_Booking_Stddev_Pop_Fields = {
  __typename?: 'private_course_booking_stddev_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
  numParticipants?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Private_Course_Booking_Stddev_Samp_Fields = {
  __typename?: 'private_course_booking_stddev_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
  numParticipants?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Private_Course_Booking_Sum_Fields = {
  __typename?: 'private_course_booking_sum_fields';
  courseId?: Maybe<Scalars['Int']>;
  numParticipants?: Maybe<Scalars['Int']>;
};

/** update columns of table "private_course_booking" */
export enum Private_Course_Booking_Update_Column {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  FamilyName = 'familyName',
  /** column name */
  GivenName = 'givenName',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message',
  /** column name */
  NumParticipants = 'numParticipants',
  /** column name */
  OrgName = 'orgName',
  /** column name */
  Phone = 'phone',
  /** column name */
  Sector = 'sector',
  /** column name */
  Source = 'source'
}

/** aggregate var_pop on columns */
export type Private_Course_Booking_Var_Pop_Fields = {
  __typename?: 'private_course_booking_var_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
  numParticipants?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Private_Course_Booking_Var_Samp_Fields = {
  __typename?: 'private_course_booking_var_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
  numParticipants?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Private_Course_Booking_Variance_Fields = {
  __typename?: 'private_course_booking_variance_fields';
  courseId?: Maybe<Scalars['Float']>;
  numParticipants?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "profile" */
export type Profile = {
  __typename?: 'profile';
  addresses: Scalars['jsonb'];
  attributes: Scalars['jsonb'];
  avatar?: Maybe<Scalars['String']>;
  /** An array relationship */
  certificates: Array<Course_Certificate>;
  /** An aggregate relationship */
  certificates_aggregate: Course_Certificate_Aggregate;
  contactDetails: Scalars['jsonb'];
  /** An array relationship */
  course_trainer: Array<Course_Trainer>;
  /** An aggregate relationship */
  course_trainer_aggregate: Course_Trainer_Aggregate;
  /** An array relationship */
  courses: Array<Course_Participant>;
  /** An aggregate relationship */
  courses_aggregate: Course_Participant_Aggregate;
  createdAt: Scalars['timestamptz'];
  dbs?: Maybe<Scalars['String']>;
  dietaryRestrictions?: Maybe<Scalars['String']>;
  disabilities?: Maybe<Scalars['String']>;
  dob?: Maybe<Scalars['date']>;
  email?: Maybe<Scalars['String']>;
  familyName: Scalars['String'];
  fullName?: Maybe<Scalars['String']>;
  givenName: Scalars['String'];
  go1Id?: Maybe<Scalars['Int']>;
  /** An array relationship */
  go1Licenses: Array<Go1_Licenses>;
  /** An aggregate relationship */
  go1Licenses_aggregate: Go1_Licenses_Aggregate;
  go1_profile?: Maybe<Scalars['jsonb']>;
  id: Scalars['uuid'];
  /** An array relationship */
  identities: Array<Identity>;
  /** An aggregate relationship */
  identities_aggregate: Identity_Aggregate;
  jobTitle?: Maybe<Scalars['String']>;
  lastActivity: Scalars['timestamptz'];
  /** An array relationship */
  organizations: Array<Organization_Member>;
  /** An aggregate relationship */
  organizations_aggregate: Organization_Member_Aggregate;
  original_record: Scalars['jsonb'];
  /** An array relationship */
  participant_audits: Array<Course_Participant_Audit>;
  /** An aggregate relationship */
  participant_audits_aggregate: Course_Participant_Audit_Aggregate;
  phone?: Maybe<Scalars['String']>;
  preferences: Scalars['jsonb'];
  /** An array relationship */
  roles: Array<Profile_Role>;
  /** An aggregate relationship */
  roles_aggregate: Profile_Role_Aggregate;
  stripe_customer_id?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['jsonb']>;
  title?: Maybe<Scalars['String']>;
  /** An array relationship */
  trainer_role_types: Array<Profile_Trainer_Role_Type>;
  /** An aggregate relationship */
  trainer_role_types_aggregate: Profile_Trainer_Role_Type_Aggregate;
  /** An array relationship */
  upcomingEnrollments: Array<Upcoming_Enrollments>;
  /** An aggregate relationship */
  upcomingEnrollments_aggregate: Upcoming_Enrollments_Aggregate;
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "profile" */
export type ProfileAddressesArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "profile" */
export type ProfileAttributesArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "profile" */
export type ProfileCertificatesArgs = {
  distinct_on?: InputMaybe<Array<Course_Certificate_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Certificate_Order_By>>;
  where?: InputMaybe<Course_Certificate_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileCertificates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Certificate_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Certificate_Order_By>>;
  where?: InputMaybe<Course_Certificate_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileContactDetailsArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "profile" */
export type ProfileCourse_TrainerArgs = {
  distinct_on?: InputMaybe<Array<Course_Trainer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Trainer_Order_By>>;
  where?: InputMaybe<Course_Trainer_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileCourse_Trainer_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Trainer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Trainer_Order_By>>;
  where?: InputMaybe<Course_Trainer_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileCoursesArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Order_By>>;
  where?: InputMaybe<Course_Participant_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileCourses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Order_By>>;
  where?: InputMaybe<Course_Participant_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileGo1LicensesArgs = {
  distinct_on?: InputMaybe<Array<Go1_Licenses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_Licenses_Order_By>>;
  where?: InputMaybe<Go1_Licenses_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileGo1Licenses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Go1_Licenses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_Licenses_Order_By>>;
  where?: InputMaybe<Go1_Licenses_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileGo1_ProfileArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "profile" */
export type ProfileIdentitiesArgs = {
  distinct_on?: InputMaybe<Array<Identity_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Identity_Order_By>>;
  where?: InputMaybe<Identity_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileIdentities_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Identity_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Identity_Order_By>>;
  where?: InputMaybe<Identity_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileOrganizationsArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Order_By>>;
  where?: InputMaybe<Organization_Member_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileOrganizations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Order_By>>;
  where?: InputMaybe<Organization_Member_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileOriginal_RecordArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "profile" */
export type ProfileParticipant_AuditsArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Audit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Audit_Order_By>>;
  where?: InputMaybe<Course_Participant_Audit_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileParticipant_Audits_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Audit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Audit_Order_By>>;
  where?: InputMaybe<Course_Participant_Audit_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfilePreferencesArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "profile" */
export type ProfileRolesArgs = {
  distinct_on?: InputMaybe<Array<Profile_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Role_Order_By>>;
  where?: InputMaybe<Profile_Role_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileRoles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Role_Order_By>>;
  where?: InputMaybe<Profile_Role_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileTagsArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "profile" */
export type ProfileTrainer_Role_TypesArgs = {
  distinct_on?: InputMaybe<Array<Profile_Trainer_Role_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Trainer_Role_Type_Order_By>>;
  where?: InputMaybe<Profile_Trainer_Role_Type_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileTrainer_Role_Types_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Trainer_Role_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Trainer_Role_Type_Order_By>>;
  where?: InputMaybe<Profile_Trainer_Role_Type_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileUpcomingEnrollmentsArgs = {
  distinct_on?: InputMaybe<Array<Upcoming_Enrollments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Upcoming_Enrollments_Order_By>>;
  where?: InputMaybe<Upcoming_Enrollments_Bool_Exp>;
};


/** columns and relationships of "profile" */
export type ProfileUpcomingEnrollments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Upcoming_Enrollments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Upcoming_Enrollments_Order_By>>;
  where?: InputMaybe<Upcoming_Enrollments_Bool_Exp>;
};

/** aggregated selection of "profile" */
export type Profile_Aggregate = {
  __typename?: 'profile_aggregate';
  aggregate?: Maybe<Profile_Aggregate_Fields>;
  nodes: Array<Profile>;
};

/** aggregate fields of "profile" */
export type Profile_Aggregate_Fields = {
  __typename?: 'profile_aggregate_fields';
  avg?: Maybe<Profile_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Profile_Max_Fields>;
  min?: Maybe<Profile_Min_Fields>;
  stddev?: Maybe<Profile_Stddev_Fields>;
  stddev_pop?: Maybe<Profile_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Profile_Stddev_Samp_Fields>;
  sum?: Maybe<Profile_Sum_Fields>;
  var_pop?: Maybe<Profile_Var_Pop_Fields>;
  var_samp?: Maybe<Profile_Var_Samp_Fields>;
  variance?: Maybe<Profile_Variance_Fields>;
};


/** aggregate fields of "profile" */
export type Profile_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Profile_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Profile_Append_Input = {
  addresses?: InputMaybe<Scalars['jsonb']>;
  attributes?: InputMaybe<Scalars['jsonb']>;
  contactDetails?: InputMaybe<Scalars['jsonb']>;
  go1_profile?: InputMaybe<Scalars['jsonb']>;
  original_record?: InputMaybe<Scalars['jsonb']>;
  preferences?: InputMaybe<Scalars['jsonb']>;
  tags?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Profile_Avg_Fields = {
  __typename?: 'profile_avg_fields';
  go1Id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "profile". All fields are combined with a logical 'AND'. */
export type Profile_Bool_Exp = {
  _and?: InputMaybe<Array<Profile_Bool_Exp>>;
  _not?: InputMaybe<Profile_Bool_Exp>;
  _or?: InputMaybe<Array<Profile_Bool_Exp>>;
  addresses?: InputMaybe<Jsonb_Comparison_Exp>;
  attributes?: InputMaybe<Jsonb_Comparison_Exp>;
  avatar?: InputMaybe<String_Comparison_Exp>;
  certificates?: InputMaybe<Course_Certificate_Bool_Exp>;
  contactDetails?: InputMaybe<Jsonb_Comparison_Exp>;
  course_trainer?: InputMaybe<Course_Trainer_Bool_Exp>;
  courses?: InputMaybe<Course_Participant_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  dbs?: InputMaybe<String_Comparison_Exp>;
  dietaryRestrictions?: InputMaybe<String_Comparison_Exp>;
  disabilities?: InputMaybe<String_Comparison_Exp>;
  dob?: InputMaybe<Date_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  familyName?: InputMaybe<String_Comparison_Exp>;
  fullName?: InputMaybe<String_Comparison_Exp>;
  givenName?: InputMaybe<String_Comparison_Exp>;
  go1Id?: InputMaybe<Int_Comparison_Exp>;
  go1Licenses?: InputMaybe<Go1_Licenses_Bool_Exp>;
  go1_profile?: InputMaybe<Jsonb_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  identities?: InputMaybe<Identity_Bool_Exp>;
  jobTitle?: InputMaybe<String_Comparison_Exp>;
  lastActivity?: InputMaybe<Timestamptz_Comparison_Exp>;
  organizations?: InputMaybe<Organization_Member_Bool_Exp>;
  original_record?: InputMaybe<Jsonb_Comparison_Exp>;
  participant_audits?: InputMaybe<Course_Participant_Audit_Bool_Exp>;
  phone?: InputMaybe<String_Comparison_Exp>;
  preferences?: InputMaybe<Jsonb_Comparison_Exp>;
  roles?: InputMaybe<Profile_Role_Bool_Exp>;
  stripe_customer_id?: InputMaybe<String_Comparison_Exp>;
  tags?: InputMaybe<Jsonb_Comparison_Exp>;
  title?: InputMaybe<String_Comparison_Exp>;
  trainer_role_types?: InputMaybe<Profile_Trainer_Role_Type_Bool_Exp>;
  upcomingEnrollments?: InputMaybe<Upcoming_Enrollments_Bool_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "profile" */
export enum Profile_Constraint {
  /** unique or primary key constraint */
  ProfileEmailKey = 'profile_email_key',
  /** unique or primary key constraint */
  ProfilePkey = 'profile_pkey',
  /** unique or primary key constraint */
  ProfileStripeCustomerIdKey = 'profile_stripe_customer_id_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Profile_Delete_At_Path_Input = {
  addresses?: InputMaybe<Array<Scalars['String']>>;
  attributes?: InputMaybe<Array<Scalars['String']>>;
  contactDetails?: InputMaybe<Array<Scalars['String']>>;
  go1_profile?: InputMaybe<Array<Scalars['String']>>;
  original_record?: InputMaybe<Array<Scalars['String']>>;
  preferences?: InputMaybe<Array<Scalars['String']>>;
  tags?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Profile_Delete_Elem_Input = {
  addresses?: InputMaybe<Scalars['Int']>;
  attributes?: InputMaybe<Scalars['Int']>;
  contactDetails?: InputMaybe<Scalars['Int']>;
  go1_profile?: InputMaybe<Scalars['Int']>;
  original_record?: InputMaybe<Scalars['Int']>;
  preferences?: InputMaybe<Scalars['Int']>;
  tags?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Profile_Delete_Key_Input = {
  addresses?: InputMaybe<Scalars['String']>;
  attributes?: InputMaybe<Scalars['String']>;
  contactDetails?: InputMaybe<Scalars['String']>;
  go1_profile?: InputMaybe<Scalars['String']>;
  original_record?: InputMaybe<Scalars['String']>;
  preferences?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "profile" */
export type Profile_Inc_Input = {
  go1Id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "profile" */
export type Profile_Insert_Input = {
  addresses?: InputMaybe<Scalars['jsonb']>;
  attributes?: InputMaybe<Scalars['jsonb']>;
  avatar?: InputMaybe<Scalars['String']>;
  certificates?: InputMaybe<Course_Certificate_Arr_Rel_Insert_Input>;
  contactDetails?: InputMaybe<Scalars['jsonb']>;
  course_trainer?: InputMaybe<Course_Trainer_Arr_Rel_Insert_Input>;
  courses?: InputMaybe<Course_Participant_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  dbs?: InputMaybe<Scalars['String']>;
  dietaryRestrictions?: InputMaybe<Scalars['String']>;
  disabilities?: InputMaybe<Scalars['String']>;
  dob?: InputMaybe<Scalars['date']>;
  email?: InputMaybe<Scalars['String']>;
  familyName?: InputMaybe<Scalars['String']>;
  givenName?: InputMaybe<Scalars['String']>;
  go1Id?: InputMaybe<Scalars['Int']>;
  go1Licenses?: InputMaybe<Go1_Licenses_Arr_Rel_Insert_Input>;
  go1_profile?: InputMaybe<Scalars['jsonb']>;
  id?: InputMaybe<Scalars['uuid']>;
  identities?: InputMaybe<Identity_Arr_Rel_Insert_Input>;
  jobTitle?: InputMaybe<Scalars['String']>;
  lastActivity?: InputMaybe<Scalars['timestamptz']>;
  organizations?: InputMaybe<Organization_Member_Arr_Rel_Insert_Input>;
  original_record?: InputMaybe<Scalars['jsonb']>;
  participant_audits?: InputMaybe<Course_Participant_Audit_Arr_Rel_Insert_Input>;
  phone?: InputMaybe<Scalars['String']>;
  preferences?: InputMaybe<Scalars['jsonb']>;
  roles?: InputMaybe<Profile_Role_Arr_Rel_Insert_Input>;
  stripe_customer_id?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['jsonb']>;
  title?: InputMaybe<Scalars['String']>;
  trainer_role_types?: InputMaybe<Profile_Trainer_Role_Type_Arr_Rel_Insert_Input>;
  upcomingEnrollments?: InputMaybe<Upcoming_Enrollments_Arr_Rel_Insert_Input>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Profile_Max_Fields = {
  __typename?: 'profile_max_fields';
  avatar?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  dbs?: Maybe<Scalars['String']>;
  dietaryRestrictions?: Maybe<Scalars['String']>;
  disabilities?: Maybe<Scalars['String']>;
  dob?: Maybe<Scalars['date']>;
  email?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  givenName?: Maybe<Scalars['String']>;
  go1Id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  jobTitle?: Maybe<Scalars['String']>;
  lastActivity?: Maybe<Scalars['timestamptz']>;
  phone?: Maybe<Scalars['String']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Profile_Min_Fields = {
  __typename?: 'profile_min_fields';
  avatar?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  dbs?: Maybe<Scalars['String']>;
  dietaryRestrictions?: Maybe<Scalars['String']>;
  disabilities?: Maybe<Scalars['String']>;
  dob?: Maybe<Scalars['date']>;
  email?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  givenName?: Maybe<Scalars['String']>;
  go1Id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  jobTitle?: Maybe<Scalars['String']>;
  lastActivity?: Maybe<Scalars['timestamptz']>;
  phone?: Maybe<Scalars['String']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "profile" */
export type Profile_Mutation_Response = {
  __typename?: 'profile_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Profile>;
};

/** input type for inserting object relation for remote table "profile" */
export type Profile_Obj_Rel_Insert_Input = {
  data: Profile_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Profile_On_Conflict>;
};

/** on_conflict condition type for table "profile" */
export type Profile_On_Conflict = {
  constraint: Profile_Constraint;
  update_columns?: Array<Profile_Update_Column>;
  where?: InputMaybe<Profile_Bool_Exp>;
};

/** Ordering options when selecting data from "profile". */
export type Profile_Order_By = {
  addresses?: InputMaybe<Order_By>;
  attributes?: InputMaybe<Order_By>;
  avatar?: InputMaybe<Order_By>;
  certificates_aggregate?: InputMaybe<Course_Certificate_Aggregate_Order_By>;
  contactDetails?: InputMaybe<Order_By>;
  course_trainer_aggregate?: InputMaybe<Course_Trainer_Aggregate_Order_By>;
  courses_aggregate?: InputMaybe<Course_Participant_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  dbs?: InputMaybe<Order_By>;
  dietaryRestrictions?: InputMaybe<Order_By>;
  disabilities?: InputMaybe<Order_By>;
  dob?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  familyName?: InputMaybe<Order_By>;
  fullName?: InputMaybe<Order_By>;
  givenName?: InputMaybe<Order_By>;
  go1Id?: InputMaybe<Order_By>;
  go1Licenses_aggregate?: InputMaybe<Go1_Licenses_Aggregate_Order_By>;
  go1_profile?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  identities_aggregate?: InputMaybe<Identity_Aggregate_Order_By>;
  jobTitle?: InputMaybe<Order_By>;
  lastActivity?: InputMaybe<Order_By>;
  organizations_aggregate?: InputMaybe<Organization_Member_Aggregate_Order_By>;
  original_record?: InputMaybe<Order_By>;
  participant_audits_aggregate?: InputMaybe<Course_Participant_Audit_Aggregate_Order_By>;
  phone?: InputMaybe<Order_By>;
  preferences?: InputMaybe<Order_By>;
  roles_aggregate?: InputMaybe<Profile_Role_Aggregate_Order_By>;
  stripe_customer_id?: InputMaybe<Order_By>;
  tags?: InputMaybe<Order_By>;
  title?: InputMaybe<Order_By>;
  trainer_role_types_aggregate?: InputMaybe<Profile_Trainer_Role_Type_Aggregate_Order_By>;
  upcomingEnrollments_aggregate?: InputMaybe<Upcoming_Enrollments_Aggregate_Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: profile */
export type Profile_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Profile_Prepend_Input = {
  addresses?: InputMaybe<Scalars['jsonb']>;
  attributes?: InputMaybe<Scalars['jsonb']>;
  contactDetails?: InputMaybe<Scalars['jsonb']>;
  go1_profile?: InputMaybe<Scalars['jsonb']>;
  original_record?: InputMaybe<Scalars['jsonb']>;
  preferences?: InputMaybe<Scalars['jsonb']>;
  tags?: InputMaybe<Scalars['jsonb']>;
};

/** columns and relationships of "profile_role" */
export type Profile_Role = {
  __typename?: 'profile_role';
  _source?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  profile: Profile;
  profile_id: Scalars['uuid'];
  /** An object relationship */
  role: Role;
  role_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "profile_role" */
export type Profile_Role_Aggregate = {
  __typename?: 'profile_role_aggregate';
  aggregate?: Maybe<Profile_Role_Aggregate_Fields>;
  nodes: Array<Profile_Role>;
};

/** aggregate fields of "profile_role" */
export type Profile_Role_Aggregate_Fields = {
  __typename?: 'profile_role_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Profile_Role_Max_Fields>;
  min?: Maybe<Profile_Role_Min_Fields>;
};


/** aggregate fields of "profile_role" */
export type Profile_Role_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Profile_Role_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "profile_role" */
export type Profile_Role_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Profile_Role_Max_Order_By>;
  min?: InputMaybe<Profile_Role_Min_Order_By>;
};

/** input type for inserting array relation for remote table "profile_role" */
export type Profile_Role_Arr_Rel_Insert_Input = {
  data: Array<Profile_Role_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Profile_Role_On_Conflict>;
};

/** Boolean expression to filter rows from the table "profile_role". All fields are combined with a logical 'AND'. */
export type Profile_Role_Bool_Exp = {
  _and?: InputMaybe<Array<Profile_Role_Bool_Exp>>;
  _not?: InputMaybe<Profile_Role_Bool_Exp>;
  _or?: InputMaybe<Array<Profile_Role_Bool_Exp>>;
  _source?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profile_id?: InputMaybe<Uuid_Comparison_Exp>;
  role?: InputMaybe<Role_Bool_Exp>;
  role_id?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "profile_role" */
export enum Profile_Role_Constraint {
  /** unique or primary key constraint */
  ProfileRolePkey = 'profile_role_pkey',
  /** unique or primary key constraint */
  ProfileRoleProfileIdRoleIdKey = 'profile_role_profile_id_role_id_key'
}

/** input type for inserting data into table "profile_role" */
export type Profile_Role_Insert_Input = {
  _source?: InputMaybe<Scalars['String']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  role?: InputMaybe<Role_Obj_Rel_Insert_Input>;
  role_id?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Profile_Role_Max_Fields = {
  __typename?: 'profile_role_max_fields';
  _source?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
  role_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "profile_role" */
export type Profile_Role_Max_Order_By = {
  _source?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Profile_Role_Min_Fields = {
  __typename?: 'profile_role_min_fields';
  _source?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
  role_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "profile_role" */
export type Profile_Role_Min_Order_By = {
  _source?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  role_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "profile_role" */
export type Profile_Role_Mutation_Response = {
  __typename?: 'profile_role_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Profile_Role>;
};

/** on_conflict condition type for table "profile_role" */
export type Profile_Role_On_Conflict = {
  constraint: Profile_Role_Constraint;
  update_columns?: Array<Profile_Role_Update_Column>;
  where?: InputMaybe<Profile_Role_Bool_Exp>;
};

/** Ordering options when selecting data from "profile_role". */
export type Profile_Role_Order_By = {
  _source?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profile_id?: InputMaybe<Order_By>;
  role?: InputMaybe<Role_Order_By>;
  role_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: profile_role */
export type Profile_Role_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "profile_role" */
export enum Profile_Role_Select_Column {
  /** column name */
  Source = '_source',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  RoleId = 'role_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "profile_role" */
export type Profile_Role_Set_Input = {
  _source?: InputMaybe<Scalars['String']>;
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  role_id?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "profile_role" */
export enum Profile_Role_Update_Column {
  /** column name */
  Source = '_source',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  RoleId = 'role_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** select columns of table "profile" */
export enum Profile_Select_Column {
  /** column name */
  Addresses = 'addresses',
  /** column name */
  Attributes = 'attributes',
  /** column name */
  Avatar = 'avatar',
  /** column name */
  ContactDetails = 'contactDetails',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Dbs = 'dbs',
  /** column name */
  DietaryRestrictions = 'dietaryRestrictions',
  /** column name */
  Disabilities = 'disabilities',
  /** column name */
  Dob = 'dob',
  /** column name */
  Email = 'email',
  /** column name */
  FamilyName = 'familyName',
  /** column name */
  GivenName = 'givenName',
  /** column name */
  Go1Id = 'go1Id',
  /** column name */
  Go1Profile = 'go1_profile',
  /** column name */
  Id = 'id',
  /** column name */
  JobTitle = 'jobTitle',
  /** column name */
  LastActivity = 'lastActivity',
  /** column name */
  OriginalRecord = 'original_record',
  /** column name */
  Phone = 'phone',
  /** column name */
  Preferences = 'preferences',
  /** column name */
  StripeCustomerId = 'stripe_customer_id',
  /** column name */
  Tags = 'tags',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "profile" */
export type Profile_Set_Input = {
  addresses?: InputMaybe<Scalars['jsonb']>;
  attributes?: InputMaybe<Scalars['jsonb']>;
  avatar?: InputMaybe<Scalars['String']>;
  contactDetails?: InputMaybe<Scalars['jsonb']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  dbs?: InputMaybe<Scalars['String']>;
  dietaryRestrictions?: InputMaybe<Scalars['String']>;
  disabilities?: InputMaybe<Scalars['String']>;
  dob?: InputMaybe<Scalars['date']>;
  email?: InputMaybe<Scalars['String']>;
  familyName?: InputMaybe<Scalars['String']>;
  givenName?: InputMaybe<Scalars['String']>;
  go1Id?: InputMaybe<Scalars['Int']>;
  go1_profile?: InputMaybe<Scalars['jsonb']>;
  id?: InputMaybe<Scalars['uuid']>;
  jobTitle?: InputMaybe<Scalars['String']>;
  lastActivity?: InputMaybe<Scalars['timestamptz']>;
  original_record?: InputMaybe<Scalars['jsonb']>;
  phone?: InputMaybe<Scalars['String']>;
  preferences?: InputMaybe<Scalars['jsonb']>;
  stripe_customer_id?: InputMaybe<Scalars['String']>;
  tags?: InputMaybe<Scalars['jsonb']>;
  title?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Profile_Stddev_Fields = {
  __typename?: 'profile_stddev_fields';
  go1Id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Profile_Stddev_Pop_Fields = {
  __typename?: 'profile_stddev_pop_fields';
  go1Id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Profile_Stddev_Samp_Fields = {
  __typename?: 'profile_stddev_samp_fields';
  go1Id?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Profile_Sum_Fields = {
  __typename?: 'profile_sum_fields';
  go1Id?: Maybe<Scalars['Int']>;
};

/** Contains partial temporary profiles until account in cognito is confirmed */
export type Profile_Temp = {
  __typename?: 'profile_temp';
  acceptMarketing: Scalars['Boolean'];
  acceptTnc: Scalars['Boolean'];
  /** An object relationship */
  course?: Maybe<Course>;
  courseId?: Maybe<Scalars['Int']>;
  createdAt: Scalars['timestamptz'];
  dob?: Maybe<Scalars['date']>;
  email: Scalars['String'];
  familyName: Scalars['String'];
  givenName: Scalars['String'];
  id: Scalars['Int'];
  jobTitle?: Maybe<Scalars['String']>;
  organizationId?: Maybe<Scalars['uuid']>;
  phone?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  sector?: Maybe<Scalars['String']>;
};

/** aggregated selection of "profile_temp" */
export type Profile_Temp_Aggregate = {
  __typename?: 'profile_temp_aggregate';
  aggregate?: Maybe<Profile_Temp_Aggregate_Fields>;
  nodes: Array<Profile_Temp>;
};

/** aggregate fields of "profile_temp" */
export type Profile_Temp_Aggregate_Fields = {
  __typename?: 'profile_temp_aggregate_fields';
  avg?: Maybe<Profile_Temp_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Profile_Temp_Max_Fields>;
  min?: Maybe<Profile_Temp_Min_Fields>;
  stddev?: Maybe<Profile_Temp_Stddev_Fields>;
  stddev_pop?: Maybe<Profile_Temp_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Profile_Temp_Stddev_Samp_Fields>;
  sum?: Maybe<Profile_Temp_Sum_Fields>;
  var_pop?: Maybe<Profile_Temp_Var_Pop_Fields>;
  var_samp?: Maybe<Profile_Temp_Var_Samp_Fields>;
  variance?: Maybe<Profile_Temp_Variance_Fields>;
};


/** aggregate fields of "profile_temp" */
export type Profile_Temp_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Profile_Temp_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Profile_Temp_Avg_Fields = {
  __typename?: 'profile_temp_avg_fields';
  courseId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "profile_temp". All fields are combined with a logical 'AND'. */
export type Profile_Temp_Bool_Exp = {
  _and?: InputMaybe<Array<Profile_Temp_Bool_Exp>>;
  _not?: InputMaybe<Profile_Temp_Bool_Exp>;
  _or?: InputMaybe<Array<Profile_Temp_Bool_Exp>>;
  acceptMarketing?: InputMaybe<Boolean_Comparison_Exp>;
  acceptTnc?: InputMaybe<Boolean_Comparison_Exp>;
  course?: InputMaybe<Course_Bool_Exp>;
  courseId?: InputMaybe<Int_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  dob?: InputMaybe<Date_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  familyName?: InputMaybe<String_Comparison_Exp>;
  givenName?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Int_Comparison_Exp>;
  jobTitle?: InputMaybe<String_Comparison_Exp>;
  organizationId?: InputMaybe<Uuid_Comparison_Exp>;
  phone?: InputMaybe<String_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  sector?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "profile_temp" */
export enum Profile_Temp_Constraint {
  /** unique or primary key constraint */
  ProfileTempPkey = 'profile_temp_pkey'
}

/** input type for incrementing numeric columns in table "profile_temp" */
export type Profile_Temp_Inc_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  quantity?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "profile_temp" */
export type Profile_Temp_Insert_Input = {
  acceptMarketing?: InputMaybe<Scalars['Boolean']>;
  acceptTnc?: InputMaybe<Scalars['Boolean']>;
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  courseId?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  dob?: InputMaybe<Scalars['date']>;
  email?: InputMaybe<Scalars['String']>;
  familyName?: InputMaybe<Scalars['String']>;
  givenName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['Int']>;
  jobTitle?: InputMaybe<Scalars['String']>;
  organizationId?: InputMaybe<Scalars['uuid']>;
  phone?: InputMaybe<Scalars['String']>;
  quantity?: InputMaybe<Scalars['Int']>;
  sector?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Profile_Temp_Max_Fields = {
  __typename?: 'profile_temp_max_fields';
  courseId?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  dob?: Maybe<Scalars['date']>;
  email?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  givenName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  jobTitle?: Maybe<Scalars['String']>;
  organizationId?: Maybe<Scalars['uuid']>;
  phone?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  sector?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Profile_Temp_Min_Fields = {
  __typename?: 'profile_temp_min_fields';
  courseId?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  dob?: Maybe<Scalars['date']>;
  email?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  givenName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  jobTitle?: Maybe<Scalars['String']>;
  organizationId?: Maybe<Scalars['uuid']>;
  phone?: Maybe<Scalars['String']>;
  quantity?: Maybe<Scalars['Int']>;
  sector?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "profile_temp" */
export type Profile_Temp_Mutation_Response = {
  __typename?: 'profile_temp_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Profile_Temp>;
};

/** on_conflict condition type for table "profile_temp" */
export type Profile_Temp_On_Conflict = {
  constraint: Profile_Temp_Constraint;
  update_columns?: Array<Profile_Temp_Update_Column>;
  where?: InputMaybe<Profile_Temp_Bool_Exp>;
};

/** Ordering options when selecting data from "profile_temp". */
export type Profile_Temp_Order_By = {
  acceptMarketing?: InputMaybe<Order_By>;
  acceptTnc?: InputMaybe<Order_By>;
  course?: InputMaybe<Course_Order_By>;
  courseId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  dob?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  familyName?: InputMaybe<Order_By>;
  givenName?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  jobTitle?: InputMaybe<Order_By>;
  organizationId?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  sector?: InputMaybe<Order_By>;
};

/** primary key columns input for table: profile_temp */
export type Profile_Temp_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "profile_temp" */
export enum Profile_Temp_Select_Column {
  /** column name */
  AcceptMarketing = 'acceptMarketing',
  /** column name */
  AcceptTnc = 'acceptTnc',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Dob = 'dob',
  /** column name */
  Email = 'email',
  /** column name */
  FamilyName = 'familyName',
  /** column name */
  GivenName = 'givenName',
  /** column name */
  Id = 'id',
  /** column name */
  JobTitle = 'jobTitle',
  /** column name */
  OrganizationId = 'organizationId',
  /** column name */
  Phone = 'phone',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  Sector = 'sector'
}

/** input type for updating data in table "profile_temp" */
export type Profile_Temp_Set_Input = {
  acceptMarketing?: InputMaybe<Scalars['Boolean']>;
  acceptTnc?: InputMaybe<Scalars['Boolean']>;
  courseId?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  dob?: InputMaybe<Scalars['date']>;
  email?: InputMaybe<Scalars['String']>;
  familyName?: InputMaybe<Scalars['String']>;
  givenName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['Int']>;
  jobTitle?: InputMaybe<Scalars['String']>;
  organizationId?: InputMaybe<Scalars['uuid']>;
  phone?: InputMaybe<Scalars['String']>;
  quantity?: InputMaybe<Scalars['Int']>;
  sector?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Profile_Temp_Stddev_Fields = {
  __typename?: 'profile_temp_stddev_fields';
  courseId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Profile_Temp_Stddev_Pop_Fields = {
  __typename?: 'profile_temp_stddev_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Profile_Temp_Stddev_Samp_Fields = {
  __typename?: 'profile_temp_stddev_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Profile_Temp_Sum_Fields = {
  __typename?: 'profile_temp_sum_fields';
  courseId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  quantity?: Maybe<Scalars['Int']>;
};

/** update columns of table "profile_temp" */
export enum Profile_Temp_Update_Column {
  /** column name */
  AcceptMarketing = 'acceptMarketing',
  /** column name */
  AcceptTnc = 'acceptTnc',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Dob = 'dob',
  /** column name */
  Email = 'email',
  /** column name */
  FamilyName = 'familyName',
  /** column name */
  GivenName = 'givenName',
  /** column name */
  Id = 'id',
  /** column name */
  JobTitle = 'jobTitle',
  /** column name */
  OrganizationId = 'organizationId',
  /** column name */
  Phone = 'phone',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  Sector = 'sector'
}

/** aggregate var_pop on columns */
export type Profile_Temp_Var_Pop_Fields = {
  __typename?: 'profile_temp_var_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Profile_Temp_Var_Samp_Fields = {
  __typename?: 'profile_temp_var_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Profile_Temp_Variance_Fields = {
  __typename?: 'profile_temp_variance_fields';
  courseId?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "profile_trainer_role_type" */
export type Profile_Trainer_Role_Type = {
  __typename?: 'profile_trainer_role_type';
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  profile_id: Scalars['uuid'];
  /** An object relationship */
  trainer_role_type: Trainer_Role_Type;
  trainer_role_type_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "profile_trainer_role_type" */
export type Profile_Trainer_Role_Type_Aggregate = {
  __typename?: 'profile_trainer_role_type_aggregate';
  aggregate?: Maybe<Profile_Trainer_Role_Type_Aggregate_Fields>;
  nodes: Array<Profile_Trainer_Role_Type>;
};

/** aggregate fields of "profile_trainer_role_type" */
export type Profile_Trainer_Role_Type_Aggregate_Fields = {
  __typename?: 'profile_trainer_role_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Profile_Trainer_Role_Type_Max_Fields>;
  min?: Maybe<Profile_Trainer_Role_Type_Min_Fields>;
};


/** aggregate fields of "profile_trainer_role_type" */
export type Profile_Trainer_Role_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Profile_Trainer_Role_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "profile_trainer_role_type" */
export type Profile_Trainer_Role_Type_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Profile_Trainer_Role_Type_Max_Order_By>;
  min?: InputMaybe<Profile_Trainer_Role_Type_Min_Order_By>;
};

/** input type for inserting array relation for remote table "profile_trainer_role_type" */
export type Profile_Trainer_Role_Type_Arr_Rel_Insert_Input = {
  data: Array<Profile_Trainer_Role_Type_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Profile_Trainer_Role_Type_On_Conflict>;
};

/** Boolean expression to filter rows from the table "profile_trainer_role_type". All fields are combined with a logical 'AND'. */
export type Profile_Trainer_Role_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Profile_Trainer_Role_Type_Bool_Exp>>;
  _not?: InputMaybe<Profile_Trainer_Role_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Profile_Trainer_Role_Type_Bool_Exp>>;
  created_at?: InputMaybe<Timestamptz_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  profile_id?: InputMaybe<Uuid_Comparison_Exp>;
  trainer_role_type?: InputMaybe<Trainer_Role_Type_Bool_Exp>;
  trainer_role_type_id?: InputMaybe<Uuid_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "profile_trainer_role_type" */
export enum Profile_Trainer_Role_Type_Constraint {
  /** unique or primary key constraint */
  ProfileTrainerRoleTypePkey = 'profile_trainer_role_type_pkey'
}

/** input type for inserting data into table "profile_trainer_role_type" */
export type Profile_Trainer_Role_Type_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  trainer_role_type?: InputMaybe<Trainer_Role_Type_Obj_Rel_Insert_Input>;
  trainer_role_type_id?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Profile_Trainer_Role_Type_Max_Fields = {
  __typename?: 'profile_trainer_role_type_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
  trainer_role_type_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "profile_trainer_role_type" */
export type Profile_Trainer_Role_Type_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  trainer_role_type_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Profile_Trainer_Role_Type_Min_Fields = {
  __typename?: 'profile_trainer_role_type_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  profile_id?: Maybe<Scalars['uuid']>;
  trainer_role_type_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "profile_trainer_role_type" */
export type Profile_Trainer_Role_Type_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  trainer_role_type_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "profile_trainer_role_type" */
export type Profile_Trainer_Role_Type_Mutation_Response = {
  __typename?: 'profile_trainer_role_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Profile_Trainer_Role_Type>;
};

/** on_conflict condition type for table "profile_trainer_role_type" */
export type Profile_Trainer_Role_Type_On_Conflict = {
  constraint: Profile_Trainer_Role_Type_Constraint;
  update_columns?: Array<Profile_Trainer_Role_Type_Update_Column>;
  where?: InputMaybe<Profile_Trainer_Role_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "profile_trainer_role_type". */
export type Profile_Trainer_Role_Type_Order_By = {
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  profile_id?: InputMaybe<Order_By>;
  trainer_role_type?: InputMaybe<Trainer_Role_Type_Order_By>;
  trainer_role_type_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: profile_trainer_role_type */
export type Profile_Trainer_Role_Type_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "profile_trainer_role_type" */
export enum Profile_Trainer_Role_Type_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  TrainerRoleTypeId = 'trainer_role_type_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "profile_trainer_role_type" */
export type Profile_Trainer_Role_Type_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamptz']>;
  id?: InputMaybe<Scalars['uuid']>;
  profile_id?: InputMaybe<Scalars['uuid']>;
  trainer_role_type_id?: InputMaybe<Scalars['uuid']>;
  updated_at?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "profile_trainer_role_type" */
export enum Profile_Trainer_Role_Type_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProfileId = 'profile_id',
  /** column name */
  TrainerRoleTypeId = 'trainer_role_type_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** update columns of table "profile" */
export enum Profile_Update_Column {
  /** column name */
  Addresses = 'addresses',
  /** column name */
  Attributes = 'attributes',
  /** column name */
  Avatar = 'avatar',
  /** column name */
  ContactDetails = 'contactDetails',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Dbs = 'dbs',
  /** column name */
  DietaryRestrictions = 'dietaryRestrictions',
  /** column name */
  Disabilities = 'disabilities',
  /** column name */
  Dob = 'dob',
  /** column name */
  Email = 'email',
  /** column name */
  FamilyName = 'familyName',
  /** column name */
  GivenName = 'givenName',
  /** column name */
  Go1Id = 'go1Id',
  /** column name */
  Go1Profile = 'go1_profile',
  /** column name */
  Id = 'id',
  /** column name */
  JobTitle = 'jobTitle',
  /** column name */
  LastActivity = 'lastActivity',
  /** column name */
  OriginalRecord = 'original_record',
  /** column name */
  Phone = 'phone',
  /** column name */
  Preferences = 'preferences',
  /** column name */
  StripeCustomerId = 'stripe_customer_id',
  /** column name */
  Tags = 'tags',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Profile_Var_Pop_Fields = {
  __typename?: 'profile_var_pop_fields';
  go1Id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Profile_Var_Samp_Fields = {
  __typename?: 'profile_var_samp_fields';
  go1Id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Profile_Variance_Fields = {
  __typename?: 'profile_variance_fields';
  go1Id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "promo_code" */
export type Promo_Code = {
  __typename?: 'promo_code';
  amount: Scalars['numeric'];
  approvedBy?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  approver?: Maybe<Profile>;
  bookerSingleUse: Scalars['Boolean'];
  code: Scalars['String'];
  /** An array relationship */
  courses: Array<Course_Promo_Code>;
  /** An aggregate relationship */
  courses_aggregate: Course_Promo_Code_Aggregate;
  createdAt: Scalars['timestamptz'];
  createdBy: Scalars['uuid'];
  /** An object relationship */
  creator: Profile;
  deniedBy?: Maybe<Scalars['uuid']>;
  description?: Maybe<Scalars['String']>;
  enabled: Scalars['Boolean'];
  id: Scalars['uuid'];
  levels: Scalars['jsonb'];
  type: Promo_Code_Type_Enum;
  updatedAt: Scalars['timestamptz'];
  usesMax?: Maybe<Scalars['numeric']>;
  validFrom: Scalars['timestamptz'];
  validTo?: Maybe<Scalars['timestamptz']>;
};


/** columns and relationships of "promo_code" */
export type Promo_CodeCoursesArgs = {
  distinct_on?: InputMaybe<Array<Course_Promo_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Promo_Code_Order_By>>;
  where?: InputMaybe<Course_Promo_Code_Bool_Exp>;
};


/** columns and relationships of "promo_code" */
export type Promo_CodeCourses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Promo_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Promo_Code_Order_By>>;
  where?: InputMaybe<Course_Promo_Code_Bool_Exp>;
};


/** columns and relationships of "promo_code" */
export type Promo_CodeLevelsArgs = {
  path?: InputMaybe<Scalars['String']>;
};

/** aggregated selection of "promo_code" */
export type Promo_Code_Aggregate = {
  __typename?: 'promo_code_aggregate';
  aggregate?: Maybe<Promo_Code_Aggregate_Fields>;
  nodes: Array<Promo_Code>;
};

/** aggregate fields of "promo_code" */
export type Promo_Code_Aggregate_Fields = {
  __typename?: 'promo_code_aggregate_fields';
  avg?: Maybe<Promo_Code_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Promo_Code_Max_Fields>;
  min?: Maybe<Promo_Code_Min_Fields>;
  stddev?: Maybe<Promo_Code_Stddev_Fields>;
  stddev_pop?: Maybe<Promo_Code_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Promo_Code_Stddev_Samp_Fields>;
  sum?: Maybe<Promo_Code_Sum_Fields>;
  var_pop?: Maybe<Promo_Code_Var_Pop_Fields>;
  var_samp?: Maybe<Promo_Code_Var_Samp_Fields>;
  variance?: Maybe<Promo_Code_Variance_Fields>;
};


/** aggregate fields of "promo_code" */
export type Promo_Code_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Promo_Code_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Promo_Code_Append_Input = {
  levels?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Promo_Code_Avg_Fields = {
  __typename?: 'promo_code_avg_fields';
  amount?: Maybe<Scalars['Float']>;
  usesMax?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "promo_code". All fields are combined with a logical 'AND'. */
export type Promo_Code_Bool_Exp = {
  _and?: InputMaybe<Array<Promo_Code_Bool_Exp>>;
  _not?: InputMaybe<Promo_Code_Bool_Exp>;
  _or?: InputMaybe<Array<Promo_Code_Bool_Exp>>;
  amount?: InputMaybe<Numeric_Comparison_Exp>;
  approvedBy?: InputMaybe<Uuid_Comparison_Exp>;
  approver?: InputMaybe<Profile_Bool_Exp>;
  bookerSingleUse?: InputMaybe<Boolean_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  courses?: InputMaybe<Course_Promo_Code_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  creator?: InputMaybe<Profile_Bool_Exp>;
  deniedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  enabled?: InputMaybe<Boolean_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  levels?: InputMaybe<Jsonb_Comparison_Exp>;
  type?: InputMaybe<Promo_Code_Type_Enum_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  usesMax?: InputMaybe<Numeric_Comparison_Exp>;
  validFrom?: InputMaybe<Timestamptz_Comparison_Exp>;
  validTo?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "promo_code" */
export enum Promo_Code_Constraint {
  /** unique or primary key constraint */
  PromoCodeCodeKey = 'promo_code_code_key',
  /** unique or primary key constraint */
  PromoCodePkey = 'promo_code_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Promo_Code_Delete_At_Path_Input = {
  levels?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Promo_Code_Delete_Elem_Input = {
  levels?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Promo_Code_Delete_Key_Input = {
  levels?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "promo_code" */
export type Promo_Code_Inc_Input = {
  amount?: InputMaybe<Scalars['numeric']>;
  usesMax?: InputMaybe<Scalars['numeric']>;
};

/** input type for inserting data into table "promo_code" */
export type Promo_Code_Insert_Input = {
  amount?: InputMaybe<Scalars['numeric']>;
  approvedBy?: InputMaybe<Scalars['uuid']>;
  approver?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  bookerSingleUse?: InputMaybe<Scalars['Boolean']>;
  code?: InputMaybe<Scalars['String']>;
  courses?: InputMaybe<Course_Promo_Code_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  createdBy?: InputMaybe<Scalars['uuid']>;
  creator?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  deniedBy?: InputMaybe<Scalars['uuid']>;
  description?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  levels?: InputMaybe<Scalars['jsonb']>;
  type?: InputMaybe<Promo_Code_Type_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  usesMax?: InputMaybe<Scalars['numeric']>;
  validFrom?: InputMaybe<Scalars['timestamptz']>;
  validTo?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Promo_Code_Max_Fields = {
  __typename?: 'promo_code_max_fields';
  amount?: Maybe<Scalars['numeric']>;
  approvedBy?: Maybe<Scalars['uuid']>;
  code?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  createdBy?: Maybe<Scalars['uuid']>;
  deniedBy?: Maybe<Scalars['uuid']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  usesMax?: Maybe<Scalars['numeric']>;
  validFrom?: Maybe<Scalars['timestamptz']>;
  validTo?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Promo_Code_Min_Fields = {
  __typename?: 'promo_code_min_fields';
  amount?: Maybe<Scalars['numeric']>;
  approvedBy?: Maybe<Scalars['uuid']>;
  code?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  createdBy?: Maybe<Scalars['uuid']>;
  deniedBy?: Maybe<Scalars['uuid']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
  usesMax?: Maybe<Scalars['numeric']>;
  validFrom?: Maybe<Scalars['timestamptz']>;
  validTo?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "promo_code" */
export type Promo_Code_Mutation_Response = {
  __typename?: 'promo_code_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Promo_Code>;
};

/** input type for inserting object relation for remote table "promo_code" */
export type Promo_Code_Obj_Rel_Insert_Input = {
  data: Promo_Code_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Promo_Code_On_Conflict>;
};

/** on_conflict condition type for table "promo_code" */
export type Promo_Code_On_Conflict = {
  constraint: Promo_Code_Constraint;
  update_columns?: Array<Promo_Code_Update_Column>;
  where?: InputMaybe<Promo_Code_Bool_Exp>;
};

/** Ordering options when selecting data from "promo_code". */
export type Promo_Code_Order_By = {
  amount?: InputMaybe<Order_By>;
  approvedBy?: InputMaybe<Order_By>;
  approver?: InputMaybe<Profile_Order_By>;
  bookerSingleUse?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  courses_aggregate?: InputMaybe<Course_Promo_Code_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  creator?: InputMaybe<Profile_Order_By>;
  deniedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  enabled?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  levels?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  usesMax?: InputMaybe<Order_By>;
  validFrom?: InputMaybe<Order_By>;
  validTo?: InputMaybe<Order_By>;
};

/** primary key columns input for table: promo_code */
export type Promo_Code_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Promo_Code_Prepend_Input = {
  levels?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "promo_code" */
export enum Promo_Code_Select_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  ApprovedBy = 'approvedBy',
  /** column name */
  BookerSingleUse = 'bookerSingleUse',
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeniedBy = 'deniedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Id = 'id',
  /** column name */
  Levels = 'levels',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsesMax = 'usesMax',
  /** column name */
  ValidFrom = 'validFrom',
  /** column name */
  ValidTo = 'validTo'
}

/** input type for updating data in table "promo_code" */
export type Promo_Code_Set_Input = {
  amount?: InputMaybe<Scalars['numeric']>;
  approvedBy?: InputMaybe<Scalars['uuid']>;
  bookerSingleUse?: InputMaybe<Scalars['Boolean']>;
  code?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  createdBy?: InputMaybe<Scalars['uuid']>;
  deniedBy?: InputMaybe<Scalars['uuid']>;
  description?: InputMaybe<Scalars['String']>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  id?: InputMaybe<Scalars['uuid']>;
  levels?: InputMaybe<Scalars['jsonb']>;
  type?: InputMaybe<Promo_Code_Type_Enum>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
  usesMax?: InputMaybe<Scalars['numeric']>;
  validFrom?: InputMaybe<Scalars['timestamptz']>;
  validTo?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Promo_Code_Stddev_Fields = {
  __typename?: 'promo_code_stddev_fields';
  amount?: Maybe<Scalars['Float']>;
  usesMax?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Promo_Code_Stddev_Pop_Fields = {
  __typename?: 'promo_code_stddev_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  usesMax?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Promo_Code_Stddev_Samp_Fields = {
  __typename?: 'promo_code_stddev_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  usesMax?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Promo_Code_Sum_Fields = {
  __typename?: 'promo_code_sum_fields';
  amount?: Maybe<Scalars['numeric']>;
  usesMax?: Maybe<Scalars['numeric']>;
};

/** columns and relationships of "promo_code_type" */
export type Promo_Code_Type = {
  __typename?: 'promo_code_type';
  name: Scalars['String'];
};

/** aggregated selection of "promo_code_type" */
export type Promo_Code_Type_Aggregate = {
  __typename?: 'promo_code_type_aggregate';
  aggregate?: Maybe<Promo_Code_Type_Aggregate_Fields>;
  nodes: Array<Promo_Code_Type>;
};

/** aggregate fields of "promo_code_type" */
export type Promo_Code_Type_Aggregate_Fields = {
  __typename?: 'promo_code_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Promo_Code_Type_Max_Fields>;
  min?: Maybe<Promo_Code_Type_Min_Fields>;
};


/** aggregate fields of "promo_code_type" */
export type Promo_Code_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Promo_Code_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "promo_code_type". All fields are combined with a logical 'AND'. */
export type Promo_Code_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Promo_Code_Type_Bool_Exp>>;
  _not?: InputMaybe<Promo_Code_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Promo_Code_Type_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "promo_code_type" */
export enum Promo_Code_Type_Constraint {
  /** unique or primary key constraint */
  PromoCodeTypePkey = 'promo_code_type_pkey'
}

export enum Promo_Code_Type_Enum {
  FreePlaces = 'FREE_PLACES',
  Percent = 'PERCENT'
}

/** Boolean expression to compare columns of type "promo_code_type_enum". All fields are combined with logical 'AND'. */
export type Promo_Code_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Promo_Code_Type_Enum>;
  _in?: InputMaybe<Array<Promo_Code_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Promo_Code_Type_Enum>;
  _nin?: InputMaybe<Array<Promo_Code_Type_Enum>>;
};

/** input type for inserting data into table "promo_code_type" */
export type Promo_Code_Type_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Promo_Code_Type_Max_Fields = {
  __typename?: 'promo_code_type_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Promo_Code_Type_Min_Fields = {
  __typename?: 'promo_code_type_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "promo_code_type" */
export type Promo_Code_Type_Mutation_Response = {
  __typename?: 'promo_code_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Promo_Code_Type>;
};

/** on_conflict condition type for table "promo_code_type" */
export type Promo_Code_Type_On_Conflict = {
  constraint: Promo_Code_Type_Constraint;
  update_columns?: Array<Promo_Code_Type_Update_Column>;
  where?: InputMaybe<Promo_Code_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "promo_code_type". */
export type Promo_Code_Type_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: promo_code_type */
export type Promo_Code_Type_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "promo_code_type" */
export enum Promo_Code_Type_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "promo_code_type" */
export type Promo_Code_Type_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "promo_code_type" */
export enum Promo_Code_Type_Update_Column {
  /** column name */
  Name = 'name'
}

/** update columns of table "promo_code" */
export enum Promo_Code_Update_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  ApprovedBy = 'approvedBy',
  /** column name */
  BookerSingleUse = 'bookerSingleUse',
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeniedBy = 'deniedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Id = 'id',
  /** column name */
  Levels = 'levels',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsesMax = 'usesMax',
  /** column name */
  ValidFrom = 'validFrom',
  /** column name */
  ValidTo = 'validTo'
}

/** aggregate var_pop on columns */
export type Promo_Code_Var_Pop_Fields = {
  __typename?: 'promo_code_var_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  usesMax?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Promo_Code_Var_Samp_Fields = {
  __typename?: 'promo_code_var_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  usesMax?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Promo_Code_Variance_Fields = {
  __typename?: 'promo_code_variance_fields';
  amount?: Maybe<Scalars['Float']>;
  usesMax?: Maybe<Scalars['Float']>;
};

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "availability" */
  availability: Array<Availability>;
  /** fetch aggregated fields from the table: "availability" */
  availability_aggregate: Availability_Aggregate;
  /** fetch data from the table: "availability" using primary key columns */
  availability_by_pk?: Maybe<Availability>;
  /** fetch data from the table: "blended_learning_status" */
  blended_learning_status: Array<Blended_Learning_Status>;
  /** fetch aggregated fields from the table: "blended_learning_status" */
  blended_learning_status_aggregate: Blended_Learning_Status_Aggregate;
  /** fetch data from the table: "blended_learning_status" using primary key columns */
  blended_learning_status_by_pk?: Maybe<Blended_Learning_Status>;
  /** Checks whether a promo code can be applied to a given course by the current user */
  canApplyPromoCode: CanApplyPromoCodeOutput;
  /** fetch data from the table: "certificate_status" */
  certificate_status: Array<Certificate_Status>;
  /** fetch aggregated fields from the table: "certificate_status" */
  certificate_status_aggregate: Certificate_Status_Aggregate;
  /** fetch data from the table: "certificate_status" using primary key columns */
  certificate_status_by_pk?: Maybe<Certificate_Status>;
  /** fetch data from the table: "color" */
  color: Array<Color>;
  /** fetch aggregated fields from the table: "color" */
  color_aggregate: Color_Aggregate;
  /** fetch data from the table: "color" using primary key columns */
  color_by_pk?: Maybe<Color>;
  content?: Maybe<RootQuery>;
  /** fetch data from the table: "course" */
  course: Array<Course>;
  /** fetch aggregated fields from the table: "course" */
  course_aggregate: Course_Aggregate;
  /** fetch data from the table: "course_audit" */
  course_audit: Array<Course_Audit>;
  /** fetch aggregated fields from the table: "course_audit" */
  course_audit_aggregate: Course_Audit_Aggregate;
  /** fetch data from the table: "course_audit" using primary key columns */
  course_audit_by_pk?: Maybe<Course_Audit>;
  /** fetch data from the table: "course_audit_type" */
  course_audit_type: Array<Course_Audit_Type>;
  /** fetch aggregated fields from the table: "course_audit_type" */
  course_audit_type_aggregate: Course_Audit_Type_Aggregate;
  /** fetch data from the table: "course_audit_type" using primary key columns */
  course_audit_type_by_pk?: Maybe<Course_Audit_Type>;
  /** fetch data from the table: "course" using primary key columns */
  course_by_pk?: Maybe<Course>;
  /** fetch data from the table: "course_cancellation_request" */
  course_cancellation_request: Array<Course_Cancellation_Request>;
  /** fetch aggregated fields from the table: "course_cancellation_request" */
  course_cancellation_request_aggregate: Course_Cancellation_Request_Aggregate;
  /** fetch data from the table: "course_cancellation_request" using primary key columns */
  course_cancellation_request_by_pk?: Maybe<Course_Cancellation_Request>;
  /** fetch data from the table: "course_certificate" */
  course_certificate: Array<Course_Certificate>;
  /** fetch aggregated fields from the table: "course_certificate" */
  course_certificate_aggregate: Course_Certificate_Aggregate;
  /** fetch data from the table: "course_certificate" using primary key columns */
  course_certificate_by_pk?: Maybe<Course_Certificate>;
  /** fetch data from the table: "course_certificate_changelog" */
  course_certificate_changelog: Array<Course_Certificate_Changelog>;
  /** fetch aggregated fields from the table: "course_certificate_changelog" */
  course_certificate_changelog_aggregate: Course_Certificate_Changelog_Aggregate;
  /** fetch data from the table: "course_certificate_changelog" using primary key columns */
  course_certificate_changelog_by_pk?: Maybe<Course_Certificate_Changelog>;
  /** fetch data from the table: "course_delivery_type" */
  course_delivery_type: Array<Course_Delivery_Type>;
  /** fetch aggregated fields from the table: "course_delivery_type" */
  course_delivery_type_aggregate: Course_Delivery_Type_Aggregate;
  /** fetch data from the table: "course_delivery_type" using primary key columns */
  course_delivery_type_by_pk?: Maybe<Course_Delivery_Type>;
  /** fetch data from the table: "course_draft" */
  course_draft: Array<Course_Draft>;
  /** fetch aggregated fields from the table: "course_draft" */
  course_draft_aggregate: Course_Draft_Aggregate;
  /** fetch data from the table: "course_draft" using primary key columns */
  course_draft_by_pk?: Maybe<Course_Draft>;
  /** fetch data from the table: "course_end_jobs" */
  course_end_jobs: Array<Course_End_Jobs>;
  /** fetch aggregated fields from the table: "course_end_jobs" */
  course_end_jobs_aggregate: Course_End_Jobs_Aggregate;
  /** fetch data from the table: "course_end_jobs" using primary key columns */
  course_end_jobs_by_pk?: Maybe<Course_End_Jobs>;
  /** fetch data from the table: "course_enquiry" */
  course_enquiry: Array<Course_Enquiry>;
  /** fetch aggregated fields from the table: "course_enquiry" */
  course_enquiry_aggregate: Course_Enquiry_Aggregate;
  /** fetch data from the table: "course_enquiry" using primary key columns */
  course_enquiry_by_pk?: Maybe<Course_Enquiry>;
  /** fetch data from the table: "course_evaluation_answers" */
  course_evaluation_answers: Array<Course_Evaluation_Answers>;
  /** fetch aggregated fields from the table: "course_evaluation_answers" */
  course_evaluation_answers_aggregate: Course_Evaluation_Answers_Aggregate;
  /** fetch data from the table: "course_evaluation_answers" using primary key columns */
  course_evaluation_answers_by_pk?: Maybe<Course_Evaluation_Answers>;
  /** fetch data from the table: "course_evaluation_question_group" */
  course_evaluation_question_group: Array<Course_Evaluation_Question_Group>;
  /** fetch aggregated fields from the table: "course_evaluation_question_group" */
  course_evaluation_question_group_aggregate: Course_Evaluation_Question_Group_Aggregate;
  /** fetch data from the table: "course_evaluation_question_group" using primary key columns */
  course_evaluation_question_group_by_pk?: Maybe<Course_Evaluation_Question_Group>;
  /** fetch data from the table: "course_evaluation_question_type" */
  course_evaluation_question_type: Array<Course_Evaluation_Question_Type>;
  /** fetch aggregated fields from the table: "course_evaluation_question_type" */
  course_evaluation_question_type_aggregate: Course_Evaluation_Question_Type_Aggregate;
  /** fetch data from the table: "course_evaluation_question_type" using primary key columns */
  course_evaluation_question_type_by_pk?: Maybe<Course_Evaluation_Question_Type>;
  /** fetch data from the table: "course_evaluation_questions" */
  course_evaluation_questions: Array<Course_Evaluation_Questions>;
  /** fetch aggregated fields from the table: "course_evaluation_questions" */
  course_evaluation_questions_aggregate: Course_Evaluation_Questions_Aggregate;
  /** fetch data from the table: "course_evaluation_questions" using primary key columns */
  course_evaluation_questions_by_pk?: Maybe<Course_Evaluation_Questions>;
  /** fetch data from the table: "course_expenses" */
  course_expenses: Array<Course_Expenses>;
  /** fetch aggregated fields from the table: "course_expenses" */
  course_expenses_aggregate: Course_Expenses_Aggregate;
  /** fetch data from the table: "course_expenses" using primary key columns */
  course_expenses_by_pk?: Maybe<Course_Expenses>;
  /** fetch data from the table: "course_invite_status" */
  course_invite_status: Array<Course_Invite_Status>;
  /** fetch aggregated fields from the table: "course_invite_status" */
  course_invite_status_aggregate: Course_Invite_Status_Aggregate;
  /** fetch data from the table: "course_invite_status" using primary key columns */
  course_invite_status_by_pk?: Maybe<Course_Invite_Status>;
  /** fetch data from the table: "course_invites" */
  course_invites: Array<Course_Invites>;
  /** fetch aggregated fields from the table: "course_invites" */
  course_invites_aggregate: Course_Invites_Aggregate;
  /** fetch data from the table: "course_invites" using primary key columns */
  course_invites_by_pk?: Maybe<Course_Invites>;
  /** fetch data from the table: "course_level" */
  course_level: Array<Course_Level>;
  /** fetch aggregated fields from the table: "course_level" */
  course_level_aggregate: Course_Level_Aggregate;
  /** fetch data from the table: "course_level" using primary key columns */
  course_level_by_pk?: Maybe<Course_Level>;
  /** fetch data from the table: "course_level_prefix" */
  course_level_prefix: Array<Course_Level_Prefix>;
  /** fetch aggregated fields from the table: "course_level_prefix" */
  course_level_prefix_aggregate: Course_Level_Prefix_Aggregate;
  /** fetch data from the table: "course_level_prefix" using primary key columns */
  course_level_prefix_by_pk?: Maybe<Course_Level_Prefix>;
  /** fetch data from the table: "course_module" */
  course_module: Array<Course_Module>;
  /** fetch aggregated fields from the table: "course_module" */
  course_module_aggregate: Course_Module_Aggregate;
  /** fetch data from the table: "course_module" using primary key columns */
  course_module_by_pk?: Maybe<Course_Module>;
  /** fetch data from the table: "course_participant" */
  course_participant: Array<Course_Participant>;
  /** fetch aggregated fields from the table: "course_participant" */
  course_participant_aggregate: Course_Participant_Aggregate;
  /** fetch data from the table: "course_participant_audit" */
  course_participant_audit: Array<Course_Participant_Audit>;
  /** fetch aggregated fields from the table: "course_participant_audit" */
  course_participant_audit_aggregate: Course_Participant_Audit_Aggregate;
  /** fetch data from the table: "course_participant_audit" using primary key columns */
  course_participant_audit_by_pk?: Maybe<Course_Participant_Audit>;
  /** fetch data from the table: "course_participant_audit_type" */
  course_participant_audit_type: Array<Course_Participant_Audit_Type>;
  /** fetch aggregated fields from the table: "course_participant_audit_type" */
  course_participant_audit_type_aggregate: Course_Participant_Audit_Type_Aggregate;
  /** fetch data from the table: "course_participant_audit_type" using primary key columns */
  course_participant_audit_type_by_pk?: Maybe<Course_Participant_Audit_Type>;
  /** fetch data from the table: "course_participant" using primary key columns */
  course_participant_by_pk?: Maybe<Course_Participant>;
  /** fetch data from the table: "course_participant_cancellation" */
  course_participant_cancellation: Array<Course_Participant_Cancellation>;
  /** fetch aggregated fields from the table: "course_participant_cancellation" */
  course_participant_cancellation_aggregate: Course_Participant_Cancellation_Aggregate;
  /** fetch data from the table: "course_participant_cancellation" using primary key columns */
  course_participant_cancellation_by_pk?: Maybe<Course_Participant_Cancellation>;
  /** fetch data from the table: "course_participant_module" */
  course_participant_module: Array<Course_Participant_Module>;
  /** fetch aggregated fields from the table: "course_participant_module" */
  course_participant_module_aggregate: Course_Participant_Module_Aggregate;
  /** fetch data from the table: "course_participant_module" using primary key columns */
  course_participant_module_by_pk?: Maybe<Course_Participant_Module>;
  /** fetch data from the table: "course_pricing" */
  course_pricing: Array<Course_Pricing>;
  /** fetch aggregated fields from the table: "course_pricing" */
  course_pricing_aggregate: Course_Pricing_Aggregate;
  /** fetch data from the table: "course_pricing" using primary key columns */
  course_pricing_by_pk?: Maybe<Course_Pricing>;
  /** fetch data from the table: "course_promo_code" */
  course_promo_code: Array<Course_Promo_Code>;
  /** fetch aggregated fields from the table: "course_promo_code" */
  course_promo_code_aggregate: Course_Promo_Code_Aggregate;
  /** fetch data from the table: "course_promo_code" using primary key columns */
  course_promo_code_by_pk?: Maybe<Course_Promo_Code>;
  /** fetch data from the table: "course_schedule" */
  course_schedule: Array<Course_Schedule>;
  /** fetch aggregated fields from the table: "course_schedule" */
  course_schedule_aggregate: Course_Schedule_Aggregate;
  /** fetch data from the table: "course_schedule" using primary key columns */
  course_schedule_by_pk?: Maybe<Course_Schedule>;
  /** fetch data from the table: "course_status" */
  course_status: Array<Course_Status>;
  /** fetch aggregated fields from the table: "course_status" */
  course_status_aggregate: Course_Status_Aggregate;
  /** fetch data from the table: "course_status" using primary key columns */
  course_status_by_pk?: Maybe<Course_Status>;
  /** An array relationship */
  course_trainer: Array<Course_Trainer>;
  /** An aggregate relationship */
  course_trainer_aggregate: Course_Trainer_Aggregate;
  /** fetch data from the table: "course_trainer" using primary key columns */
  course_trainer_by_pk?: Maybe<Course_Trainer>;
  /** fetch data from the table: "course_trainer_type" */
  course_trainer_type: Array<Course_Trainer_Type>;
  /** fetch aggregated fields from the table: "course_trainer_type" */
  course_trainer_type_aggregate: Course_Trainer_Type_Aggregate;
  /** fetch data from the table: "course_trainer_type" using primary key columns */
  course_trainer_type_by_pk?: Maybe<Course_Trainer_Type>;
  /** fetch data from the table: "course_type" */
  course_type: Array<Course_Type>;
  /** fetch aggregated fields from the table: "course_type" */
  course_type_aggregate: Course_Type_Aggregate;
  /** fetch data from the table: "course_type" using primary key columns */
  course_type_by_pk?: Maybe<Course_Type>;
  /** fetch data from the table: "course_type_prefix" */
  course_type_prefix: Array<Course_Type_Prefix>;
  /** fetch aggregated fields from the table: "course_type_prefix" */
  course_type_prefix_aggregate: Course_Type_Prefix_Aggregate;
  /** fetch data from the table: "course_type_prefix" using primary key columns */
  course_type_prefix_by_pk?: Maybe<Course_Type_Prefix>;
  /** fetch data from the table: "dfe_establishment" */
  dfe_establishment: Array<Dfe_Establishment>;
  /** fetch aggregated fields from the table: "dfe_establishment" */
  dfe_establishment_aggregate: Dfe_Establishment_Aggregate;
  /** fetch data from the table: "dfe_establishment" using primary key columns */
  dfe_establishment_by_pk?: Maybe<Dfe_Establishment>;
  /** eligibleTransferCourses */
  eligibleTransferCourses: Array<TransferCourse>;
  /** fetch data from the table: "expire_go1_license_jobs" */
  expire_go1_license_jobs: Array<Expire_Go1_License_Jobs>;
  /** fetch aggregated fields from the table: "expire_go1_license_jobs" */
  expire_go1_license_jobs_aggregate: Expire_Go1_License_Jobs_Aggregate;
  /** fetch data from the table: "expire_go1_license_jobs" using primary key columns */
  expire_go1_license_jobs_by_pk?: Maybe<Expire_Go1_License_Jobs>;
  /** Fetches membership plans */
  fetchPlans?: Maybe<Array<Maybe<PlanObject>>>;
  /** getCoursePricing */
  getCoursePricing?: Maybe<GetCoursePricingOutput>;
  getInvite?: Maybe<CourseInvite>;
  getOrgInvite?: Maybe<OrgInvite>;
  getTrainersLevels?: Maybe<Array<Maybe<TrainerLevels>>>;
  getXeroInvoicesForOrders: Array<Maybe<XeroInvoice>>;
  /** fetch data from the table: "go1_history_events" */
  go1_history_events: Array<Go1_History_Events>;
  /** fetch aggregated fields from the table: "go1_history_events" */
  go1_history_events_aggregate: Go1_History_Events_Aggregate;
  /** fetch data from the table: "go1_history_events" using primary key columns */
  go1_history_events_by_pk?: Maybe<Go1_History_Events>;
  /** fetch data from the table: "go1_licenses" */
  go1_licenses: Array<Go1_Licenses>;
  /** fetch aggregated fields from the table: "go1_licenses" */
  go1_licenses_aggregate: Go1_Licenses_Aggregate;
  /** fetch data from the table: "go1_licenses" using primary key columns */
  go1_licenses_by_pk?: Maybe<Go1_Licenses>;
  /** fetch data from the table: "go1_licenses_history" */
  go1_licenses_history: Array<Go1_Licenses_History>;
  /** fetch aggregated fields from the table: "go1_licenses_history" */
  go1_licenses_history_aggregate: Go1_Licenses_History_Aggregate;
  /** fetch data from the table: "go1_licenses_history" using primary key columns */
  go1_licenses_history_by_pk?: Maybe<Go1_Licenses_History>;
  /** fetch data from the table: "grade" */
  grade: Array<Grade>;
  /** fetch aggregated fields from the table: "grade" */
  grade_aggregate: Grade_Aggregate;
  /** fetch data from the table: "grade" using primary key columns */
  grade_by_pk?: Maybe<Grade>;
  /** fetch data from the table: "identity" */
  identity: Array<Identity>;
  /** fetch aggregated fields from the table: "identity" */
  identity_aggregate: Identity_Aggregate;
  /** fetch data from the table: "identity" using primary key columns */
  identity_by_pk?: Maybe<Identity>;
  /** fetch data from the table: "identity_type" */
  identity_type: Array<Identity_Type>;
  /** fetch aggregated fields from the table: "identity_type" */
  identity_type_aggregate: Identity_Type_Aggregate;
  /** fetch data from the table: "identity_type" using primary key columns */
  identity_type_by_pk?: Maybe<Identity_Type>;
  initAuth: InitAuthOutput;
  /** Checks whether user is subscribed to membership */
  isUserSubscribedToMembership?: Maybe<IsUserSubscribedToMembershipResponse>;
  /** fetch data from the table: "legacy_certificate" */
  legacy_certificate: Array<Legacy_Certificate>;
  /** fetch aggregated fields from the table: "legacy_certificate" */
  legacy_certificate_aggregate: Legacy_Certificate_Aggregate;
  /** fetch data from the table: "legacy_certificate" using primary key columns */
  legacy_certificate_by_pk?: Maybe<Legacy_Certificate>;
  /** fetch data from the table: "module" */
  module: Array<Module>;
  /** fetch aggregated fields from the table: "module" */
  module_aggregate: Module_Aggregate;
  /** fetch data from the table: "module" using primary key columns */
  module_by_pk?: Maybe<Module>;
  /** fetch data from the table: "module_category" */
  module_category: Array<Module_Category>;
  /** fetch aggregated fields from the table: "module_category" */
  module_category_aggregate: Module_Category_Aggregate;
  /** fetch data from the table: "module_category" using primary key columns */
  module_category_by_pk?: Maybe<Module_Category>;
  /** fetch data from the table: "module_group" */
  module_group: Array<Module_Group>;
  /** fetch aggregated fields from the table: "module_group" */
  module_group_aggregate: Module_Group_Aggregate;
  /** fetch data from the table: "module_group" using primary key columns */
  module_group_by_pk?: Maybe<Module_Group>;
  /** fetch data from the table: "module_group_duration" */
  module_group_duration: Array<Module_Group_Duration>;
  /** fetch aggregated fields from the table: "module_group_duration" */
  module_group_duration_aggregate: Module_Group_Duration_Aggregate;
  /** fetch data from the table: "module_group_duration" using primary key columns */
  module_group_duration_by_pk?: Maybe<Module_Group_Duration>;
  /** fetch data from the table: "order" */
  order: Array<Order>;
  /** fetch aggregated fields from the table: "order" */
  order_aggregate: Order_Aggregate;
  /** fetch data from the table: "order" using primary key columns */
  order_by_pk?: Maybe<Order>;
  /** fetch data from the table: "organization" */
  organization: Array<Organization>;
  /** fetch aggregated fields from the table: "organization" */
  organization_aggregate: Organization_Aggregate;
  /** fetch data from the table: "organization" using primary key columns */
  organization_by_pk?: Maybe<Organization>;
  /** fetch data from the table: "organization_invites" */
  organization_invites: Array<Organization_Invites>;
  /** fetch aggregated fields from the table: "organization_invites" */
  organization_invites_aggregate: Organization_Invites_Aggregate;
  /** fetch data from the table: "organization_invites" using primary key columns */
  organization_invites_by_pk?: Maybe<Organization_Invites>;
  /** fetch data from the table: "organization_member" */
  organization_member: Array<Organization_Member>;
  /** fetch aggregated fields from the table: "organization_member" */
  organization_member_aggregate: Organization_Member_Aggregate;
  /** fetch data from the table: "organization_member" using primary key columns */
  organization_member_by_pk?: Maybe<Organization_Member>;
  /** fetch data from the table: "payment_methods" */
  payment_methods: Array<Payment_Methods>;
  /** fetch aggregated fields from the table: "payment_methods" */
  payment_methods_aggregate: Payment_Methods_Aggregate;
  /** fetch data from the table: "payment_methods" using primary key columns */
  payment_methods_by_pk?: Maybe<Payment_Methods>;
  /** Podcast */
  podcast?: Maybe<PodcastPayload>;
  /** Podcasts list */
  podcasts?: Maybe<PodcastsPayload>;
  /** fetch data from the table: "private_course_booking" */
  private_course_booking: Array<Private_Course_Booking>;
  /** fetch aggregated fields from the table: "private_course_booking" */
  private_course_booking_aggregate: Private_Course_Booking_Aggregate;
  /** fetch data from the table: "private_course_booking" using primary key columns */
  private_course_booking_by_pk?: Maybe<Private_Course_Booking>;
  /** fetch data from the table: "profile" */
  profile: Array<Profile>;
  /** fetch aggregated fields from the table: "profile" */
  profile_aggregate: Profile_Aggregate;
  /** fetch data from the table: "profile" using primary key columns */
  profile_by_pk?: Maybe<Profile>;
  /** fetch data from the table: "profile_role" */
  profile_role: Array<Profile_Role>;
  /** fetch aggregated fields from the table: "profile_role" */
  profile_role_aggregate: Profile_Role_Aggregate;
  /** fetch data from the table: "profile_role" using primary key columns */
  profile_role_by_pk?: Maybe<Profile_Role>;
  /** fetch data from the table: "profile_temp" */
  profile_temp: Array<Profile_Temp>;
  /** fetch aggregated fields from the table: "profile_temp" */
  profile_temp_aggregate: Profile_Temp_Aggregate;
  /** fetch data from the table: "profile_temp" using primary key columns */
  profile_temp_by_pk?: Maybe<Profile_Temp>;
  /** fetch data from the table: "profile_trainer_role_type" */
  profile_trainer_role_type: Array<Profile_Trainer_Role_Type>;
  /** fetch aggregated fields from the table: "profile_trainer_role_type" */
  profile_trainer_role_type_aggregate: Profile_Trainer_Role_Type_Aggregate;
  /** fetch data from the table: "profile_trainer_role_type" using primary key columns */
  profile_trainer_role_type_by_pk?: Maybe<Profile_Trainer_Role_Type>;
  /** fetch data from the table: "promo_code" */
  promo_code: Array<Promo_Code>;
  /** fetch aggregated fields from the table: "promo_code" */
  promo_code_aggregate: Promo_Code_Aggregate;
  /** fetch data from the table: "promo_code" using primary key columns */
  promo_code_by_pk?: Maybe<Promo_Code>;
  /** fetch data from the table: "promo_code_type" */
  promo_code_type: Array<Promo_Code_Type>;
  /** fetch aggregated fields from the table: "promo_code_type" */
  promo_code_type_aggregate: Promo_Code_Type_Aggregate;
  /** fetch data from the table: "promo_code_type" using primary key columns */
  promo_code_type_by_pk?: Maybe<Promo_Code_Type>;
  /** fetch data from the table: "role" */
  role: Array<Role>;
  /** fetch aggregated fields from the table: "role" */
  role_aggregate: Role_Aggregate;
  /** fetch data from the table: "role" using primary key columns */
  role_by_pk?: Maybe<Role>;
  searchTrainers?: Maybe<Array<Maybe<SearchTrainer>>>;
  /** fetch data from the table: "trainer_role_type" */
  trainer_role_type: Array<Trainer_Role_Type>;
  /** fetch aggregated fields from the table: "trainer_role_type" */
  trainer_role_type_aggregate: Trainer_Role_Type_Aggregate;
  /** fetch data from the table: "trainer_role_type" using primary key columns */
  trainer_role_type_by_pk?: Maybe<Trainer_Role_Type>;
  /** fetch data from the table: "trust_type" */
  trust_type: Array<Trust_Type>;
  /** fetch aggregated fields from the table: "trust_type" */
  trust_type_aggregate: Trust_Type_Aggregate;
  /** fetch data from the table: "trust_type" using primary key columns */
  trust_type_by_pk?: Maybe<Trust_Type>;
  /** fetch data from the table: "upcoming_enrollments" */
  upcoming_enrollments: Array<Upcoming_Enrollments>;
  /** fetch aggregated fields from the table: "upcoming_enrollments" */
  upcoming_enrollments_aggregate: Upcoming_Enrollments_Aggregate;
  /** fetch data from the table: "venue" */
  venue: Array<Venue>;
  /** fetch aggregated fields from the table: "venue" */
  venue_aggregate: Venue_Aggregate;
  /** fetch data from the table: "venue" using primary key columns */
  venue_by_pk?: Maybe<Venue>;
  /** fetch data from the table: "waitlist" */
  waitlist: Array<Waitlist>;
  /** fetch aggregated fields from the table: "waitlist" */
  waitlist_aggregate: Waitlist_Aggregate;
  /** fetch data from the table: "waitlist" using primary key columns */
  waitlist_by_pk?: Maybe<Waitlist>;
  xeroConnect?: Maybe<XeroConnectOutput>;
  xeroContactSearch?: Maybe<XeroContactSearchOutput>;
  xeroInvoicesStatus?: Maybe<XeroInvoicesStatusOutput>;
  /** fetch data from the table: "xero_credential" */
  xero_credential: Array<Xero_Credential>;
  /** fetch aggregated fields from the table: "xero_credential" */
  xero_credential_aggregate: Xero_Credential_Aggregate;
  /** fetch data from the table: "xero_credential" using primary key columns */
  xero_credential_by_pk?: Maybe<Xero_Credential>;
};


export type Query_RootAvailabilityArgs = {
  distinct_on?: InputMaybe<Array<Availability_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Availability_Order_By>>;
  where?: InputMaybe<Availability_Bool_Exp>;
};


export type Query_RootAvailability_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Availability_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Availability_Order_By>>;
  where?: InputMaybe<Availability_Bool_Exp>;
};


export type Query_RootAvailability_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootBlended_Learning_StatusArgs = {
  distinct_on?: InputMaybe<Array<Blended_Learning_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Blended_Learning_Status_Order_By>>;
  where?: InputMaybe<Blended_Learning_Status_Bool_Exp>;
};


export type Query_RootBlended_Learning_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Blended_Learning_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Blended_Learning_Status_Order_By>>;
  where?: InputMaybe<Blended_Learning_Status_Bool_Exp>;
};


export type Query_RootBlended_Learning_Status_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootCanApplyPromoCodeArgs = {
  input: CanApplyPromoCodeInput;
};


export type Query_RootCertificate_StatusArgs = {
  distinct_on?: InputMaybe<Array<Certificate_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Certificate_Status_Order_By>>;
  where?: InputMaybe<Certificate_Status_Bool_Exp>;
};


export type Query_RootCertificate_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Certificate_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Certificate_Status_Order_By>>;
  where?: InputMaybe<Certificate_Status_Bool_Exp>;
};


export type Query_RootCertificate_Status_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootColorArgs = {
  distinct_on?: InputMaybe<Array<Color_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Color_Order_By>>;
  where?: InputMaybe<Color_Bool_Exp>;
};


export type Query_RootColor_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Color_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Color_Order_By>>;
  where?: InputMaybe<Color_Bool_Exp>;
};


export type Query_RootColor_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootCourseArgs = {
  distinct_on?: InputMaybe<Array<Course_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Order_By>>;
  where?: InputMaybe<Course_Bool_Exp>;
};


export type Query_RootCourse_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Order_By>>;
  where?: InputMaybe<Course_Bool_Exp>;
};


export type Query_RootCourse_AuditArgs = {
  distinct_on?: InputMaybe<Array<Course_Audit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Audit_Order_By>>;
  where?: InputMaybe<Course_Audit_Bool_Exp>;
};


export type Query_RootCourse_Audit_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Audit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Audit_Order_By>>;
  where?: InputMaybe<Course_Audit_Bool_Exp>;
};


export type Query_RootCourse_Audit_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_Audit_TypeArgs = {
  distinct_on?: InputMaybe<Array<Course_Audit_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Audit_Type_Order_By>>;
  where?: InputMaybe<Course_Audit_Type_Bool_Exp>;
};


export type Query_RootCourse_Audit_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Audit_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Audit_Type_Order_By>>;
  where?: InputMaybe<Course_Audit_Type_Bool_Exp>;
};


export type Query_RootCourse_Audit_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootCourse_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootCourse_Cancellation_RequestArgs = {
  distinct_on?: InputMaybe<Array<Course_Cancellation_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Cancellation_Request_Order_By>>;
  where?: InputMaybe<Course_Cancellation_Request_Bool_Exp>;
};


export type Query_RootCourse_Cancellation_Request_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Cancellation_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Cancellation_Request_Order_By>>;
  where?: InputMaybe<Course_Cancellation_Request_Bool_Exp>;
};


export type Query_RootCourse_Cancellation_Request_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_CertificateArgs = {
  distinct_on?: InputMaybe<Array<Course_Certificate_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Certificate_Order_By>>;
  where?: InputMaybe<Course_Certificate_Bool_Exp>;
};


export type Query_RootCourse_Certificate_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Certificate_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Certificate_Order_By>>;
  where?: InputMaybe<Course_Certificate_Bool_Exp>;
};


export type Query_RootCourse_Certificate_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_Certificate_ChangelogArgs = {
  distinct_on?: InputMaybe<Array<Course_Certificate_Changelog_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Certificate_Changelog_Order_By>>;
  where?: InputMaybe<Course_Certificate_Changelog_Bool_Exp>;
};


export type Query_RootCourse_Certificate_Changelog_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Certificate_Changelog_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Certificate_Changelog_Order_By>>;
  where?: InputMaybe<Course_Certificate_Changelog_Bool_Exp>;
};


export type Query_RootCourse_Certificate_Changelog_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_Delivery_TypeArgs = {
  distinct_on?: InputMaybe<Array<Course_Delivery_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Delivery_Type_Order_By>>;
  where?: InputMaybe<Course_Delivery_Type_Bool_Exp>;
};


export type Query_RootCourse_Delivery_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Delivery_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Delivery_Type_Order_By>>;
  where?: InputMaybe<Course_Delivery_Type_Bool_Exp>;
};


export type Query_RootCourse_Delivery_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootCourse_DraftArgs = {
  distinct_on?: InputMaybe<Array<Course_Draft_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Draft_Order_By>>;
  where?: InputMaybe<Course_Draft_Bool_Exp>;
};


export type Query_RootCourse_Draft_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Draft_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Draft_Order_By>>;
  where?: InputMaybe<Course_Draft_Bool_Exp>;
};


export type Query_RootCourse_Draft_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_End_JobsArgs = {
  distinct_on?: InputMaybe<Array<Course_End_Jobs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_End_Jobs_Order_By>>;
  where?: InputMaybe<Course_End_Jobs_Bool_Exp>;
};


export type Query_RootCourse_End_Jobs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_End_Jobs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_End_Jobs_Order_By>>;
  where?: InputMaybe<Course_End_Jobs_Bool_Exp>;
};


export type Query_RootCourse_End_Jobs_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_EnquiryArgs = {
  distinct_on?: InputMaybe<Array<Course_Enquiry_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Enquiry_Order_By>>;
  where?: InputMaybe<Course_Enquiry_Bool_Exp>;
};


export type Query_RootCourse_Enquiry_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Enquiry_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Enquiry_Order_By>>;
  where?: InputMaybe<Course_Enquiry_Bool_Exp>;
};


export type Query_RootCourse_Enquiry_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_Evaluation_AnswersArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Answers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Answers_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Answers_Bool_Exp>;
};


export type Query_RootCourse_Evaluation_Answers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Answers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Answers_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Answers_Bool_Exp>;
};


export type Query_RootCourse_Evaluation_Answers_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_Evaluation_Question_GroupArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Question_Group_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Question_Group_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Question_Group_Bool_Exp>;
};


export type Query_RootCourse_Evaluation_Question_Group_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Question_Group_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Question_Group_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Question_Group_Bool_Exp>;
};


export type Query_RootCourse_Evaluation_Question_Group_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootCourse_Evaluation_Question_TypeArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Question_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Question_Type_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Question_Type_Bool_Exp>;
};


export type Query_RootCourse_Evaluation_Question_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Question_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Question_Type_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Question_Type_Bool_Exp>;
};


export type Query_RootCourse_Evaluation_Question_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootCourse_Evaluation_QuestionsArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Questions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Questions_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Questions_Bool_Exp>;
};


export type Query_RootCourse_Evaluation_Questions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Questions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Questions_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Questions_Bool_Exp>;
};


export type Query_RootCourse_Evaluation_Questions_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_ExpensesArgs = {
  distinct_on?: InputMaybe<Array<Course_Expenses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Expenses_Order_By>>;
  where?: InputMaybe<Course_Expenses_Bool_Exp>;
};


export type Query_RootCourse_Expenses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Expenses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Expenses_Order_By>>;
  where?: InputMaybe<Course_Expenses_Bool_Exp>;
};


export type Query_RootCourse_Expenses_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_Invite_StatusArgs = {
  distinct_on?: InputMaybe<Array<Course_Invite_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Invite_Status_Order_By>>;
  where?: InputMaybe<Course_Invite_Status_Bool_Exp>;
};


export type Query_RootCourse_Invite_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Invite_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Invite_Status_Order_By>>;
  where?: InputMaybe<Course_Invite_Status_Bool_Exp>;
};


export type Query_RootCourse_Invite_Status_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootCourse_InvitesArgs = {
  distinct_on?: InputMaybe<Array<Course_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Invites_Order_By>>;
  where?: InputMaybe<Course_Invites_Bool_Exp>;
};


export type Query_RootCourse_Invites_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Invites_Order_By>>;
  where?: InputMaybe<Course_Invites_Bool_Exp>;
};


export type Query_RootCourse_Invites_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_LevelArgs = {
  distinct_on?: InputMaybe<Array<Course_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Level_Order_By>>;
  where?: InputMaybe<Course_Level_Bool_Exp>;
};


export type Query_RootCourse_Level_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Level_Order_By>>;
  where?: InputMaybe<Course_Level_Bool_Exp>;
};


export type Query_RootCourse_Level_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootCourse_Level_PrefixArgs = {
  distinct_on?: InputMaybe<Array<Course_Level_Prefix_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Level_Prefix_Order_By>>;
  where?: InputMaybe<Course_Level_Prefix_Bool_Exp>;
};


export type Query_RootCourse_Level_Prefix_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Level_Prefix_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Level_Prefix_Order_By>>;
  where?: InputMaybe<Course_Level_Prefix_Bool_Exp>;
};


export type Query_RootCourse_Level_Prefix_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_ModuleArgs = {
  distinct_on?: InputMaybe<Array<Course_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Module_Order_By>>;
  where?: InputMaybe<Course_Module_Bool_Exp>;
};


export type Query_RootCourse_Module_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Module_Order_By>>;
  where?: InputMaybe<Course_Module_Bool_Exp>;
};


export type Query_RootCourse_Module_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_ParticipantArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Order_By>>;
  where?: InputMaybe<Course_Participant_Bool_Exp>;
};


export type Query_RootCourse_Participant_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Order_By>>;
  where?: InputMaybe<Course_Participant_Bool_Exp>;
};


export type Query_RootCourse_Participant_AuditArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Audit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Audit_Order_By>>;
  where?: InputMaybe<Course_Participant_Audit_Bool_Exp>;
};


export type Query_RootCourse_Participant_Audit_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Audit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Audit_Order_By>>;
  where?: InputMaybe<Course_Participant_Audit_Bool_Exp>;
};


export type Query_RootCourse_Participant_Audit_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_Participant_Audit_TypeArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Audit_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Audit_Type_Order_By>>;
  where?: InputMaybe<Course_Participant_Audit_Type_Bool_Exp>;
};


export type Query_RootCourse_Participant_Audit_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Audit_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Audit_Type_Order_By>>;
  where?: InputMaybe<Course_Participant_Audit_Type_Bool_Exp>;
};


export type Query_RootCourse_Participant_Audit_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootCourse_Participant_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_Participant_CancellationArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Cancellation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Cancellation_Order_By>>;
  where?: InputMaybe<Course_Participant_Cancellation_Bool_Exp>;
};


export type Query_RootCourse_Participant_Cancellation_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Cancellation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Cancellation_Order_By>>;
  where?: InputMaybe<Course_Participant_Cancellation_Bool_Exp>;
};


export type Query_RootCourse_Participant_Cancellation_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_Participant_ModuleArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Module_Order_By>>;
  where?: InputMaybe<Course_Participant_Module_Bool_Exp>;
};


export type Query_RootCourse_Participant_Module_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Module_Order_By>>;
  where?: InputMaybe<Course_Participant_Module_Bool_Exp>;
};


export type Query_RootCourse_Participant_Module_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_PricingArgs = {
  distinct_on?: InputMaybe<Array<Course_Pricing_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Pricing_Order_By>>;
  where?: InputMaybe<Course_Pricing_Bool_Exp>;
};


export type Query_RootCourse_Pricing_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Pricing_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Pricing_Order_By>>;
  where?: InputMaybe<Course_Pricing_Bool_Exp>;
};


export type Query_RootCourse_Pricing_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_Promo_CodeArgs = {
  distinct_on?: InputMaybe<Array<Course_Promo_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Promo_Code_Order_By>>;
  where?: InputMaybe<Course_Promo_Code_Bool_Exp>;
};


export type Query_RootCourse_Promo_Code_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Promo_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Promo_Code_Order_By>>;
  where?: InputMaybe<Course_Promo_Code_Bool_Exp>;
};


export type Query_RootCourse_Promo_Code_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_ScheduleArgs = {
  distinct_on?: InputMaybe<Array<Course_Schedule_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Schedule_Order_By>>;
  where?: InputMaybe<Course_Schedule_Bool_Exp>;
};


export type Query_RootCourse_Schedule_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Schedule_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Schedule_Order_By>>;
  where?: InputMaybe<Course_Schedule_Bool_Exp>;
};


export type Query_RootCourse_Schedule_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_StatusArgs = {
  distinct_on?: InputMaybe<Array<Course_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Status_Order_By>>;
  where?: InputMaybe<Course_Status_Bool_Exp>;
};


export type Query_RootCourse_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Status_Order_By>>;
  where?: InputMaybe<Course_Status_Bool_Exp>;
};


export type Query_RootCourse_Status_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootCourse_TrainerArgs = {
  distinct_on?: InputMaybe<Array<Course_Trainer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Trainer_Order_By>>;
  where?: InputMaybe<Course_Trainer_Bool_Exp>;
};


export type Query_RootCourse_Trainer_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Trainer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Trainer_Order_By>>;
  where?: InputMaybe<Course_Trainer_Bool_Exp>;
};


export type Query_RootCourse_Trainer_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCourse_Trainer_TypeArgs = {
  distinct_on?: InputMaybe<Array<Course_Trainer_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Trainer_Type_Order_By>>;
  where?: InputMaybe<Course_Trainer_Type_Bool_Exp>;
};


export type Query_RootCourse_Trainer_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Trainer_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Trainer_Type_Order_By>>;
  where?: InputMaybe<Course_Trainer_Type_Bool_Exp>;
};


export type Query_RootCourse_Trainer_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootCourse_TypeArgs = {
  distinct_on?: InputMaybe<Array<Course_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Type_Order_By>>;
  where?: InputMaybe<Course_Type_Bool_Exp>;
};


export type Query_RootCourse_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Type_Order_By>>;
  where?: InputMaybe<Course_Type_Bool_Exp>;
};


export type Query_RootCourse_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootCourse_Type_PrefixArgs = {
  distinct_on?: InputMaybe<Array<Course_Type_Prefix_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Type_Prefix_Order_By>>;
  where?: InputMaybe<Course_Type_Prefix_Bool_Exp>;
};


export type Query_RootCourse_Type_Prefix_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Type_Prefix_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Type_Prefix_Order_By>>;
  where?: InputMaybe<Course_Type_Prefix_Bool_Exp>;
};


export type Query_RootCourse_Type_Prefix_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootDfe_EstablishmentArgs = {
  distinct_on?: InputMaybe<Array<Dfe_Establishment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Dfe_Establishment_Order_By>>;
  where?: InputMaybe<Dfe_Establishment_Bool_Exp>;
};


export type Query_RootDfe_Establishment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Dfe_Establishment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Dfe_Establishment_Order_By>>;
  where?: InputMaybe<Dfe_Establishment_Bool_Exp>;
};


export type Query_RootDfe_Establishment_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootEligibleTransferCoursesArgs = {
  fromCourseId: Scalars['Int'];
};


export type Query_RootExpire_Go1_License_JobsArgs = {
  distinct_on?: InputMaybe<Array<Expire_Go1_License_Jobs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Expire_Go1_License_Jobs_Order_By>>;
  where?: InputMaybe<Expire_Go1_License_Jobs_Bool_Exp>;
};


export type Query_RootExpire_Go1_License_Jobs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Expire_Go1_License_Jobs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Expire_Go1_License_Jobs_Order_By>>;
  where?: InputMaybe<Expire_Go1_License_Jobs_Bool_Exp>;
};


export type Query_RootExpire_Go1_License_Jobs_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGetCoursePricingArgs = {
  input: GetCoursePricingInput;
};


export type Query_RootGetTrainersLevelsArgs = {
  input: GetTrainersLevelsInput;
};


export type Query_RootGetXeroInvoicesForOrdersArgs = {
  invoiceNumbers: Array<Scalars['String']>;
};


export type Query_RootGo1_History_EventsArgs = {
  distinct_on?: InputMaybe<Array<Go1_History_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_History_Events_Order_By>>;
  where?: InputMaybe<Go1_History_Events_Bool_Exp>;
};


export type Query_RootGo1_History_Events_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Go1_History_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_History_Events_Order_By>>;
  where?: InputMaybe<Go1_History_Events_Bool_Exp>;
};


export type Query_RootGo1_History_Events_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootGo1_LicensesArgs = {
  distinct_on?: InputMaybe<Array<Go1_Licenses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_Licenses_Order_By>>;
  where?: InputMaybe<Go1_Licenses_Bool_Exp>;
};


export type Query_RootGo1_Licenses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Go1_Licenses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_Licenses_Order_By>>;
  where?: InputMaybe<Go1_Licenses_Bool_Exp>;
};


export type Query_RootGo1_Licenses_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGo1_Licenses_HistoryArgs = {
  distinct_on?: InputMaybe<Array<Go1_Licenses_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_Licenses_History_Order_By>>;
  where?: InputMaybe<Go1_Licenses_History_Bool_Exp>;
};


export type Query_RootGo1_Licenses_History_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Go1_Licenses_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_Licenses_History_Order_By>>;
  where?: InputMaybe<Go1_Licenses_History_Bool_Exp>;
};


export type Query_RootGo1_Licenses_History_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootGradeArgs = {
  distinct_on?: InputMaybe<Array<Grade_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Grade_Order_By>>;
  where?: InputMaybe<Grade_Bool_Exp>;
};


export type Query_RootGrade_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Grade_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Grade_Order_By>>;
  where?: InputMaybe<Grade_Bool_Exp>;
};


export type Query_RootGrade_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootIdentityArgs = {
  distinct_on?: InputMaybe<Array<Identity_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Identity_Order_By>>;
  where?: InputMaybe<Identity_Bool_Exp>;
};


export type Query_RootIdentity_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Identity_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Identity_Order_By>>;
  where?: InputMaybe<Identity_Bool_Exp>;
};


export type Query_RootIdentity_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootIdentity_TypeArgs = {
  distinct_on?: InputMaybe<Array<Identity_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Identity_Type_Order_By>>;
  where?: InputMaybe<Identity_Type_Bool_Exp>;
};


export type Query_RootIdentity_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Identity_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Identity_Type_Order_By>>;
  where?: InputMaybe<Identity_Type_Bool_Exp>;
};


export type Query_RootIdentity_Type_By_PkArgs = {
  value: Scalars['String'];
};


export type Query_RootIsUserSubscribedToMembershipArgs = {
  customerId: Scalars['String'];
};


export type Query_RootLegacy_CertificateArgs = {
  distinct_on?: InputMaybe<Array<Legacy_Certificate_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Legacy_Certificate_Order_By>>;
  where?: InputMaybe<Legacy_Certificate_Bool_Exp>;
};


export type Query_RootLegacy_Certificate_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Legacy_Certificate_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Legacy_Certificate_Order_By>>;
  where?: InputMaybe<Legacy_Certificate_Bool_Exp>;
};


export type Query_RootLegacy_Certificate_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootModuleArgs = {
  distinct_on?: InputMaybe<Array<Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Order_By>>;
  where?: InputMaybe<Module_Bool_Exp>;
};


export type Query_RootModule_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Order_By>>;
  where?: InputMaybe<Module_Bool_Exp>;
};


export type Query_RootModule_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootModule_CategoryArgs = {
  distinct_on?: InputMaybe<Array<Module_Category_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Category_Order_By>>;
  where?: InputMaybe<Module_Category_Bool_Exp>;
};


export type Query_RootModule_Category_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Category_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Category_Order_By>>;
  where?: InputMaybe<Module_Category_Bool_Exp>;
};


export type Query_RootModule_Category_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootModule_GroupArgs = {
  distinct_on?: InputMaybe<Array<Module_Group_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Group_Order_By>>;
  where?: InputMaybe<Module_Group_Bool_Exp>;
};


export type Query_RootModule_Group_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Group_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Group_Order_By>>;
  where?: InputMaybe<Module_Group_Bool_Exp>;
};


export type Query_RootModule_Group_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootModule_Group_DurationArgs = {
  distinct_on?: InputMaybe<Array<Module_Group_Duration_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Group_Duration_Order_By>>;
  where?: InputMaybe<Module_Group_Duration_Bool_Exp>;
};


export type Query_RootModule_Group_Duration_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Group_Duration_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Group_Duration_Order_By>>;
  where?: InputMaybe<Module_Group_Duration_Bool_Exp>;
};


export type Query_RootModule_Group_Duration_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootOrderArgs = {
  distinct_on?: InputMaybe<Array<Order_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Order_Order_By>>;
  where?: InputMaybe<Order_Bool_Exp>;
};


export type Query_RootOrder_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Order_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Order_Order_By>>;
  where?: InputMaybe<Order_Bool_Exp>;
};


export type Query_RootOrder_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootOrganizationArgs = {
  distinct_on?: InputMaybe<Array<Organization_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Order_By>>;
  where?: InputMaybe<Organization_Bool_Exp>;
};


export type Query_RootOrganization_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Order_By>>;
  where?: InputMaybe<Organization_Bool_Exp>;
};


export type Query_RootOrganization_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootOrganization_InvitesArgs = {
  distinct_on?: InputMaybe<Array<Organization_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Invites_Order_By>>;
  where?: InputMaybe<Organization_Invites_Bool_Exp>;
};


export type Query_RootOrganization_Invites_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Invites_Order_By>>;
  where?: InputMaybe<Organization_Invites_Bool_Exp>;
};


export type Query_RootOrganization_Invites_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootOrganization_MemberArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Order_By>>;
  where?: InputMaybe<Organization_Member_Bool_Exp>;
};


export type Query_RootOrganization_Member_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Order_By>>;
  where?: InputMaybe<Organization_Member_Bool_Exp>;
};


export type Query_RootOrganization_Member_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPayment_MethodsArgs = {
  distinct_on?: InputMaybe<Array<Payment_Methods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Payment_Methods_Order_By>>;
  where?: InputMaybe<Payment_Methods_Bool_Exp>;
};


export type Query_RootPayment_Methods_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Payment_Methods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Payment_Methods_Order_By>>;
  where?: InputMaybe<Payment_Methods_Bool_Exp>;
};


export type Query_RootPayment_Methods_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootPodcastArgs = {
  id: Scalars['ID'];
};


export type Query_RootPodcastsArgs = {
  input?: InputMaybe<PodcastsInput>;
};


export type Query_RootPrivate_Course_BookingArgs = {
  distinct_on?: InputMaybe<Array<Private_Course_Booking_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Private_Course_Booking_Order_By>>;
  where?: InputMaybe<Private_Course_Booking_Bool_Exp>;
};


export type Query_RootPrivate_Course_Booking_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Private_Course_Booking_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Private_Course_Booking_Order_By>>;
  where?: InputMaybe<Private_Course_Booking_Bool_Exp>;
};


export type Query_RootPrivate_Course_Booking_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootProfileArgs = {
  distinct_on?: InputMaybe<Array<Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Order_By>>;
  where?: InputMaybe<Profile_Bool_Exp>;
};


export type Query_RootProfile_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Order_By>>;
  where?: InputMaybe<Profile_Bool_Exp>;
};


export type Query_RootProfile_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootProfile_RoleArgs = {
  distinct_on?: InputMaybe<Array<Profile_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Role_Order_By>>;
  where?: InputMaybe<Profile_Role_Bool_Exp>;
};


export type Query_RootProfile_Role_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Role_Order_By>>;
  where?: InputMaybe<Profile_Role_Bool_Exp>;
};


export type Query_RootProfile_Role_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootProfile_TempArgs = {
  distinct_on?: InputMaybe<Array<Profile_Temp_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Temp_Order_By>>;
  where?: InputMaybe<Profile_Temp_Bool_Exp>;
};


export type Query_RootProfile_Temp_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Temp_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Temp_Order_By>>;
  where?: InputMaybe<Profile_Temp_Bool_Exp>;
};


export type Query_RootProfile_Temp_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootProfile_Trainer_Role_TypeArgs = {
  distinct_on?: InputMaybe<Array<Profile_Trainer_Role_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Trainer_Role_Type_Order_By>>;
  where?: InputMaybe<Profile_Trainer_Role_Type_Bool_Exp>;
};


export type Query_RootProfile_Trainer_Role_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Trainer_Role_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Trainer_Role_Type_Order_By>>;
  where?: InputMaybe<Profile_Trainer_Role_Type_Bool_Exp>;
};


export type Query_RootProfile_Trainer_Role_Type_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPromo_CodeArgs = {
  distinct_on?: InputMaybe<Array<Promo_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Promo_Code_Order_By>>;
  where?: InputMaybe<Promo_Code_Bool_Exp>;
};


export type Query_RootPromo_Code_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Promo_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Promo_Code_Order_By>>;
  where?: InputMaybe<Promo_Code_Bool_Exp>;
};


export type Query_RootPromo_Code_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPromo_Code_TypeArgs = {
  distinct_on?: InputMaybe<Array<Promo_Code_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Promo_Code_Type_Order_By>>;
  where?: InputMaybe<Promo_Code_Type_Bool_Exp>;
};


export type Query_RootPromo_Code_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Promo_Code_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Promo_Code_Type_Order_By>>;
  where?: InputMaybe<Promo_Code_Type_Bool_Exp>;
};


export type Query_RootPromo_Code_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootRoleArgs = {
  distinct_on?: InputMaybe<Array<Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Role_Order_By>>;
  where?: InputMaybe<Role_Bool_Exp>;
};


export type Query_RootRole_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Role_Order_By>>;
  where?: InputMaybe<Role_Bool_Exp>;
};


export type Query_RootRole_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootSearchTrainersArgs = {
  input: SearchTrainersInput;
};


export type Query_RootTrainer_Role_TypeArgs = {
  distinct_on?: InputMaybe<Array<Trainer_Role_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Trainer_Role_Type_Order_By>>;
  where?: InputMaybe<Trainer_Role_Type_Bool_Exp>;
};


export type Query_RootTrainer_Role_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Trainer_Role_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Trainer_Role_Type_Order_By>>;
  where?: InputMaybe<Trainer_Role_Type_Bool_Exp>;
};


export type Query_RootTrainer_Role_Type_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootTrust_TypeArgs = {
  distinct_on?: InputMaybe<Array<Trust_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Trust_Type_Order_By>>;
  where?: InputMaybe<Trust_Type_Bool_Exp>;
};


export type Query_RootTrust_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Trust_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Trust_Type_Order_By>>;
  where?: InputMaybe<Trust_Type_Bool_Exp>;
};


export type Query_RootTrust_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootUpcoming_EnrollmentsArgs = {
  distinct_on?: InputMaybe<Array<Upcoming_Enrollments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Upcoming_Enrollments_Order_By>>;
  where?: InputMaybe<Upcoming_Enrollments_Bool_Exp>;
};


export type Query_RootUpcoming_Enrollments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Upcoming_Enrollments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Upcoming_Enrollments_Order_By>>;
  where?: InputMaybe<Upcoming_Enrollments_Bool_Exp>;
};


export type Query_RootVenueArgs = {
  distinct_on?: InputMaybe<Array<Venue_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Venue_Order_By>>;
  where?: InputMaybe<Venue_Bool_Exp>;
};


export type Query_RootVenue_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Venue_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Venue_Order_By>>;
  where?: InputMaybe<Venue_Bool_Exp>;
};


export type Query_RootVenue_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootWaitlistArgs = {
  distinct_on?: InputMaybe<Array<Waitlist_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Waitlist_Order_By>>;
  where?: InputMaybe<Waitlist_Bool_Exp>;
};


export type Query_RootWaitlist_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Waitlist_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Waitlist_Order_By>>;
  where?: InputMaybe<Waitlist_Bool_Exp>;
};


export type Query_RootWaitlist_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootXeroContactSearchArgs = {
  input: XeroContactSearchInput;
};


export type Query_RootXeroInvoicesStatusArgs = {
  input: XeroInvoicesStatusInput;
};


export type Query_RootXero_CredentialArgs = {
  distinct_on?: InputMaybe<Array<Xero_Credential_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Xero_Credential_Order_By>>;
  where?: InputMaybe<Xero_Credential_Bool_Exp>;
};


export type Query_RootXero_Credential_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Xero_Credential_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Xero_Credential_Order_By>>;
  where?: InputMaybe<Xero_Credential_Bool_Exp>;
};


export type Query_RootXero_Credential_By_PkArgs = {
  client_id: Scalars['String'];
};

/** columns and relationships of "role" */
export type Role = {
  __typename?: 'role';
  data: Scalars['jsonb'];
  id: Scalars['uuid'];
  name: Scalars['String'];
  /** An array relationship */
  profile_roles: Array<Profile_Role>;
  /** An aggregate relationship */
  profile_roles_aggregate: Profile_Role_Aggregate;
  rank?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "role" */
export type RoleDataArgs = {
  path?: InputMaybe<Scalars['String']>;
};


/** columns and relationships of "role" */
export type RoleProfile_RolesArgs = {
  distinct_on?: InputMaybe<Array<Profile_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Role_Order_By>>;
  where?: InputMaybe<Profile_Role_Bool_Exp>;
};


/** columns and relationships of "role" */
export type RoleProfile_Roles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Role_Order_By>>;
  where?: InputMaybe<Profile_Role_Bool_Exp>;
};

/** aggregated selection of "role" */
export type Role_Aggregate = {
  __typename?: 'role_aggregate';
  aggregate?: Maybe<Role_Aggregate_Fields>;
  nodes: Array<Role>;
};

/** aggregate fields of "role" */
export type Role_Aggregate_Fields = {
  __typename?: 'role_aggregate_fields';
  avg?: Maybe<Role_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Role_Max_Fields>;
  min?: Maybe<Role_Min_Fields>;
  stddev?: Maybe<Role_Stddev_Fields>;
  stddev_pop?: Maybe<Role_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Role_Stddev_Samp_Fields>;
  sum?: Maybe<Role_Sum_Fields>;
  var_pop?: Maybe<Role_Var_Pop_Fields>;
  var_samp?: Maybe<Role_Var_Samp_Fields>;
  variance?: Maybe<Role_Variance_Fields>;
};


/** aggregate fields of "role" */
export type Role_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Role_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Role_Append_Input = {
  data?: InputMaybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Role_Avg_Fields = {
  __typename?: 'role_avg_fields';
  rank?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "role". All fields are combined with a logical 'AND'. */
export type Role_Bool_Exp = {
  _and?: InputMaybe<Array<Role_Bool_Exp>>;
  _not?: InputMaybe<Role_Bool_Exp>;
  _or?: InputMaybe<Array<Role_Bool_Exp>>;
  data?: InputMaybe<Jsonb_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  profile_roles?: InputMaybe<Profile_Role_Bool_Exp>;
  rank?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "role" */
export enum Role_Constraint {
  /** unique or primary key constraint */
  RoleNameKey = 'role_name_key',
  /** unique or primary key constraint */
  RolePkey = 'role_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Role_Delete_At_Path_Input = {
  data?: InputMaybe<Array<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Role_Delete_Elem_Input = {
  data?: InputMaybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Role_Delete_Key_Input = {
  data?: InputMaybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "role" */
export type Role_Inc_Input = {
  rank?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "role" */
export type Role_Insert_Input = {
  data?: InputMaybe<Scalars['jsonb']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  profile_roles?: InputMaybe<Profile_Role_Arr_Rel_Insert_Input>;
  rank?: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Role_Max_Fields = {
  __typename?: 'role_max_fields';
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  rank?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Role_Min_Fields = {
  __typename?: 'role_min_fields';
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  rank?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "role" */
export type Role_Mutation_Response = {
  __typename?: 'role_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Role>;
};

/** input type for inserting object relation for remote table "role" */
export type Role_Obj_Rel_Insert_Input = {
  data: Role_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Role_On_Conflict>;
};

/** on_conflict condition type for table "role" */
export type Role_On_Conflict = {
  constraint: Role_Constraint;
  update_columns?: Array<Role_Update_Column>;
  where?: InputMaybe<Role_Bool_Exp>;
};

/** Ordering options when selecting data from "role". */
export type Role_Order_By = {
  data?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  profile_roles_aggregate?: InputMaybe<Profile_Role_Aggregate_Order_By>;
  rank?: InputMaybe<Order_By>;
};

/** primary key columns input for table: role */
export type Role_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Role_Prepend_Input = {
  data?: InputMaybe<Scalars['jsonb']>;
};

/** select columns of table "role" */
export enum Role_Select_Column {
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Rank = 'rank'
}

/** input type for updating data in table "role" */
export type Role_Set_Input = {
  data?: InputMaybe<Scalars['jsonb']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  rank?: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Role_Stddev_Fields = {
  __typename?: 'role_stddev_fields';
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Role_Stddev_Pop_Fields = {
  __typename?: 'role_stddev_pop_fields';
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Role_Stddev_Samp_Fields = {
  __typename?: 'role_stddev_samp_fields';
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Role_Sum_Fields = {
  __typename?: 'role_sum_fields';
  rank?: Maybe<Scalars['Int']>;
};

/** update columns of table "role" */
export enum Role_Update_Column {
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Rank = 'rank'
}

/** aggregate var_pop on columns */
export type Role_Var_Pop_Fields = {
  __typename?: 'role_var_pop_fields';
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Role_Var_Samp_Fields = {
  __typename?: 'role_var_samp_fields';
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Role_Variance_Fields = {
  __typename?: 'role_variance_fields';
  rank?: Maybe<Scalars['Float']>;
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "availability" */
  availability: Array<Availability>;
  /** fetch aggregated fields from the table: "availability" */
  availability_aggregate: Availability_Aggregate;
  /** fetch data from the table: "availability" using primary key columns */
  availability_by_pk?: Maybe<Availability>;
  /** fetch data from the table: "blended_learning_status" */
  blended_learning_status: Array<Blended_Learning_Status>;
  /** fetch aggregated fields from the table: "blended_learning_status" */
  blended_learning_status_aggregate: Blended_Learning_Status_Aggregate;
  /** fetch data from the table: "blended_learning_status" using primary key columns */
  blended_learning_status_by_pk?: Maybe<Blended_Learning_Status>;
  /** fetch data from the table: "certificate_status" */
  certificate_status: Array<Certificate_Status>;
  /** fetch aggregated fields from the table: "certificate_status" */
  certificate_status_aggregate: Certificate_Status_Aggregate;
  /** fetch data from the table: "certificate_status" using primary key columns */
  certificate_status_by_pk?: Maybe<Certificate_Status>;
  /** fetch data from the table: "color" */
  color: Array<Color>;
  /** fetch aggregated fields from the table: "color" */
  color_aggregate: Color_Aggregate;
  /** fetch data from the table: "color" using primary key columns */
  color_by_pk?: Maybe<Color>;
  /** fetch data from the table: "course" */
  course: Array<Course>;
  /** fetch aggregated fields from the table: "course" */
  course_aggregate: Course_Aggregate;
  /** fetch data from the table: "course_audit" */
  course_audit: Array<Course_Audit>;
  /** fetch aggregated fields from the table: "course_audit" */
  course_audit_aggregate: Course_Audit_Aggregate;
  /** fetch data from the table: "course_audit" using primary key columns */
  course_audit_by_pk?: Maybe<Course_Audit>;
  /** fetch data from the table: "course_audit_type" */
  course_audit_type: Array<Course_Audit_Type>;
  /** fetch aggregated fields from the table: "course_audit_type" */
  course_audit_type_aggregate: Course_Audit_Type_Aggregate;
  /** fetch data from the table: "course_audit_type" using primary key columns */
  course_audit_type_by_pk?: Maybe<Course_Audit_Type>;
  /** fetch data from the table: "course" using primary key columns */
  course_by_pk?: Maybe<Course>;
  /** fetch data from the table: "course_cancellation_request" */
  course_cancellation_request: Array<Course_Cancellation_Request>;
  /** fetch aggregated fields from the table: "course_cancellation_request" */
  course_cancellation_request_aggregate: Course_Cancellation_Request_Aggregate;
  /** fetch data from the table: "course_cancellation_request" using primary key columns */
  course_cancellation_request_by_pk?: Maybe<Course_Cancellation_Request>;
  /** fetch data from the table: "course_certificate" */
  course_certificate: Array<Course_Certificate>;
  /** fetch aggregated fields from the table: "course_certificate" */
  course_certificate_aggregate: Course_Certificate_Aggregate;
  /** fetch data from the table: "course_certificate" using primary key columns */
  course_certificate_by_pk?: Maybe<Course_Certificate>;
  /** fetch data from the table: "course_certificate_changelog" */
  course_certificate_changelog: Array<Course_Certificate_Changelog>;
  /** fetch aggregated fields from the table: "course_certificate_changelog" */
  course_certificate_changelog_aggregate: Course_Certificate_Changelog_Aggregate;
  /** fetch data from the table: "course_certificate_changelog" using primary key columns */
  course_certificate_changelog_by_pk?: Maybe<Course_Certificate_Changelog>;
  /** fetch data from the table: "course_delivery_type" */
  course_delivery_type: Array<Course_Delivery_Type>;
  /** fetch aggregated fields from the table: "course_delivery_type" */
  course_delivery_type_aggregate: Course_Delivery_Type_Aggregate;
  /** fetch data from the table: "course_delivery_type" using primary key columns */
  course_delivery_type_by_pk?: Maybe<Course_Delivery_Type>;
  /** fetch data from the table: "course_draft" */
  course_draft: Array<Course_Draft>;
  /** fetch aggregated fields from the table: "course_draft" */
  course_draft_aggregate: Course_Draft_Aggregate;
  /** fetch data from the table: "course_draft" using primary key columns */
  course_draft_by_pk?: Maybe<Course_Draft>;
  /** fetch data from the table: "course_end_jobs" */
  course_end_jobs: Array<Course_End_Jobs>;
  /** fetch aggregated fields from the table: "course_end_jobs" */
  course_end_jobs_aggregate: Course_End_Jobs_Aggregate;
  /** fetch data from the table: "course_end_jobs" using primary key columns */
  course_end_jobs_by_pk?: Maybe<Course_End_Jobs>;
  /** fetch data from the table: "course_enquiry" */
  course_enquiry: Array<Course_Enquiry>;
  /** fetch aggregated fields from the table: "course_enquiry" */
  course_enquiry_aggregate: Course_Enquiry_Aggregate;
  /** fetch data from the table: "course_enquiry" using primary key columns */
  course_enquiry_by_pk?: Maybe<Course_Enquiry>;
  /** fetch data from the table: "course_evaluation_answers" */
  course_evaluation_answers: Array<Course_Evaluation_Answers>;
  /** fetch aggregated fields from the table: "course_evaluation_answers" */
  course_evaluation_answers_aggregate: Course_Evaluation_Answers_Aggregate;
  /** fetch data from the table: "course_evaluation_answers" using primary key columns */
  course_evaluation_answers_by_pk?: Maybe<Course_Evaluation_Answers>;
  /** fetch data from the table: "course_evaluation_question_group" */
  course_evaluation_question_group: Array<Course_Evaluation_Question_Group>;
  /** fetch aggregated fields from the table: "course_evaluation_question_group" */
  course_evaluation_question_group_aggregate: Course_Evaluation_Question_Group_Aggregate;
  /** fetch data from the table: "course_evaluation_question_group" using primary key columns */
  course_evaluation_question_group_by_pk?: Maybe<Course_Evaluation_Question_Group>;
  /** fetch data from the table: "course_evaluation_question_type" */
  course_evaluation_question_type: Array<Course_Evaluation_Question_Type>;
  /** fetch aggregated fields from the table: "course_evaluation_question_type" */
  course_evaluation_question_type_aggregate: Course_Evaluation_Question_Type_Aggregate;
  /** fetch data from the table: "course_evaluation_question_type" using primary key columns */
  course_evaluation_question_type_by_pk?: Maybe<Course_Evaluation_Question_Type>;
  /** fetch data from the table: "course_evaluation_questions" */
  course_evaluation_questions: Array<Course_Evaluation_Questions>;
  /** fetch aggregated fields from the table: "course_evaluation_questions" */
  course_evaluation_questions_aggregate: Course_Evaluation_Questions_Aggregate;
  /** fetch data from the table: "course_evaluation_questions" using primary key columns */
  course_evaluation_questions_by_pk?: Maybe<Course_Evaluation_Questions>;
  /** fetch data from the table: "course_expenses" */
  course_expenses: Array<Course_Expenses>;
  /** fetch aggregated fields from the table: "course_expenses" */
  course_expenses_aggregate: Course_Expenses_Aggregate;
  /** fetch data from the table: "course_expenses" using primary key columns */
  course_expenses_by_pk?: Maybe<Course_Expenses>;
  /** fetch data from the table: "course_invite_status" */
  course_invite_status: Array<Course_Invite_Status>;
  /** fetch aggregated fields from the table: "course_invite_status" */
  course_invite_status_aggregate: Course_Invite_Status_Aggregate;
  /** fetch data from the table: "course_invite_status" using primary key columns */
  course_invite_status_by_pk?: Maybe<Course_Invite_Status>;
  /** fetch data from the table: "course_invites" */
  course_invites: Array<Course_Invites>;
  /** fetch aggregated fields from the table: "course_invites" */
  course_invites_aggregate: Course_Invites_Aggregate;
  /** fetch data from the table: "course_invites" using primary key columns */
  course_invites_by_pk?: Maybe<Course_Invites>;
  /** fetch data from the table: "course_level" */
  course_level: Array<Course_Level>;
  /** fetch aggregated fields from the table: "course_level" */
  course_level_aggregate: Course_Level_Aggregate;
  /** fetch data from the table: "course_level" using primary key columns */
  course_level_by_pk?: Maybe<Course_Level>;
  /** fetch data from the table: "course_level_prefix" */
  course_level_prefix: Array<Course_Level_Prefix>;
  /** fetch aggregated fields from the table: "course_level_prefix" */
  course_level_prefix_aggregate: Course_Level_Prefix_Aggregate;
  /** fetch data from the table: "course_level_prefix" using primary key columns */
  course_level_prefix_by_pk?: Maybe<Course_Level_Prefix>;
  /** fetch data from the table: "course_module" */
  course_module: Array<Course_Module>;
  /** fetch aggregated fields from the table: "course_module" */
  course_module_aggregate: Course_Module_Aggregate;
  /** fetch data from the table: "course_module" using primary key columns */
  course_module_by_pk?: Maybe<Course_Module>;
  /** fetch data from the table: "course_participant" */
  course_participant: Array<Course_Participant>;
  /** fetch aggregated fields from the table: "course_participant" */
  course_participant_aggregate: Course_Participant_Aggregate;
  /** fetch data from the table: "course_participant_audit" */
  course_participant_audit: Array<Course_Participant_Audit>;
  /** fetch aggregated fields from the table: "course_participant_audit" */
  course_participant_audit_aggregate: Course_Participant_Audit_Aggregate;
  /** fetch data from the table: "course_participant_audit" using primary key columns */
  course_participant_audit_by_pk?: Maybe<Course_Participant_Audit>;
  /** fetch data from the table: "course_participant_audit_type" */
  course_participant_audit_type: Array<Course_Participant_Audit_Type>;
  /** fetch aggregated fields from the table: "course_participant_audit_type" */
  course_participant_audit_type_aggregate: Course_Participant_Audit_Type_Aggregate;
  /** fetch data from the table: "course_participant_audit_type" using primary key columns */
  course_participant_audit_type_by_pk?: Maybe<Course_Participant_Audit_Type>;
  /** fetch data from the table: "course_participant" using primary key columns */
  course_participant_by_pk?: Maybe<Course_Participant>;
  /** fetch data from the table: "course_participant_cancellation" */
  course_participant_cancellation: Array<Course_Participant_Cancellation>;
  /** fetch aggregated fields from the table: "course_participant_cancellation" */
  course_participant_cancellation_aggregate: Course_Participant_Cancellation_Aggregate;
  /** fetch data from the table: "course_participant_cancellation" using primary key columns */
  course_participant_cancellation_by_pk?: Maybe<Course_Participant_Cancellation>;
  /** fetch data from the table: "course_participant_module" */
  course_participant_module: Array<Course_Participant_Module>;
  /** fetch aggregated fields from the table: "course_participant_module" */
  course_participant_module_aggregate: Course_Participant_Module_Aggregate;
  /** fetch data from the table: "course_participant_module" using primary key columns */
  course_participant_module_by_pk?: Maybe<Course_Participant_Module>;
  /** fetch data from the table: "course_pricing" */
  course_pricing: Array<Course_Pricing>;
  /** fetch aggregated fields from the table: "course_pricing" */
  course_pricing_aggregate: Course_Pricing_Aggregate;
  /** fetch data from the table: "course_pricing" using primary key columns */
  course_pricing_by_pk?: Maybe<Course_Pricing>;
  /** fetch data from the table: "course_promo_code" */
  course_promo_code: Array<Course_Promo_Code>;
  /** fetch aggregated fields from the table: "course_promo_code" */
  course_promo_code_aggregate: Course_Promo_Code_Aggregate;
  /** fetch data from the table: "course_promo_code" using primary key columns */
  course_promo_code_by_pk?: Maybe<Course_Promo_Code>;
  /** fetch data from the table: "course_schedule" */
  course_schedule: Array<Course_Schedule>;
  /** fetch aggregated fields from the table: "course_schedule" */
  course_schedule_aggregate: Course_Schedule_Aggregate;
  /** fetch data from the table: "course_schedule" using primary key columns */
  course_schedule_by_pk?: Maybe<Course_Schedule>;
  /** fetch data from the table: "course_status" */
  course_status: Array<Course_Status>;
  /** fetch aggregated fields from the table: "course_status" */
  course_status_aggregate: Course_Status_Aggregate;
  /** fetch data from the table: "course_status" using primary key columns */
  course_status_by_pk?: Maybe<Course_Status>;
  /** An array relationship */
  course_trainer: Array<Course_Trainer>;
  /** An aggregate relationship */
  course_trainer_aggregate: Course_Trainer_Aggregate;
  /** fetch data from the table: "course_trainer" using primary key columns */
  course_trainer_by_pk?: Maybe<Course_Trainer>;
  /** fetch data from the table: "course_trainer_type" */
  course_trainer_type: Array<Course_Trainer_Type>;
  /** fetch aggregated fields from the table: "course_trainer_type" */
  course_trainer_type_aggregate: Course_Trainer_Type_Aggregate;
  /** fetch data from the table: "course_trainer_type" using primary key columns */
  course_trainer_type_by_pk?: Maybe<Course_Trainer_Type>;
  /** fetch data from the table: "course_type" */
  course_type: Array<Course_Type>;
  /** fetch aggregated fields from the table: "course_type" */
  course_type_aggregate: Course_Type_Aggregate;
  /** fetch data from the table: "course_type" using primary key columns */
  course_type_by_pk?: Maybe<Course_Type>;
  /** fetch data from the table: "course_type_prefix" */
  course_type_prefix: Array<Course_Type_Prefix>;
  /** fetch aggregated fields from the table: "course_type_prefix" */
  course_type_prefix_aggregate: Course_Type_Prefix_Aggregate;
  /** fetch data from the table: "course_type_prefix" using primary key columns */
  course_type_prefix_by_pk?: Maybe<Course_Type_Prefix>;
  /** fetch data from the table: "dfe_establishment" */
  dfe_establishment: Array<Dfe_Establishment>;
  /** fetch aggregated fields from the table: "dfe_establishment" */
  dfe_establishment_aggregate: Dfe_Establishment_Aggregate;
  /** fetch data from the table: "dfe_establishment" using primary key columns */
  dfe_establishment_by_pk?: Maybe<Dfe_Establishment>;
  /** fetch data from the table: "expire_go1_license_jobs" */
  expire_go1_license_jobs: Array<Expire_Go1_License_Jobs>;
  /** fetch aggregated fields from the table: "expire_go1_license_jobs" */
  expire_go1_license_jobs_aggregate: Expire_Go1_License_Jobs_Aggregate;
  /** fetch data from the table: "expire_go1_license_jobs" using primary key columns */
  expire_go1_license_jobs_by_pk?: Maybe<Expire_Go1_License_Jobs>;
  /** fetch data from the table: "go1_history_events" */
  go1_history_events: Array<Go1_History_Events>;
  /** fetch aggregated fields from the table: "go1_history_events" */
  go1_history_events_aggregate: Go1_History_Events_Aggregate;
  /** fetch data from the table: "go1_history_events" using primary key columns */
  go1_history_events_by_pk?: Maybe<Go1_History_Events>;
  /** fetch data from the table: "go1_licenses" */
  go1_licenses: Array<Go1_Licenses>;
  /** fetch aggregated fields from the table: "go1_licenses" */
  go1_licenses_aggregate: Go1_Licenses_Aggregate;
  /** fetch data from the table: "go1_licenses" using primary key columns */
  go1_licenses_by_pk?: Maybe<Go1_Licenses>;
  /** fetch data from the table: "go1_licenses_history" */
  go1_licenses_history: Array<Go1_Licenses_History>;
  /** fetch aggregated fields from the table: "go1_licenses_history" */
  go1_licenses_history_aggregate: Go1_Licenses_History_Aggregate;
  /** fetch data from the table: "go1_licenses_history" using primary key columns */
  go1_licenses_history_by_pk?: Maybe<Go1_Licenses_History>;
  /** fetch data from the table: "grade" */
  grade: Array<Grade>;
  /** fetch aggregated fields from the table: "grade" */
  grade_aggregate: Grade_Aggregate;
  /** fetch data from the table: "grade" using primary key columns */
  grade_by_pk?: Maybe<Grade>;
  /** fetch data from the table: "identity" */
  identity: Array<Identity>;
  /** fetch aggregated fields from the table: "identity" */
  identity_aggregate: Identity_Aggregate;
  /** fetch data from the table: "identity" using primary key columns */
  identity_by_pk?: Maybe<Identity>;
  /** fetch data from the table: "identity_type" */
  identity_type: Array<Identity_Type>;
  /** fetch aggregated fields from the table: "identity_type" */
  identity_type_aggregate: Identity_Type_Aggregate;
  /** fetch data from the table: "identity_type" using primary key columns */
  identity_type_by_pk?: Maybe<Identity_Type>;
  /** fetch data from the table: "legacy_certificate" */
  legacy_certificate: Array<Legacy_Certificate>;
  /** fetch aggregated fields from the table: "legacy_certificate" */
  legacy_certificate_aggregate: Legacy_Certificate_Aggregate;
  /** fetch data from the table: "legacy_certificate" using primary key columns */
  legacy_certificate_by_pk?: Maybe<Legacy_Certificate>;
  /** fetch data from the table: "module" */
  module: Array<Module>;
  /** fetch aggregated fields from the table: "module" */
  module_aggregate: Module_Aggregate;
  /** fetch data from the table: "module" using primary key columns */
  module_by_pk?: Maybe<Module>;
  /** fetch data from the table: "module_category" */
  module_category: Array<Module_Category>;
  /** fetch aggregated fields from the table: "module_category" */
  module_category_aggregate: Module_Category_Aggregate;
  /** fetch data from the table: "module_category" using primary key columns */
  module_category_by_pk?: Maybe<Module_Category>;
  /** fetch data from the table: "module_group" */
  module_group: Array<Module_Group>;
  /** fetch aggregated fields from the table: "module_group" */
  module_group_aggregate: Module_Group_Aggregate;
  /** fetch data from the table: "module_group" using primary key columns */
  module_group_by_pk?: Maybe<Module_Group>;
  /** fetch data from the table: "module_group_duration" */
  module_group_duration: Array<Module_Group_Duration>;
  /** fetch aggregated fields from the table: "module_group_duration" */
  module_group_duration_aggregate: Module_Group_Duration_Aggregate;
  /** fetch data from the table: "module_group_duration" using primary key columns */
  module_group_duration_by_pk?: Maybe<Module_Group_Duration>;
  /** fetch data from the table: "order" */
  order: Array<Order>;
  /** fetch aggregated fields from the table: "order" */
  order_aggregate: Order_Aggregate;
  /** fetch data from the table: "order" using primary key columns */
  order_by_pk?: Maybe<Order>;
  /** fetch data from the table: "organization" */
  organization: Array<Organization>;
  /** fetch aggregated fields from the table: "organization" */
  organization_aggregate: Organization_Aggregate;
  /** fetch data from the table: "organization" using primary key columns */
  organization_by_pk?: Maybe<Organization>;
  /** fetch data from the table: "organization_invites" */
  organization_invites: Array<Organization_Invites>;
  /** fetch aggregated fields from the table: "organization_invites" */
  organization_invites_aggregate: Organization_Invites_Aggregate;
  /** fetch data from the table: "organization_invites" using primary key columns */
  organization_invites_by_pk?: Maybe<Organization_Invites>;
  /** fetch data from the table: "organization_member" */
  organization_member: Array<Organization_Member>;
  /** fetch aggregated fields from the table: "organization_member" */
  organization_member_aggregate: Organization_Member_Aggregate;
  /** fetch data from the table: "organization_member" using primary key columns */
  organization_member_by_pk?: Maybe<Organization_Member>;
  /** fetch data from the table: "payment_methods" */
  payment_methods: Array<Payment_Methods>;
  /** fetch aggregated fields from the table: "payment_methods" */
  payment_methods_aggregate: Payment_Methods_Aggregate;
  /** fetch data from the table: "payment_methods" using primary key columns */
  payment_methods_by_pk?: Maybe<Payment_Methods>;
  /** fetch data from the table: "private_course_booking" */
  private_course_booking: Array<Private_Course_Booking>;
  /** fetch aggregated fields from the table: "private_course_booking" */
  private_course_booking_aggregate: Private_Course_Booking_Aggregate;
  /** fetch data from the table: "private_course_booking" using primary key columns */
  private_course_booking_by_pk?: Maybe<Private_Course_Booking>;
  /** fetch data from the table: "profile" */
  profile: Array<Profile>;
  /** fetch aggregated fields from the table: "profile" */
  profile_aggregate: Profile_Aggregate;
  /** fetch data from the table: "profile" using primary key columns */
  profile_by_pk?: Maybe<Profile>;
  /** fetch data from the table: "profile_role" */
  profile_role: Array<Profile_Role>;
  /** fetch aggregated fields from the table: "profile_role" */
  profile_role_aggregate: Profile_Role_Aggregate;
  /** fetch data from the table: "profile_role" using primary key columns */
  profile_role_by_pk?: Maybe<Profile_Role>;
  /** fetch data from the table: "profile_temp" */
  profile_temp: Array<Profile_Temp>;
  /** fetch aggregated fields from the table: "profile_temp" */
  profile_temp_aggregate: Profile_Temp_Aggregate;
  /** fetch data from the table: "profile_temp" using primary key columns */
  profile_temp_by_pk?: Maybe<Profile_Temp>;
  /** fetch data from the table: "profile_trainer_role_type" */
  profile_trainer_role_type: Array<Profile_Trainer_Role_Type>;
  /** fetch aggregated fields from the table: "profile_trainer_role_type" */
  profile_trainer_role_type_aggregate: Profile_Trainer_Role_Type_Aggregate;
  /** fetch data from the table: "profile_trainer_role_type" using primary key columns */
  profile_trainer_role_type_by_pk?: Maybe<Profile_Trainer_Role_Type>;
  /** fetch data from the table: "promo_code" */
  promo_code: Array<Promo_Code>;
  /** fetch aggregated fields from the table: "promo_code" */
  promo_code_aggregate: Promo_Code_Aggregate;
  /** fetch data from the table: "promo_code" using primary key columns */
  promo_code_by_pk?: Maybe<Promo_Code>;
  /** fetch data from the table: "promo_code_type" */
  promo_code_type: Array<Promo_Code_Type>;
  /** fetch aggregated fields from the table: "promo_code_type" */
  promo_code_type_aggregate: Promo_Code_Type_Aggregate;
  /** fetch data from the table: "promo_code_type" using primary key columns */
  promo_code_type_by_pk?: Maybe<Promo_Code_Type>;
  /** fetch data from the table: "role" */
  role: Array<Role>;
  /** fetch aggregated fields from the table: "role" */
  role_aggregate: Role_Aggregate;
  /** fetch data from the table: "role" using primary key columns */
  role_by_pk?: Maybe<Role>;
  /** fetch data from the table: "trainer_role_type" */
  trainer_role_type: Array<Trainer_Role_Type>;
  /** fetch aggregated fields from the table: "trainer_role_type" */
  trainer_role_type_aggregate: Trainer_Role_Type_Aggregate;
  /** fetch data from the table: "trainer_role_type" using primary key columns */
  trainer_role_type_by_pk?: Maybe<Trainer_Role_Type>;
  /** fetch data from the table: "trust_type" */
  trust_type: Array<Trust_Type>;
  /** fetch aggregated fields from the table: "trust_type" */
  trust_type_aggregate: Trust_Type_Aggregate;
  /** fetch data from the table: "trust_type" using primary key columns */
  trust_type_by_pk?: Maybe<Trust_Type>;
  /** fetch data from the table: "upcoming_enrollments" */
  upcoming_enrollments: Array<Upcoming_Enrollments>;
  /** fetch aggregated fields from the table: "upcoming_enrollments" */
  upcoming_enrollments_aggregate: Upcoming_Enrollments_Aggregate;
  /** fetch data from the table: "venue" */
  venue: Array<Venue>;
  /** fetch aggregated fields from the table: "venue" */
  venue_aggregate: Venue_Aggregate;
  /** fetch data from the table: "venue" using primary key columns */
  venue_by_pk?: Maybe<Venue>;
  /** fetch data from the table: "waitlist" */
  waitlist: Array<Waitlist>;
  /** fetch aggregated fields from the table: "waitlist" */
  waitlist_aggregate: Waitlist_Aggregate;
  /** fetch data from the table: "waitlist" using primary key columns */
  waitlist_by_pk?: Maybe<Waitlist>;
  /** fetch data from the table: "xero_credential" */
  xero_credential: Array<Xero_Credential>;
  /** fetch aggregated fields from the table: "xero_credential" */
  xero_credential_aggregate: Xero_Credential_Aggregate;
  /** fetch data from the table: "xero_credential" using primary key columns */
  xero_credential_by_pk?: Maybe<Xero_Credential>;
};


export type Subscription_RootAvailabilityArgs = {
  distinct_on?: InputMaybe<Array<Availability_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Availability_Order_By>>;
  where?: InputMaybe<Availability_Bool_Exp>;
};


export type Subscription_RootAvailability_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Availability_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Availability_Order_By>>;
  where?: InputMaybe<Availability_Bool_Exp>;
};


export type Subscription_RootAvailability_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootBlended_Learning_StatusArgs = {
  distinct_on?: InputMaybe<Array<Blended_Learning_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Blended_Learning_Status_Order_By>>;
  where?: InputMaybe<Blended_Learning_Status_Bool_Exp>;
};


export type Subscription_RootBlended_Learning_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Blended_Learning_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Blended_Learning_Status_Order_By>>;
  where?: InputMaybe<Blended_Learning_Status_Bool_Exp>;
};


export type Subscription_RootBlended_Learning_Status_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootCertificate_StatusArgs = {
  distinct_on?: InputMaybe<Array<Certificate_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Certificate_Status_Order_By>>;
  where?: InputMaybe<Certificate_Status_Bool_Exp>;
};


export type Subscription_RootCertificate_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Certificate_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Certificate_Status_Order_By>>;
  where?: InputMaybe<Certificate_Status_Bool_Exp>;
};


export type Subscription_RootCertificate_Status_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootColorArgs = {
  distinct_on?: InputMaybe<Array<Color_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Color_Order_By>>;
  where?: InputMaybe<Color_Bool_Exp>;
};


export type Subscription_RootColor_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Color_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Color_Order_By>>;
  where?: InputMaybe<Color_Bool_Exp>;
};


export type Subscription_RootColor_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootCourseArgs = {
  distinct_on?: InputMaybe<Array<Course_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Order_By>>;
  where?: InputMaybe<Course_Bool_Exp>;
};


export type Subscription_RootCourse_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Order_By>>;
  where?: InputMaybe<Course_Bool_Exp>;
};


export type Subscription_RootCourse_AuditArgs = {
  distinct_on?: InputMaybe<Array<Course_Audit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Audit_Order_By>>;
  where?: InputMaybe<Course_Audit_Bool_Exp>;
};


export type Subscription_RootCourse_Audit_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Audit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Audit_Order_By>>;
  where?: InputMaybe<Course_Audit_Bool_Exp>;
};


export type Subscription_RootCourse_Audit_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_Audit_TypeArgs = {
  distinct_on?: InputMaybe<Array<Course_Audit_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Audit_Type_Order_By>>;
  where?: InputMaybe<Course_Audit_Type_Bool_Exp>;
};


export type Subscription_RootCourse_Audit_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Audit_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Audit_Type_Order_By>>;
  where?: InputMaybe<Course_Audit_Type_Bool_Exp>;
};


export type Subscription_RootCourse_Audit_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootCourse_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootCourse_Cancellation_RequestArgs = {
  distinct_on?: InputMaybe<Array<Course_Cancellation_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Cancellation_Request_Order_By>>;
  where?: InputMaybe<Course_Cancellation_Request_Bool_Exp>;
};


export type Subscription_RootCourse_Cancellation_Request_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Cancellation_Request_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Cancellation_Request_Order_By>>;
  where?: InputMaybe<Course_Cancellation_Request_Bool_Exp>;
};


export type Subscription_RootCourse_Cancellation_Request_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_CertificateArgs = {
  distinct_on?: InputMaybe<Array<Course_Certificate_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Certificate_Order_By>>;
  where?: InputMaybe<Course_Certificate_Bool_Exp>;
};


export type Subscription_RootCourse_Certificate_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Certificate_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Certificate_Order_By>>;
  where?: InputMaybe<Course_Certificate_Bool_Exp>;
};


export type Subscription_RootCourse_Certificate_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_Certificate_ChangelogArgs = {
  distinct_on?: InputMaybe<Array<Course_Certificate_Changelog_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Certificate_Changelog_Order_By>>;
  where?: InputMaybe<Course_Certificate_Changelog_Bool_Exp>;
};


export type Subscription_RootCourse_Certificate_Changelog_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Certificate_Changelog_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Certificate_Changelog_Order_By>>;
  where?: InputMaybe<Course_Certificate_Changelog_Bool_Exp>;
};


export type Subscription_RootCourse_Certificate_Changelog_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_Delivery_TypeArgs = {
  distinct_on?: InputMaybe<Array<Course_Delivery_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Delivery_Type_Order_By>>;
  where?: InputMaybe<Course_Delivery_Type_Bool_Exp>;
};


export type Subscription_RootCourse_Delivery_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Delivery_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Delivery_Type_Order_By>>;
  where?: InputMaybe<Course_Delivery_Type_Bool_Exp>;
};


export type Subscription_RootCourse_Delivery_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootCourse_DraftArgs = {
  distinct_on?: InputMaybe<Array<Course_Draft_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Draft_Order_By>>;
  where?: InputMaybe<Course_Draft_Bool_Exp>;
};


export type Subscription_RootCourse_Draft_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Draft_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Draft_Order_By>>;
  where?: InputMaybe<Course_Draft_Bool_Exp>;
};


export type Subscription_RootCourse_Draft_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_End_JobsArgs = {
  distinct_on?: InputMaybe<Array<Course_End_Jobs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_End_Jobs_Order_By>>;
  where?: InputMaybe<Course_End_Jobs_Bool_Exp>;
};


export type Subscription_RootCourse_End_Jobs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_End_Jobs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_End_Jobs_Order_By>>;
  where?: InputMaybe<Course_End_Jobs_Bool_Exp>;
};


export type Subscription_RootCourse_End_Jobs_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_EnquiryArgs = {
  distinct_on?: InputMaybe<Array<Course_Enquiry_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Enquiry_Order_By>>;
  where?: InputMaybe<Course_Enquiry_Bool_Exp>;
};


export type Subscription_RootCourse_Enquiry_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Enquiry_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Enquiry_Order_By>>;
  where?: InputMaybe<Course_Enquiry_Bool_Exp>;
};


export type Subscription_RootCourse_Enquiry_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_Evaluation_AnswersArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Answers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Answers_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Answers_Bool_Exp>;
};


export type Subscription_RootCourse_Evaluation_Answers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Answers_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Answers_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Answers_Bool_Exp>;
};


export type Subscription_RootCourse_Evaluation_Answers_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_Evaluation_Question_GroupArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Question_Group_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Question_Group_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Question_Group_Bool_Exp>;
};


export type Subscription_RootCourse_Evaluation_Question_Group_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Question_Group_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Question_Group_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Question_Group_Bool_Exp>;
};


export type Subscription_RootCourse_Evaluation_Question_Group_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootCourse_Evaluation_Question_TypeArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Question_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Question_Type_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Question_Type_Bool_Exp>;
};


export type Subscription_RootCourse_Evaluation_Question_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Question_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Question_Type_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Question_Type_Bool_Exp>;
};


export type Subscription_RootCourse_Evaluation_Question_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootCourse_Evaluation_QuestionsArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Questions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Questions_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Questions_Bool_Exp>;
};


export type Subscription_RootCourse_Evaluation_Questions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Evaluation_Questions_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Evaluation_Questions_Order_By>>;
  where?: InputMaybe<Course_Evaluation_Questions_Bool_Exp>;
};


export type Subscription_RootCourse_Evaluation_Questions_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_ExpensesArgs = {
  distinct_on?: InputMaybe<Array<Course_Expenses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Expenses_Order_By>>;
  where?: InputMaybe<Course_Expenses_Bool_Exp>;
};


export type Subscription_RootCourse_Expenses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Expenses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Expenses_Order_By>>;
  where?: InputMaybe<Course_Expenses_Bool_Exp>;
};


export type Subscription_RootCourse_Expenses_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_Invite_StatusArgs = {
  distinct_on?: InputMaybe<Array<Course_Invite_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Invite_Status_Order_By>>;
  where?: InputMaybe<Course_Invite_Status_Bool_Exp>;
};


export type Subscription_RootCourse_Invite_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Invite_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Invite_Status_Order_By>>;
  where?: InputMaybe<Course_Invite_Status_Bool_Exp>;
};


export type Subscription_RootCourse_Invite_Status_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootCourse_InvitesArgs = {
  distinct_on?: InputMaybe<Array<Course_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Invites_Order_By>>;
  where?: InputMaybe<Course_Invites_Bool_Exp>;
};


export type Subscription_RootCourse_Invites_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Invites_Order_By>>;
  where?: InputMaybe<Course_Invites_Bool_Exp>;
};


export type Subscription_RootCourse_Invites_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_LevelArgs = {
  distinct_on?: InputMaybe<Array<Course_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Level_Order_By>>;
  where?: InputMaybe<Course_Level_Bool_Exp>;
};


export type Subscription_RootCourse_Level_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Level_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Level_Order_By>>;
  where?: InputMaybe<Course_Level_Bool_Exp>;
};


export type Subscription_RootCourse_Level_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootCourse_Level_PrefixArgs = {
  distinct_on?: InputMaybe<Array<Course_Level_Prefix_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Level_Prefix_Order_By>>;
  where?: InputMaybe<Course_Level_Prefix_Bool_Exp>;
};


export type Subscription_RootCourse_Level_Prefix_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Level_Prefix_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Level_Prefix_Order_By>>;
  where?: InputMaybe<Course_Level_Prefix_Bool_Exp>;
};


export type Subscription_RootCourse_Level_Prefix_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_ModuleArgs = {
  distinct_on?: InputMaybe<Array<Course_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Module_Order_By>>;
  where?: InputMaybe<Course_Module_Bool_Exp>;
};


export type Subscription_RootCourse_Module_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Module_Order_By>>;
  where?: InputMaybe<Course_Module_Bool_Exp>;
};


export type Subscription_RootCourse_Module_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_ParticipantArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Order_By>>;
  where?: InputMaybe<Course_Participant_Bool_Exp>;
};


export type Subscription_RootCourse_Participant_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Order_By>>;
  where?: InputMaybe<Course_Participant_Bool_Exp>;
};


export type Subscription_RootCourse_Participant_AuditArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Audit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Audit_Order_By>>;
  where?: InputMaybe<Course_Participant_Audit_Bool_Exp>;
};


export type Subscription_RootCourse_Participant_Audit_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Audit_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Audit_Order_By>>;
  where?: InputMaybe<Course_Participant_Audit_Bool_Exp>;
};


export type Subscription_RootCourse_Participant_Audit_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_Participant_Audit_TypeArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Audit_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Audit_Type_Order_By>>;
  where?: InputMaybe<Course_Participant_Audit_Type_Bool_Exp>;
};


export type Subscription_RootCourse_Participant_Audit_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Audit_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Audit_Type_Order_By>>;
  where?: InputMaybe<Course_Participant_Audit_Type_Bool_Exp>;
};


export type Subscription_RootCourse_Participant_Audit_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootCourse_Participant_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_Participant_CancellationArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Cancellation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Cancellation_Order_By>>;
  where?: InputMaybe<Course_Participant_Cancellation_Bool_Exp>;
};


export type Subscription_RootCourse_Participant_Cancellation_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Cancellation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Cancellation_Order_By>>;
  where?: InputMaybe<Course_Participant_Cancellation_Bool_Exp>;
};


export type Subscription_RootCourse_Participant_Cancellation_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_Participant_ModuleArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Module_Order_By>>;
  where?: InputMaybe<Course_Participant_Module_Bool_Exp>;
};


export type Subscription_RootCourse_Participant_Module_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Participant_Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Participant_Module_Order_By>>;
  where?: InputMaybe<Course_Participant_Module_Bool_Exp>;
};


export type Subscription_RootCourse_Participant_Module_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_PricingArgs = {
  distinct_on?: InputMaybe<Array<Course_Pricing_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Pricing_Order_By>>;
  where?: InputMaybe<Course_Pricing_Bool_Exp>;
};


export type Subscription_RootCourse_Pricing_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Pricing_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Pricing_Order_By>>;
  where?: InputMaybe<Course_Pricing_Bool_Exp>;
};


export type Subscription_RootCourse_Pricing_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_Promo_CodeArgs = {
  distinct_on?: InputMaybe<Array<Course_Promo_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Promo_Code_Order_By>>;
  where?: InputMaybe<Course_Promo_Code_Bool_Exp>;
};


export type Subscription_RootCourse_Promo_Code_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Promo_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Promo_Code_Order_By>>;
  where?: InputMaybe<Course_Promo_Code_Bool_Exp>;
};


export type Subscription_RootCourse_Promo_Code_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_ScheduleArgs = {
  distinct_on?: InputMaybe<Array<Course_Schedule_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Schedule_Order_By>>;
  where?: InputMaybe<Course_Schedule_Bool_Exp>;
};


export type Subscription_RootCourse_Schedule_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Schedule_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Schedule_Order_By>>;
  where?: InputMaybe<Course_Schedule_Bool_Exp>;
};


export type Subscription_RootCourse_Schedule_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_StatusArgs = {
  distinct_on?: InputMaybe<Array<Course_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Status_Order_By>>;
  where?: InputMaybe<Course_Status_Bool_Exp>;
};


export type Subscription_RootCourse_Status_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Status_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Status_Order_By>>;
  where?: InputMaybe<Course_Status_Bool_Exp>;
};


export type Subscription_RootCourse_Status_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootCourse_TrainerArgs = {
  distinct_on?: InputMaybe<Array<Course_Trainer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Trainer_Order_By>>;
  where?: InputMaybe<Course_Trainer_Bool_Exp>;
};


export type Subscription_RootCourse_Trainer_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Trainer_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Trainer_Order_By>>;
  where?: InputMaybe<Course_Trainer_Bool_Exp>;
};


export type Subscription_RootCourse_Trainer_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCourse_Trainer_TypeArgs = {
  distinct_on?: InputMaybe<Array<Course_Trainer_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Trainer_Type_Order_By>>;
  where?: InputMaybe<Course_Trainer_Type_Bool_Exp>;
};


export type Subscription_RootCourse_Trainer_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Trainer_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Trainer_Type_Order_By>>;
  where?: InputMaybe<Course_Trainer_Type_Bool_Exp>;
};


export type Subscription_RootCourse_Trainer_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootCourse_TypeArgs = {
  distinct_on?: InputMaybe<Array<Course_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Type_Order_By>>;
  where?: InputMaybe<Course_Type_Bool_Exp>;
};


export type Subscription_RootCourse_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Type_Order_By>>;
  where?: InputMaybe<Course_Type_Bool_Exp>;
};


export type Subscription_RootCourse_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootCourse_Type_PrefixArgs = {
  distinct_on?: InputMaybe<Array<Course_Type_Prefix_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Type_Prefix_Order_By>>;
  where?: InputMaybe<Course_Type_Prefix_Bool_Exp>;
};


export type Subscription_RootCourse_Type_Prefix_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Type_Prefix_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Type_Prefix_Order_By>>;
  where?: InputMaybe<Course_Type_Prefix_Bool_Exp>;
};


export type Subscription_RootCourse_Type_Prefix_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootDfe_EstablishmentArgs = {
  distinct_on?: InputMaybe<Array<Dfe_Establishment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Dfe_Establishment_Order_By>>;
  where?: InputMaybe<Dfe_Establishment_Bool_Exp>;
};


export type Subscription_RootDfe_Establishment_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Dfe_Establishment_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Dfe_Establishment_Order_By>>;
  where?: InputMaybe<Dfe_Establishment_Bool_Exp>;
};


export type Subscription_RootDfe_Establishment_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootExpire_Go1_License_JobsArgs = {
  distinct_on?: InputMaybe<Array<Expire_Go1_License_Jobs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Expire_Go1_License_Jobs_Order_By>>;
  where?: InputMaybe<Expire_Go1_License_Jobs_Bool_Exp>;
};


export type Subscription_RootExpire_Go1_License_Jobs_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Expire_Go1_License_Jobs_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Expire_Go1_License_Jobs_Order_By>>;
  where?: InputMaybe<Expire_Go1_License_Jobs_Bool_Exp>;
};


export type Subscription_RootExpire_Go1_License_Jobs_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGo1_History_EventsArgs = {
  distinct_on?: InputMaybe<Array<Go1_History_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_History_Events_Order_By>>;
  where?: InputMaybe<Go1_History_Events_Bool_Exp>;
};


export type Subscription_RootGo1_History_Events_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Go1_History_Events_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_History_Events_Order_By>>;
  where?: InputMaybe<Go1_History_Events_Bool_Exp>;
};


export type Subscription_RootGo1_History_Events_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootGo1_LicensesArgs = {
  distinct_on?: InputMaybe<Array<Go1_Licenses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_Licenses_Order_By>>;
  where?: InputMaybe<Go1_Licenses_Bool_Exp>;
};


export type Subscription_RootGo1_Licenses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Go1_Licenses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_Licenses_Order_By>>;
  where?: InputMaybe<Go1_Licenses_Bool_Exp>;
};


export type Subscription_RootGo1_Licenses_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGo1_Licenses_HistoryArgs = {
  distinct_on?: InputMaybe<Array<Go1_Licenses_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_Licenses_History_Order_By>>;
  where?: InputMaybe<Go1_Licenses_History_Bool_Exp>;
};


export type Subscription_RootGo1_Licenses_History_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Go1_Licenses_History_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Go1_Licenses_History_Order_By>>;
  where?: InputMaybe<Go1_Licenses_History_Bool_Exp>;
};


export type Subscription_RootGo1_Licenses_History_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootGradeArgs = {
  distinct_on?: InputMaybe<Array<Grade_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Grade_Order_By>>;
  where?: InputMaybe<Grade_Bool_Exp>;
};


export type Subscription_RootGrade_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Grade_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Grade_Order_By>>;
  where?: InputMaybe<Grade_Bool_Exp>;
};


export type Subscription_RootGrade_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootIdentityArgs = {
  distinct_on?: InputMaybe<Array<Identity_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Identity_Order_By>>;
  where?: InputMaybe<Identity_Bool_Exp>;
};


export type Subscription_RootIdentity_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Identity_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Identity_Order_By>>;
  where?: InputMaybe<Identity_Bool_Exp>;
};


export type Subscription_RootIdentity_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootIdentity_TypeArgs = {
  distinct_on?: InputMaybe<Array<Identity_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Identity_Type_Order_By>>;
  where?: InputMaybe<Identity_Type_Bool_Exp>;
};


export type Subscription_RootIdentity_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Identity_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Identity_Type_Order_By>>;
  where?: InputMaybe<Identity_Type_Bool_Exp>;
};


export type Subscription_RootIdentity_Type_By_PkArgs = {
  value: Scalars['String'];
};


export type Subscription_RootLegacy_CertificateArgs = {
  distinct_on?: InputMaybe<Array<Legacy_Certificate_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Legacy_Certificate_Order_By>>;
  where?: InputMaybe<Legacy_Certificate_Bool_Exp>;
};


export type Subscription_RootLegacy_Certificate_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Legacy_Certificate_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Legacy_Certificate_Order_By>>;
  where?: InputMaybe<Legacy_Certificate_Bool_Exp>;
};


export type Subscription_RootLegacy_Certificate_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootModuleArgs = {
  distinct_on?: InputMaybe<Array<Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Order_By>>;
  where?: InputMaybe<Module_Bool_Exp>;
};


export type Subscription_RootModule_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Order_By>>;
  where?: InputMaybe<Module_Bool_Exp>;
};


export type Subscription_RootModule_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootModule_CategoryArgs = {
  distinct_on?: InputMaybe<Array<Module_Category_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Category_Order_By>>;
  where?: InputMaybe<Module_Category_Bool_Exp>;
};


export type Subscription_RootModule_Category_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Category_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Category_Order_By>>;
  where?: InputMaybe<Module_Category_Bool_Exp>;
};


export type Subscription_RootModule_Category_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootModule_GroupArgs = {
  distinct_on?: InputMaybe<Array<Module_Group_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Group_Order_By>>;
  where?: InputMaybe<Module_Group_Bool_Exp>;
};


export type Subscription_RootModule_Group_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Group_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Group_Order_By>>;
  where?: InputMaybe<Module_Group_Bool_Exp>;
};


export type Subscription_RootModule_Group_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootModule_Group_DurationArgs = {
  distinct_on?: InputMaybe<Array<Module_Group_Duration_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Group_Duration_Order_By>>;
  where?: InputMaybe<Module_Group_Duration_Bool_Exp>;
};


export type Subscription_RootModule_Group_Duration_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Module_Group_Duration_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Module_Group_Duration_Order_By>>;
  where?: InputMaybe<Module_Group_Duration_Bool_Exp>;
};


export type Subscription_RootModule_Group_Duration_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootOrderArgs = {
  distinct_on?: InputMaybe<Array<Order_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Order_Order_By>>;
  where?: InputMaybe<Order_Bool_Exp>;
};


export type Subscription_RootOrder_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Order_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Order_Order_By>>;
  where?: InputMaybe<Order_Bool_Exp>;
};


export type Subscription_RootOrder_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootOrganizationArgs = {
  distinct_on?: InputMaybe<Array<Organization_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Order_By>>;
  where?: InputMaybe<Organization_Bool_Exp>;
};


export type Subscription_RootOrganization_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Order_By>>;
  where?: InputMaybe<Organization_Bool_Exp>;
};


export type Subscription_RootOrganization_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootOrganization_InvitesArgs = {
  distinct_on?: InputMaybe<Array<Organization_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Invites_Order_By>>;
  where?: InputMaybe<Organization_Invites_Bool_Exp>;
};


export type Subscription_RootOrganization_Invites_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Invites_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Invites_Order_By>>;
  where?: InputMaybe<Organization_Invites_Bool_Exp>;
};


export type Subscription_RootOrganization_Invites_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootOrganization_MemberArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Order_By>>;
  where?: InputMaybe<Organization_Member_Bool_Exp>;
};


export type Subscription_RootOrganization_Member_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Organization_Member_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Organization_Member_Order_By>>;
  where?: InputMaybe<Organization_Member_Bool_Exp>;
};


export type Subscription_RootOrganization_Member_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPayment_MethodsArgs = {
  distinct_on?: InputMaybe<Array<Payment_Methods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Payment_Methods_Order_By>>;
  where?: InputMaybe<Payment_Methods_Bool_Exp>;
};


export type Subscription_RootPayment_Methods_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Payment_Methods_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Payment_Methods_Order_By>>;
  where?: InputMaybe<Payment_Methods_Bool_Exp>;
};


export type Subscription_RootPayment_Methods_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootPrivate_Course_BookingArgs = {
  distinct_on?: InputMaybe<Array<Private_Course_Booking_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Private_Course_Booking_Order_By>>;
  where?: InputMaybe<Private_Course_Booking_Bool_Exp>;
};


export type Subscription_RootPrivate_Course_Booking_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Private_Course_Booking_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Private_Course_Booking_Order_By>>;
  where?: InputMaybe<Private_Course_Booking_Bool_Exp>;
};


export type Subscription_RootPrivate_Course_Booking_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootProfileArgs = {
  distinct_on?: InputMaybe<Array<Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Order_By>>;
  where?: InputMaybe<Profile_Bool_Exp>;
};


export type Subscription_RootProfile_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Order_By>>;
  where?: InputMaybe<Profile_Bool_Exp>;
};


export type Subscription_RootProfile_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootProfile_RoleArgs = {
  distinct_on?: InputMaybe<Array<Profile_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Role_Order_By>>;
  where?: InputMaybe<Profile_Role_Bool_Exp>;
};


export type Subscription_RootProfile_Role_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Role_Order_By>>;
  where?: InputMaybe<Profile_Role_Bool_Exp>;
};


export type Subscription_RootProfile_Role_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootProfile_TempArgs = {
  distinct_on?: InputMaybe<Array<Profile_Temp_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Temp_Order_By>>;
  where?: InputMaybe<Profile_Temp_Bool_Exp>;
};


export type Subscription_RootProfile_Temp_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Temp_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Temp_Order_By>>;
  where?: InputMaybe<Profile_Temp_Bool_Exp>;
};


export type Subscription_RootProfile_Temp_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootProfile_Trainer_Role_TypeArgs = {
  distinct_on?: InputMaybe<Array<Profile_Trainer_Role_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Trainer_Role_Type_Order_By>>;
  where?: InputMaybe<Profile_Trainer_Role_Type_Bool_Exp>;
};


export type Subscription_RootProfile_Trainer_Role_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Trainer_Role_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Trainer_Role_Type_Order_By>>;
  where?: InputMaybe<Profile_Trainer_Role_Type_Bool_Exp>;
};


export type Subscription_RootProfile_Trainer_Role_Type_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPromo_CodeArgs = {
  distinct_on?: InputMaybe<Array<Promo_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Promo_Code_Order_By>>;
  where?: InputMaybe<Promo_Code_Bool_Exp>;
};


export type Subscription_RootPromo_Code_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Promo_Code_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Promo_Code_Order_By>>;
  where?: InputMaybe<Promo_Code_Bool_Exp>;
};


export type Subscription_RootPromo_Code_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPromo_Code_TypeArgs = {
  distinct_on?: InputMaybe<Array<Promo_Code_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Promo_Code_Type_Order_By>>;
  where?: InputMaybe<Promo_Code_Type_Bool_Exp>;
};


export type Subscription_RootPromo_Code_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Promo_Code_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Promo_Code_Type_Order_By>>;
  where?: InputMaybe<Promo_Code_Type_Bool_Exp>;
};


export type Subscription_RootPromo_Code_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootRoleArgs = {
  distinct_on?: InputMaybe<Array<Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Role_Order_By>>;
  where?: InputMaybe<Role_Bool_Exp>;
};


export type Subscription_RootRole_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Role_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Role_Order_By>>;
  where?: InputMaybe<Role_Bool_Exp>;
};


export type Subscription_RootRole_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootTrainer_Role_TypeArgs = {
  distinct_on?: InputMaybe<Array<Trainer_Role_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Trainer_Role_Type_Order_By>>;
  where?: InputMaybe<Trainer_Role_Type_Bool_Exp>;
};


export type Subscription_RootTrainer_Role_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Trainer_Role_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Trainer_Role_Type_Order_By>>;
  where?: InputMaybe<Trainer_Role_Type_Bool_Exp>;
};


export type Subscription_RootTrainer_Role_Type_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootTrust_TypeArgs = {
  distinct_on?: InputMaybe<Array<Trust_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Trust_Type_Order_By>>;
  where?: InputMaybe<Trust_Type_Bool_Exp>;
};


export type Subscription_RootTrust_Type_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Trust_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Trust_Type_Order_By>>;
  where?: InputMaybe<Trust_Type_Bool_Exp>;
};


export type Subscription_RootTrust_Type_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootUpcoming_EnrollmentsArgs = {
  distinct_on?: InputMaybe<Array<Upcoming_Enrollments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Upcoming_Enrollments_Order_By>>;
  where?: InputMaybe<Upcoming_Enrollments_Bool_Exp>;
};


export type Subscription_RootUpcoming_Enrollments_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Upcoming_Enrollments_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Upcoming_Enrollments_Order_By>>;
  where?: InputMaybe<Upcoming_Enrollments_Bool_Exp>;
};


export type Subscription_RootVenueArgs = {
  distinct_on?: InputMaybe<Array<Venue_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Venue_Order_By>>;
  where?: InputMaybe<Venue_Bool_Exp>;
};


export type Subscription_RootVenue_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Venue_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Venue_Order_By>>;
  where?: InputMaybe<Venue_Bool_Exp>;
};


export type Subscription_RootVenue_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootWaitlistArgs = {
  distinct_on?: InputMaybe<Array<Waitlist_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Waitlist_Order_By>>;
  where?: InputMaybe<Waitlist_Bool_Exp>;
};


export type Subscription_RootWaitlist_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Waitlist_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Waitlist_Order_By>>;
  where?: InputMaybe<Waitlist_Bool_Exp>;
};


export type Subscription_RootWaitlist_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootXero_CredentialArgs = {
  distinct_on?: InputMaybe<Array<Xero_Credential_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Xero_Credential_Order_By>>;
  where?: InputMaybe<Xero_Credential_Bool_Exp>;
};


export type Subscription_RootXero_Credential_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Xero_Credential_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Xero_Credential_Order_By>>;
  where?: InputMaybe<Xero_Credential_Bool_Exp>;
};


export type Subscription_RootXero_Credential_By_PkArgs = {
  client_id: Scalars['String'];
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type Timestamp_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamp']>;
  _gt?: InputMaybe<Scalars['timestamp']>;
  _gte?: InputMaybe<Scalars['timestamp']>;
  _in?: InputMaybe<Array<Scalars['timestamp']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['timestamp']>;
  _lte?: InputMaybe<Scalars['timestamp']>;
  _neq?: InputMaybe<Scalars['timestamp']>;
  _nin?: InputMaybe<Array<Scalars['timestamp']>>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamptz']>;
  _gt?: InputMaybe<Scalars['timestamptz']>;
  _gte?: InputMaybe<Scalars['timestamptz']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['timestamptz']>;
  _lte?: InputMaybe<Scalars['timestamptz']>;
  _neq?: InputMaybe<Scalars['timestamptz']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']>>;
};

/** Trainer role types */
export type Trainer_Role_Type = {
  __typename?: 'trainer_role_type';
  id: Scalars['uuid'];
  name: Scalars['String'];
  /** An array relationship */
  profiles: Array<Profile_Trainer_Role_Type>;
  /** An aggregate relationship */
  profiles_aggregate: Profile_Trainer_Role_Type_Aggregate;
};


/** Trainer role types */
export type Trainer_Role_TypeProfilesArgs = {
  distinct_on?: InputMaybe<Array<Profile_Trainer_Role_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Trainer_Role_Type_Order_By>>;
  where?: InputMaybe<Profile_Trainer_Role_Type_Bool_Exp>;
};


/** Trainer role types */
export type Trainer_Role_TypeProfiles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Profile_Trainer_Role_Type_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Profile_Trainer_Role_Type_Order_By>>;
  where?: InputMaybe<Profile_Trainer_Role_Type_Bool_Exp>;
};

/** aggregated selection of "trainer_role_type" */
export type Trainer_Role_Type_Aggregate = {
  __typename?: 'trainer_role_type_aggregate';
  aggregate?: Maybe<Trainer_Role_Type_Aggregate_Fields>;
  nodes: Array<Trainer_Role_Type>;
};

/** aggregate fields of "trainer_role_type" */
export type Trainer_Role_Type_Aggregate_Fields = {
  __typename?: 'trainer_role_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Trainer_Role_Type_Max_Fields>;
  min?: Maybe<Trainer_Role_Type_Min_Fields>;
};


/** aggregate fields of "trainer_role_type" */
export type Trainer_Role_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Trainer_Role_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "trainer_role_type". All fields are combined with a logical 'AND'. */
export type Trainer_Role_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Trainer_Role_Type_Bool_Exp>>;
  _not?: InputMaybe<Trainer_Role_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Trainer_Role_Type_Bool_Exp>>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  profiles?: InputMaybe<Profile_Trainer_Role_Type_Bool_Exp>;
};

/** unique or primary key constraints on table "trainer_role_type" */
export enum Trainer_Role_Type_Constraint {
  /** unique or primary key constraint */
  TrainerRoleTypeNameKey = 'trainer_role_type_name_key',
  /** unique or primary key constraint */
  TrainerRoleTypePkey = 'trainer_role_type_pkey'
}

/** input type for inserting data into table "trainer_role_type" */
export type Trainer_Role_Type_Insert_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  profiles?: InputMaybe<Profile_Trainer_Role_Type_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Trainer_Role_Type_Max_Fields = {
  __typename?: 'trainer_role_type_max_fields';
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Trainer_Role_Type_Min_Fields = {
  __typename?: 'trainer_role_type_min_fields';
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "trainer_role_type" */
export type Trainer_Role_Type_Mutation_Response = {
  __typename?: 'trainer_role_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Trainer_Role_Type>;
};

/** input type for inserting object relation for remote table "trainer_role_type" */
export type Trainer_Role_Type_Obj_Rel_Insert_Input = {
  data: Trainer_Role_Type_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Trainer_Role_Type_On_Conflict>;
};

/** on_conflict condition type for table "trainer_role_type" */
export type Trainer_Role_Type_On_Conflict = {
  constraint: Trainer_Role_Type_Constraint;
  update_columns?: Array<Trainer_Role_Type_Update_Column>;
  where?: InputMaybe<Trainer_Role_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "trainer_role_type". */
export type Trainer_Role_Type_Order_By = {
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  profiles_aggregate?: InputMaybe<Profile_Trainer_Role_Type_Aggregate_Order_By>;
};

/** primary key columns input for table: trainer_role_type */
export type Trainer_Role_Type_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "trainer_role_type" */
export enum Trainer_Role_Type_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "trainer_role_type" */
export type Trainer_Role_Type_Set_Input = {
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "trainer_role_type" */
export enum Trainer_Role_Type_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "trust_type" */
export type Trust_Type = {
  __typename?: 'trust_type';
  name: Scalars['String'];
};

/** aggregated selection of "trust_type" */
export type Trust_Type_Aggregate = {
  __typename?: 'trust_type_aggregate';
  aggregate?: Maybe<Trust_Type_Aggregate_Fields>;
  nodes: Array<Trust_Type>;
};

/** aggregate fields of "trust_type" */
export type Trust_Type_Aggregate_Fields = {
  __typename?: 'trust_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Trust_Type_Max_Fields>;
  min?: Maybe<Trust_Type_Min_Fields>;
};


/** aggregate fields of "trust_type" */
export type Trust_Type_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Trust_Type_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "trust_type". All fields are combined with a logical 'AND'. */
export type Trust_Type_Bool_Exp = {
  _and?: InputMaybe<Array<Trust_Type_Bool_Exp>>;
  _not?: InputMaybe<Trust_Type_Bool_Exp>;
  _or?: InputMaybe<Array<Trust_Type_Bool_Exp>>;
  name?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "trust_type" */
export enum Trust_Type_Constraint {
  /** unique or primary key constraint */
  TrustTypePkey = 'trust_type_pkey'
}

export enum Trust_Type_Enum {
  MultiAcademyTrust = 'MULTI_ACADEMY_TRUST',
  NotApplicable = 'NOT_APPLICABLE',
  SingleAcademyTrust = 'SINGLE_ACADEMY_TRUST',
  SupportedByATrust = 'SUPPORTED_BY_A_TRUST'
}

/** Boolean expression to compare columns of type "trust_type_enum". All fields are combined with logical 'AND'. */
export type Trust_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Trust_Type_Enum>;
  _in?: InputMaybe<Array<Trust_Type_Enum>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Trust_Type_Enum>;
  _nin?: InputMaybe<Array<Trust_Type_Enum>>;
};

/** input type for inserting data into table "trust_type" */
export type Trust_Type_Insert_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Trust_Type_Max_Fields = {
  __typename?: 'trust_type_max_fields';
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Trust_Type_Min_Fields = {
  __typename?: 'trust_type_min_fields';
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "trust_type" */
export type Trust_Type_Mutation_Response = {
  __typename?: 'trust_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Trust_Type>;
};

/** on_conflict condition type for table "trust_type" */
export type Trust_Type_On_Conflict = {
  constraint: Trust_Type_Constraint;
  update_columns?: Array<Trust_Type_Update_Column>;
  where?: InputMaybe<Trust_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "trust_type". */
export type Trust_Type_Order_By = {
  name?: InputMaybe<Order_By>;
};

/** primary key columns input for table: trust_type */
export type Trust_Type_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "trust_type" */
export enum Trust_Type_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "trust_type" */
export type Trust_Type_Set_Input = {
  name?: InputMaybe<Scalars['String']>;
};

/** update columns of table "trust_type" */
export enum Trust_Type_Update_Column {
  /** column name */
  Name = 'name'
}

/** columns and relationships of "upcoming_enrollments" */
export type Upcoming_Enrollments = {
  __typename?: 'upcoming_enrollments';
  courseId?: Maybe<Scalars['Int']>;
  courseLevel?: Maybe<Scalars['String']>;
  orgId?: Maybe<Scalars['uuid']>;
  orgName?: Maybe<Scalars['String']>;
  /** An object relationship */
  profile?: Maybe<Profile>;
  profileId?: Maybe<Scalars['uuid']>;
  scheduleStart?: Maybe<Scalars['timestamptz']>;
};

/** aggregated selection of "upcoming_enrollments" */
export type Upcoming_Enrollments_Aggregate = {
  __typename?: 'upcoming_enrollments_aggregate';
  aggregate?: Maybe<Upcoming_Enrollments_Aggregate_Fields>;
  nodes: Array<Upcoming_Enrollments>;
};

/** aggregate fields of "upcoming_enrollments" */
export type Upcoming_Enrollments_Aggregate_Fields = {
  __typename?: 'upcoming_enrollments_aggregate_fields';
  avg?: Maybe<Upcoming_Enrollments_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Upcoming_Enrollments_Max_Fields>;
  min?: Maybe<Upcoming_Enrollments_Min_Fields>;
  stddev?: Maybe<Upcoming_Enrollments_Stddev_Fields>;
  stddev_pop?: Maybe<Upcoming_Enrollments_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Upcoming_Enrollments_Stddev_Samp_Fields>;
  sum?: Maybe<Upcoming_Enrollments_Sum_Fields>;
  var_pop?: Maybe<Upcoming_Enrollments_Var_Pop_Fields>;
  var_samp?: Maybe<Upcoming_Enrollments_Var_Samp_Fields>;
  variance?: Maybe<Upcoming_Enrollments_Variance_Fields>;
};


/** aggregate fields of "upcoming_enrollments" */
export type Upcoming_Enrollments_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Upcoming_Enrollments_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "upcoming_enrollments" */
export type Upcoming_Enrollments_Aggregate_Order_By = {
  avg?: InputMaybe<Upcoming_Enrollments_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Upcoming_Enrollments_Max_Order_By>;
  min?: InputMaybe<Upcoming_Enrollments_Min_Order_By>;
  stddev?: InputMaybe<Upcoming_Enrollments_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Upcoming_Enrollments_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Upcoming_Enrollments_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Upcoming_Enrollments_Sum_Order_By>;
  var_pop?: InputMaybe<Upcoming_Enrollments_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Upcoming_Enrollments_Var_Samp_Order_By>;
  variance?: InputMaybe<Upcoming_Enrollments_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "upcoming_enrollments" */
export type Upcoming_Enrollments_Arr_Rel_Insert_Input = {
  data: Array<Upcoming_Enrollments_Insert_Input>;
};

/** aggregate avg on columns */
export type Upcoming_Enrollments_Avg_Fields = {
  __typename?: 'upcoming_enrollments_avg_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "upcoming_enrollments" */
export type Upcoming_Enrollments_Avg_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "upcoming_enrollments". All fields are combined with a logical 'AND'. */
export type Upcoming_Enrollments_Bool_Exp = {
  _and?: InputMaybe<Array<Upcoming_Enrollments_Bool_Exp>>;
  _not?: InputMaybe<Upcoming_Enrollments_Bool_Exp>;
  _or?: InputMaybe<Array<Upcoming_Enrollments_Bool_Exp>>;
  courseId?: InputMaybe<Int_Comparison_Exp>;
  courseLevel?: InputMaybe<String_Comparison_Exp>;
  orgId?: InputMaybe<Uuid_Comparison_Exp>;
  orgName?: InputMaybe<String_Comparison_Exp>;
  profile?: InputMaybe<Profile_Bool_Exp>;
  profileId?: InputMaybe<Uuid_Comparison_Exp>;
  scheduleStart?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** input type for inserting data into table "upcoming_enrollments" */
export type Upcoming_Enrollments_Insert_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
  courseLevel?: InputMaybe<Scalars['String']>;
  orgId?: InputMaybe<Scalars['uuid']>;
  orgName?: InputMaybe<Scalars['String']>;
  profile?: InputMaybe<Profile_Obj_Rel_Insert_Input>;
  profileId?: InputMaybe<Scalars['uuid']>;
  scheduleStart?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Upcoming_Enrollments_Max_Fields = {
  __typename?: 'upcoming_enrollments_max_fields';
  courseId?: Maybe<Scalars['Int']>;
  courseLevel?: Maybe<Scalars['String']>;
  orgId?: Maybe<Scalars['uuid']>;
  orgName?: Maybe<Scalars['String']>;
  profileId?: Maybe<Scalars['uuid']>;
  scheduleStart?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "upcoming_enrollments" */
export type Upcoming_Enrollments_Max_Order_By = {
  courseId?: InputMaybe<Order_By>;
  courseLevel?: InputMaybe<Order_By>;
  orgId?: InputMaybe<Order_By>;
  orgName?: InputMaybe<Order_By>;
  profileId?: InputMaybe<Order_By>;
  scheduleStart?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Upcoming_Enrollments_Min_Fields = {
  __typename?: 'upcoming_enrollments_min_fields';
  courseId?: Maybe<Scalars['Int']>;
  courseLevel?: Maybe<Scalars['String']>;
  orgId?: Maybe<Scalars['uuid']>;
  orgName?: Maybe<Scalars['String']>;
  profileId?: Maybe<Scalars['uuid']>;
  scheduleStart?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "upcoming_enrollments" */
export type Upcoming_Enrollments_Min_Order_By = {
  courseId?: InputMaybe<Order_By>;
  courseLevel?: InputMaybe<Order_By>;
  orgId?: InputMaybe<Order_By>;
  orgName?: InputMaybe<Order_By>;
  profileId?: InputMaybe<Order_By>;
  scheduleStart?: InputMaybe<Order_By>;
};

/** Ordering options when selecting data from "upcoming_enrollments". */
export type Upcoming_Enrollments_Order_By = {
  courseId?: InputMaybe<Order_By>;
  courseLevel?: InputMaybe<Order_By>;
  orgId?: InputMaybe<Order_By>;
  orgName?: InputMaybe<Order_By>;
  profile?: InputMaybe<Profile_Order_By>;
  profileId?: InputMaybe<Order_By>;
  scheduleStart?: InputMaybe<Order_By>;
};

/** select columns of table "upcoming_enrollments" */
export enum Upcoming_Enrollments_Select_Column {
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CourseLevel = 'courseLevel',
  /** column name */
  OrgId = 'orgId',
  /** column name */
  OrgName = 'orgName',
  /** column name */
  ProfileId = 'profileId',
  /** column name */
  ScheduleStart = 'scheduleStart'
}

/** aggregate stddev on columns */
export type Upcoming_Enrollments_Stddev_Fields = {
  __typename?: 'upcoming_enrollments_stddev_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "upcoming_enrollments" */
export type Upcoming_Enrollments_Stddev_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Upcoming_Enrollments_Stddev_Pop_Fields = {
  __typename?: 'upcoming_enrollments_stddev_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "upcoming_enrollments" */
export type Upcoming_Enrollments_Stddev_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Upcoming_Enrollments_Stddev_Samp_Fields = {
  __typename?: 'upcoming_enrollments_stddev_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "upcoming_enrollments" */
export type Upcoming_Enrollments_Stddev_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Upcoming_Enrollments_Sum_Fields = {
  __typename?: 'upcoming_enrollments_sum_fields';
  courseId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "upcoming_enrollments" */
export type Upcoming_Enrollments_Sum_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate var_pop on columns */
export type Upcoming_Enrollments_Var_Pop_Fields = {
  __typename?: 'upcoming_enrollments_var_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "upcoming_enrollments" */
export type Upcoming_Enrollments_Var_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Upcoming_Enrollments_Var_Samp_Fields = {
  __typename?: 'upcoming_enrollments_var_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "upcoming_enrollments" */
export type Upcoming_Enrollments_Var_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Upcoming_Enrollments_Variance_Fields = {
  __typename?: 'upcoming_enrollments_variance_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "upcoming_enrollments" */
export type Upcoming_Enrollments_Variance_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['uuid']>;
  _gt?: InputMaybe<Scalars['uuid']>;
  _gte?: InputMaybe<Scalars['uuid']>;
  _in?: InputMaybe<Array<Scalars['uuid']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['uuid']>;
  _lte?: InputMaybe<Scalars['uuid']>;
  _neq?: InputMaybe<Scalars['uuid']>;
  _nin?: InputMaybe<Array<Scalars['uuid']>>;
};

/** columns and relationships of "venue" */
export type Venue = {
  __typename?: 'venue';
  addressLineOne: Scalars['String'];
  addressLineTwo?: Maybe<Scalars['String']>;
  city: Scalars['String'];
  createdAt: Scalars['timestamptz'];
  geoCoordinates?: Maybe<Scalars['point']>;
  googlePlacesId?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  name: Scalars['String'];
  postCode: Scalars['String'];
  /** An array relationship */
  schedule: Array<Course_Schedule>;
  /** An aggregate relationship */
  schedule_aggregate: Course_Schedule_Aggregate;
  updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "venue" */
export type VenueScheduleArgs = {
  distinct_on?: InputMaybe<Array<Course_Schedule_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Schedule_Order_By>>;
  where?: InputMaybe<Course_Schedule_Bool_Exp>;
};


/** columns and relationships of "venue" */
export type VenueSchedule_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Course_Schedule_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Course_Schedule_Order_By>>;
  where?: InputMaybe<Course_Schedule_Bool_Exp>;
};

/** aggregated selection of "venue" */
export type Venue_Aggregate = {
  __typename?: 'venue_aggregate';
  aggregate?: Maybe<Venue_Aggregate_Fields>;
  nodes: Array<Venue>;
};

/** aggregate fields of "venue" */
export type Venue_Aggregate_Fields = {
  __typename?: 'venue_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Venue_Max_Fields>;
  min?: Maybe<Venue_Min_Fields>;
};


/** aggregate fields of "venue" */
export type Venue_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Venue_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "venue". All fields are combined with a logical 'AND'. */
export type Venue_Bool_Exp = {
  _and?: InputMaybe<Array<Venue_Bool_Exp>>;
  _not?: InputMaybe<Venue_Bool_Exp>;
  _or?: InputMaybe<Array<Venue_Bool_Exp>>;
  addressLineOne?: InputMaybe<String_Comparison_Exp>;
  addressLineTwo?: InputMaybe<String_Comparison_Exp>;
  city?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  geoCoordinates?: InputMaybe<Point_Comparison_Exp>;
  googlePlacesId?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  postCode?: InputMaybe<String_Comparison_Exp>;
  schedule?: InputMaybe<Course_Schedule_Bool_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "venue" */
export enum Venue_Constraint {
  /** unique or primary key constraint */
  VenuePkey = 'venue_pkey'
}

/** input type for inserting data into table "venue" */
export type Venue_Insert_Input = {
  addressLineOne?: InputMaybe<Scalars['String']>;
  addressLineTwo?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  geoCoordinates?: InputMaybe<Scalars['point']>;
  googlePlacesId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  postCode?: InputMaybe<Scalars['String']>;
  schedule?: InputMaybe<Course_Schedule_Arr_Rel_Insert_Input>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Venue_Max_Fields = {
  __typename?: 'venue_max_fields';
  addressLineOne?: Maybe<Scalars['String']>;
  addressLineTwo?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  googlePlacesId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  postCode?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Venue_Min_Fields = {
  __typename?: 'venue_min_fields';
  addressLineOne?: Maybe<Scalars['String']>;
  addressLineTwo?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  googlePlacesId?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  postCode?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "venue" */
export type Venue_Mutation_Response = {
  __typename?: 'venue_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Venue>;
};

/** input type for inserting object relation for remote table "venue" */
export type Venue_Obj_Rel_Insert_Input = {
  data: Venue_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Venue_On_Conflict>;
};

/** on_conflict condition type for table "venue" */
export type Venue_On_Conflict = {
  constraint: Venue_Constraint;
  update_columns?: Array<Venue_Update_Column>;
  where?: InputMaybe<Venue_Bool_Exp>;
};

/** Ordering options when selecting data from "venue". */
export type Venue_Order_By = {
  addressLineOne?: InputMaybe<Order_By>;
  addressLineTwo?: InputMaybe<Order_By>;
  city?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  geoCoordinates?: InputMaybe<Order_By>;
  googlePlacesId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  postCode?: InputMaybe<Order_By>;
  schedule_aggregate?: InputMaybe<Course_Schedule_Aggregate_Order_By>;
  updatedAt?: InputMaybe<Order_By>;
};

/** primary key columns input for table: venue */
export type Venue_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "venue" */
export enum Venue_Select_Column {
  /** column name */
  AddressLineOne = 'addressLineOne',
  /** column name */
  AddressLineTwo = 'addressLineTwo',
  /** column name */
  City = 'city',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GeoCoordinates = 'geoCoordinates',
  /** column name */
  GooglePlacesId = 'googlePlacesId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PostCode = 'postCode',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "venue" */
export type Venue_Set_Input = {
  addressLineOne?: InputMaybe<Scalars['String']>;
  addressLineTwo?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  geoCoordinates?: InputMaybe<Scalars['point']>;
  googlePlacesId?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  name?: InputMaybe<Scalars['String']>;
  postCode?: InputMaybe<Scalars['String']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']>;
};

/** update columns of table "venue" */
export enum Venue_Update_Column {
  /** column name */
  AddressLineOne = 'addressLineOne',
  /** column name */
  AddressLineTwo = 'addressLineTwo',
  /** column name */
  City = 'city',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GeoCoordinates = 'geoCoordinates',
  /** column name */
  GooglePlacesId = 'googlePlacesId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PostCode = 'postCode',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "waitlist" */
export type Waitlist = {
  __typename?: 'waitlist';
  confirmed: Scalars['Boolean'];
  /** An object relationship */
  course: Course;
  courseId: Scalars['Int'];
  createdAt: Scalars['timestamptz'];
  email: Scalars['String'];
  familyName: Scalars['String'];
  givenName: Scalars['String'];
  id: Scalars['uuid'];
  orgName: Scalars['String'];
  phone: Scalars['String'];
};

/** aggregated selection of "waitlist" */
export type Waitlist_Aggregate = {
  __typename?: 'waitlist_aggregate';
  aggregate?: Maybe<Waitlist_Aggregate_Fields>;
  nodes: Array<Waitlist>;
};

/** aggregate fields of "waitlist" */
export type Waitlist_Aggregate_Fields = {
  __typename?: 'waitlist_aggregate_fields';
  avg?: Maybe<Waitlist_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Waitlist_Max_Fields>;
  min?: Maybe<Waitlist_Min_Fields>;
  stddev?: Maybe<Waitlist_Stddev_Fields>;
  stddev_pop?: Maybe<Waitlist_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Waitlist_Stddev_Samp_Fields>;
  sum?: Maybe<Waitlist_Sum_Fields>;
  var_pop?: Maybe<Waitlist_Var_Pop_Fields>;
  var_samp?: Maybe<Waitlist_Var_Samp_Fields>;
  variance?: Maybe<Waitlist_Variance_Fields>;
};


/** aggregate fields of "waitlist" */
export type Waitlist_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Waitlist_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "waitlist" */
export type Waitlist_Aggregate_Order_By = {
  avg?: InputMaybe<Waitlist_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Waitlist_Max_Order_By>;
  min?: InputMaybe<Waitlist_Min_Order_By>;
  stddev?: InputMaybe<Waitlist_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Waitlist_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Waitlist_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Waitlist_Sum_Order_By>;
  var_pop?: InputMaybe<Waitlist_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Waitlist_Var_Samp_Order_By>;
  variance?: InputMaybe<Waitlist_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "waitlist" */
export type Waitlist_Arr_Rel_Insert_Input = {
  data: Array<Waitlist_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Waitlist_On_Conflict>;
};

/** aggregate avg on columns */
export type Waitlist_Avg_Fields = {
  __typename?: 'waitlist_avg_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "waitlist" */
export type Waitlist_Avg_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "waitlist". All fields are combined with a logical 'AND'. */
export type Waitlist_Bool_Exp = {
  _and?: InputMaybe<Array<Waitlist_Bool_Exp>>;
  _not?: InputMaybe<Waitlist_Bool_Exp>;
  _or?: InputMaybe<Array<Waitlist_Bool_Exp>>;
  confirmed?: InputMaybe<Boolean_Comparison_Exp>;
  course?: InputMaybe<Course_Bool_Exp>;
  courseId?: InputMaybe<Int_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  familyName?: InputMaybe<String_Comparison_Exp>;
  givenName?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  orgName?: InputMaybe<String_Comparison_Exp>;
  phone?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "waitlist" */
export enum Waitlist_Constraint {
  /** unique or primary key constraint */
  WaitlistCourseIdEmailKey = 'waitlist_course_id_email_key',
  /** unique or primary key constraint */
  WaitlistPkey = 'waitlist_pkey'
}

/** input type for incrementing numeric columns in table "waitlist" */
export type Waitlist_Inc_Input = {
  courseId?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "waitlist" */
export type Waitlist_Insert_Input = {
  confirmed?: InputMaybe<Scalars['Boolean']>;
  course?: InputMaybe<Course_Obj_Rel_Insert_Input>;
  courseId?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  familyName?: InputMaybe<Scalars['String']>;
  givenName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  orgName?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Waitlist_Max_Fields = {
  __typename?: 'waitlist_max_fields';
  courseId?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  givenName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  orgName?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "waitlist" */
export type Waitlist_Max_Order_By = {
  courseId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  familyName?: InputMaybe<Order_By>;
  givenName?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  orgName?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Waitlist_Min_Fields = {
  __typename?: 'waitlist_min_fields';
  courseId?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  familyName?: Maybe<Scalars['String']>;
  givenName?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  orgName?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "waitlist" */
export type Waitlist_Min_Order_By = {
  courseId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  familyName?: InputMaybe<Order_By>;
  givenName?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  orgName?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "waitlist" */
export type Waitlist_Mutation_Response = {
  __typename?: 'waitlist_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Waitlist>;
};

/** on_conflict condition type for table "waitlist" */
export type Waitlist_On_Conflict = {
  constraint: Waitlist_Constraint;
  update_columns?: Array<Waitlist_Update_Column>;
  where?: InputMaybe<Waitlist_Bool_Exp>;
};

/** Ordering options when selecting data from "waitlist". */
export type Waitlist_Order_By = {
  confirmed?: InputMaybe<Order_By>;
  course?: InputMaybe<Course_Order_By>;
  courseId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  familyName?: InputMaybe<Order_By>;
  givenName?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  orgName?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
};

/** primary key columns input for table: waitlist */
export type Waitlist_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "waitlist" */
export enum Waitlist_Select_Column {
  /** column name */
  Confirmed = 'confirmed',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  FamilyName = 'familyName',
  /** column name */
  GivenName = 'givenName',
  /** column name */
  Id = 'id',
  /** column name */
  OrgName = 'orgName',
  /** column name */
  Phone = 'phone'
}

/** input type for updating data in table "waitlist" */
export type Waitlist_Set_Input = {
  confirmed?: InputMaybe<Scalars['Boolean']>;
  courseId?: InputMaybe<Scalars['Int']>;
  createdAt?: InputMaybe<Scalars['timestamptz']>;
  email?: InputMaybe<Scalars['String']>;
  familyName?: InputMaybe<Scalars['String']>;
  givenName?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['uuid']>;
  orgName?: InputMaybe<Scalars['String']>;
  phone?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Waitlist_Stddev_Fields = {
  __typename?: 'waitlist_stddev_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "waitlist" */
export type Waitlist_Stddev_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Waitlist_Stddev_Pop_Fields = {
  __typename?: 'waitlist_stddev_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "waitlist" */
export type Waitlist_Stddev_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Waitlist_Stddev_Samp_Fields = {
  __typename?: 'waitlist_stddev_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "waitlist" */
export type Waitlist_Stddev_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Waitlist_Sum_Fields = {
  __typename?: 'waitlist_sum_fields';
  courseId?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "waitlist" */
export type Waitlist_Sum_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** update columns of table "waitlist" */
export enum Waitlist_Update_Column {
  /** column name */
  Confirmed = 'confirmed',
  /** column name */
  CourseId = 'courseId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  FamilyName = 'familyName',
  /** column name */
  GivenName = 'givenName',
  /** column name */
  Id = 'id',
  /** column name */
  OrgName = 'orgName',
  /** column name */
  Phone = 'phone'
}

/** aggregate var_pop on columns */
export type Waitlist_Var_Pop_Fields = {
  __typename?: 'waitlist_var_pop_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "waitlist" */
export type Waitlist_Var_Pop_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Waitlist_Var_Samp_Fields = {
  __typename?: 'waitlist_var_samp_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "waitlist" */
export type Waitlist_Var_Samp_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Waitlist_Variance_Fields = {
  __typename?: 'waitlist_variance_fields';
  courseId?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "waitlist" */
export type Waitlist_Variance_Order_By = {
  courseId?: InputMaybe<Order_By>;
};

/** columns and relationships of "xero_credential" */
export type Xero_Credential = {
  __typename?: 'xero_credential';
  client_id: Scalars['String'];
  token: Scalars['String'];
};

/** aggregated selection of "xero_credential" */
export type Xero_Credential_Aggregate = {
  __typename?: 'xero_credential_aggregate';
  aggregate?: Maybe<Xero_Credential_Aggregate_Fields>;
  nodes: Array<Xero_Credential>;
};

/** aggregate fields of "xero_credential" */
export type Xero_Credential_Aggregate_Fields = {
  __typename?: 'xero_credential_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Xero_Credential_Max_Fields>;
  min?: Maybe<Xero_Credential_Min_Fields>;
};


/** aggregate fields of "xero_credential" */
export type Xero_Credential_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Xero_Credential_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "xero_credential". All fields are combined with a logical 'AND'. */
export type Xero_Credential_Bool_Exp = {
  _and?: InputMaybe<Array<Xero_Credential_Bool_Exp>>;
  _not?: InputMaybe<Xero_Credential_Bool_Exp>;
  _or?: InputMaybe<Array<Xero_Credential_Bool_Exp>>;
  client_id?: InputMaybe<String_Comparison_Exp>;
  token?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "xero_credential" */
export enum Xero_Credential_Constraint {
  /** unique or primary key constraint */
  XeroCredentialPkey = 'xero_credential_pkey'
}

/** input type for inserting data into table "xero_credential" */
export type Xero_Credential_Insert_Input = {
  client_id?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Xero_Credential_Max_Fields = {
  __typename?: 'xero_credential_max_fields';
  client_id?: Maybe<Scalars['String']>;
  token?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Xero_Credential_Min_Fields = {
  __typename?: 'xero_credential_min_fields';
  client_id?: Maybe<Scalars['String']>;
  token?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "xero_credential" */
export type Xero_Credential_Mutation_Response = {
  __typename?: 'xero_credential_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Xero_Credential>;
};

/** on_conflict condition type for table "xero_credential" */
export type Xero_Credential_On_Conflict = {
  constraint: Xero_Credential_Constraint;
  update_columns?: Array<Xero_Credential_Update_Column>;
  where?: InputMaybe<Xero_Credential_Bool_Exp>;
};

/** Ordering options when selecting data from "xero_credential". */
export type Xero_Credential_Order_By = {
  client_id?: InputMaybe<Order_By>;
  token?: InputMaybe<Order_By>;
};

/** primary key columns input for table: xero_credential */
export type Xero_Credential_Pk_Columns_Input = {
  client_id: Scalars['String'];
};

/** select columns of table "xero_credential" */
export enum Xero_Credential_Select_Column {
  /** column name */
  ClientId = 'client_id',
  /** column name */
  Token = 'token'
}

/** input type for updating data in table "xero_credential" */
export type Xero_Credential_Set_Input = {
  client_id?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['String']>;
};

/** update columns of table "xero_credential" */
export enum Xero_Credential_Update_Column {
  /** column name */
  ClientId = 'client_id',
  /** column name */
  Token = 'token'
}

export type ReplaceParticipantMutationVariables = Exact<{
  input: ReplaceParticipantInput;
}>;


export type ReplaceParticipantMutation = { __typename?: 'mutation_root', replaceParticipant?: { __typename?: 'ReplaceParticipantOutput', success: boolean, error?: ReplaceParticipantError | null } | null };

export type SearchTrainersQueryVariables = Exact<{
  input: SearchTrainersInput;
}>;


export type SearchTrainersQuery = { __typename?: 'query_root', trainers?: Array<{ __typename?: 'SearchTrainer', id: any, fullName: string, avatar?: string | null, availability?: SearchTrainerAvailability | null, levels: Array<{ __typename?: 'CourseCertificateLevel', courseLevel: CourseLevel, expiryDate: any }>, trainer_role_types: Array<{ __typename?: 'TrainerRoleType', trainer_role_type?: { __typename?: 'TrainerRoleTypeObj', name: string, id: string } | null }> } | null> | null };

export type SearchCourseFragment = { __typename?: 'course', id: number, name: string, level: Course_Level_Enum, deliveryType: Course_Delivery_Type_Enum, schedule: Array<{ __typename?: 'course_schedule', start: any, venue?: { __typename?: 'venue', city: string } | null }> };

export type SearchCoursesQueryVariables = Exact<{
  where?: InputMaybe<Course_Bool_Exp>;
}>;


export type SearchCoursesQuery = { __typename?: 'query_root', courses: Array<{ __typename?: 'course', id: number, name: string, level: Course_Level_Enum, deliveryType: Course_Delivery_Type_Enum, schedule: Array<{ __typename?: 'course_schedule', start: any, venue?: { __typename?: 'venue', city: string } | null }> }> };

export type GetSelectedCoursesQueryVariables = Exact<{
  ids: Array<Scalars['Int']> | Scalars['Int'];
}>;


export type GetSelectedCoursesQuery = { __typename?: 'query_root', courses: Array<{ __typename?: 'course', id: number, name: string, level: Course_Level_Enum, deliveryType: Course_Delivery_Type_Enum, schedule: Array<{ __typename?: 'course_schedule', start: any, venue?: { __typename?: 'venue', city: string } | null }> }> };

export type UpsertZoomMeetingMutationVariables = Exact<{
  input?: InputMaybe<UpsertZoomMeetingInput>;
}>;


export type UpsertZoomMeetingMutation = { __typename?: 'mutation_root', upsertZoomMeeting?: { __typename?: 'UpsertZoomMeetingPayload', success: boolean, meeting?: { __typename?: 'ZoomMeeting', id: number, joinUrl: string } | null } | null };

export type StripeCreatePaymentMutationVariables = Exact<{
  input: StripeCreatePaymentIntentInput;
}>;


export type StripeCreatePaymentMutation = { __typename?: 'mutation_root', paymentIntent?: { __typename?: 'StripeCreatePaymentIntentOutput', clientSecret: string, amount: number, currency: Currency } | null };

export type ConfirmCcPaymentMutationVariables = Exact<{
  orderId: Scalars['uuid'];
}>;


export type ConfirmCcPaymentMutation = { __typename?: 'mutation_root', confirmCreditCardPayment?: { __typename?: 'ConfirmCreditCardPaymentOutput', confirmed: boolean, error?: ConfirmCreditCardPaymentError | null } | null };

export type OnboardUserMutationVariables = Exact<{
  id: Scalars['uuid'];
  input: Profile_Set_Input;
}>;


export type OnboardUserMutation = { __typename?: 'mutation_root', update_profile_by_pk?: { __typename?: 'profile', id: any } | null };

export type AllResourceCategoriesQueryVariables = Exact<{ [key: string]: never; }>;


export type AllResourceCategoriesQuery = { __typename?: 'query_root', content?: { __typename?: 'RootQuery', resourceCategories?: { __typename?: 'RootQueryToResourceCategoryConnection', nodes?: Array<{ __typename?: 'ResourceCategory', id: string, name?: string | null, description?: string | null, resouceIcon?: { __typename?: 'ResourceCategory_Resouceicon', resourceicon?: string | null } | null, resourceArea?: { __typename?: 'ResourceCategory_Resourcearea', resourcearea?: string | null } | null } | null> | null } | null } | null };

export type ResourceDetailsQueryVariables = Exact<{
  id: Scalars['ID'];
  term?: InputMaybe<Scalars['String']>;
}>;


export type ResourceDetailsQuery = { __typename?: 'query_root', content?: { __typename?: 'RootQuery', resourceCategory?: { __typename?: 'ResourceCategory', id: string, name?: string | null, description?: string | null, children?: { __typename?: 'ResourceCategoryToResourceCategoryConnection', nodes?: Array<{ __typename?: 'ResourceCategory', id: string, name?: string | null, description?: string | null, children?: { __typename?: 'ResourceCategoryToResourceCategoryConnection', nodes?: Array<{ __typename?: 'ResourceCategory', id: string, name?: string | null, description?: string | null, resources?: { __typename?: 'ResourceCategoryToResourceConnection', nodes?: Array<{ __typename?: 'Resource', id: string, title?: string | null, resourceAttachment?: { __typename?: 'Resource_Resourceattachment', resourcetype?: string | null, videourl?: string | null, file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null } | null> | null } | null } | null> | null } | null, resources?: { __typename?: 'ResourceCategoryToResourceConnection', nodes?: Array<{ __typename?: 'Resource', id: string, title?: string | null, resourceAttachment?: { __typename?: 'Resource_Resourceattachment', resourcetype?: string | null, videourl?: string | null, file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null } | null> | null } | null } | null> | null } | null, resources?: { __typename?: 'ResourceCategoryToResourceConnection', nodes?: Array<{ __typename?: 'Resource', id: string, title?: string | null, resourceAttachment?: { __typename?: 'Resource_Resourceattachment', resourcetype?: string | null, videourl?: string | null, file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null } | null> | null } | null } | null } | null };

export type ResourceCategorySummaryFragment = { __typename?: 'ResourceCategory', id: string, name?: string | null, description?: string | null, resources?: { __typename?: 'ResourceCategoryToResourceConnection', nodes?: Array<{ __typename?: 'Resource', id: string, title?: string | null, resourceAttachment?: { __typename?: 'Resource_Resourceattachment', resourcetype?: string | null, videourl?: string | null, file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null } | null> | null } | null };

export type ResourceSummaryFragment = { __typename?: 'Resource', id: string, title?: string | null, resourceAttachment?: { __typename?: 'Resource_Resourceattachment', resourcetype?: string | null, videourl?: string | null, file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null };

export type ParticipantTransferQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type ParticipantTransferQuery = { __typename?: 'query_root', participant?: { __typename?: 'course_participant', id: any, profile: { __typename?: 'profile', fullName?: string | null, avatar?: string | null } } | null };

export type TransferParticipantDetailsQueryVariables = Exact<{
  courseId: Scalars['Int'];
  participantId: Scalars['uuid'];
}>;


export type TransferParticipantDetailsQuery = { __typename?: 'query_root', course?: { __typename?: 'course', id: number, level: Course_Level_Enum, type: Course_Type_Enum, status?: Course_Status_Enum | null, dates: { __typename?: 'course_schedule_aggregate', aggregate?: { __typename?: 'course_schedule_aggregate_fields', start?: { __typename?: 'course_schedule_min_fields', date?: any | null } | null, end?: { __typename?: 'course_schedule_max_fields', date?: any | null } | null } | null } } | null, participant?: { __typename?: 'course_participant', id: any, profile: { __typename?: 'profile', fullName?: string | null, avatar?: string | null } } | null };

export type TransferEligibleCoursesQueryVariables = Exact<{
  fromCourseId: Scalars['Int'];
}>;


export type TransferEligibleCoursesQuery = { __typename?: 'query_root', eligibleTransferCourses: Array<{ __typename?: 'TransferCourse', id: number, courseCode: string, startDate: string, endDate: string, virtualLink?: string | null, venue?: string | null, venueName?: string | null, venueCity?: string | null }> };

export type TransferParticipantMutationVariables = Exact<{
  input: TransferInput;
}>;


export type TransferParticipantMutation = { __typename?: 'mutation_root', transferParticipant?: { __typename?: 'TransferParticipantOutput', success: boolean, error?: string | null } | null };

export type WaitlistCourseQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type WaitlistCourseQuery = { __typename?: 'query_root', courses: Array<{ __typename?: 'course', id: number, name: string, schedule: Array<{ __typename?: 'course_schedule', end: any, start: any, venue?: { __typename?: 'venue', name: string, addressLineOne: string, addressLineTwo?: string | null, city: string, postCode: string } | null }> }> };

export type JoinWaitlistMutationVariables = Exact<{
  input: Waitlist_Insert_Input;
}>;


export type JoinWaitlistMutation = { __typename?: 'mutation_root', waitlist?: { __typename?: 'waitlist_mutation_response', affected_rows: number } | null };

export type CourseGradingDataQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type CourseGradingDataQuery = { __typename?: 'query_root', course?: { __typename?: 'course', id: number, name: string, type: Course_Type_Enum, level: Course_Level_Enum, deliveryType: Course_Delivery_Type_Enum, participants: Array<{ __typename?: 'course_participant', id: any, attended?: boolean | null, grade?: Grade_Enum | null, profile: { __typename?: 'profile', id: any, fullName?: string | null, avatar?: string | null } }>, modules: Array<{ __typename?: 'course_module', id: any, covered?: boolean | null, module: { __typename?: 'module', id: any, name: string, moduleGroup?: { __typename?: 'module_group', id: any, name: string, mandatory: boolean } | null } }> } | null };

export type XeroConnectQueryVariables = Exact<{ [key: string]: never; }>;


export type XeroConnectQuery = { __typename?: 'query_root', xeroConnect?: { __typename?: 'XeroConnectOutput', consentUrl?: string | null } | null };

export type XeroCallbackMutationVariables = Exact<{
  input: XeroCallbackInput;
}>;


export type XeroCallbackMutation = { __typename?: 'mutation_root', xeroCallback?: { __typename?: 'XeroCallbackOutput', status: boolean } | null };

export type ProfilesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<Profile_Order_By> | Profile_Order_By>;
  where?: InputMaybe<Profile_Bool_Exp>;
}>;


export type ProfilesQuery = { __typename?: 'query_root', profiles: Array<{ __typename?: 'profile', id: any, givenName: string, familyName: string, fullName?: string | null, avatar?: string | null, title?: string | null, tags?: any | null, addresses: any, attributes: any, contactDetails: any, dietaryRestrictions?: string | null, disabilities?: string | null, preferences: any, createdAt: any, updatedAt: any, email?: string | null, phone?: string | null, dob?: any | null, jobTitle?: string | null, dbs?: string | null, lastActivity: any, organizations: Array<{ __typename?: 'organization_member', id: any, isAdmin?: boolean | null, position?: string | null, organization: { __typename?: 'organization', name: string, id: any, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null } }>, roles: Array<{ __typename?: 'profile_role', role: { __typename?: 'role', name: string, id: any } }>, trainer_role_types: Array<{ __typename?: 'profile_trainer_role_type', trainer_role_type: { __typename?: 'trainer_role_type', id: any, name: string } }> }>, profilesAggregation: { __typename?: 'profile_aggregate', aggregate?: { __typename?: 'profile_aggregate_fields', count: number } | null } };

export type OrganizationsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<Organization_Order_By> | Organization_Order_By>;
}>;


export type OrganizationsQuery = { __typename?: 'query_root', organizations: Array<{ __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null, members_aggregate: { __typename?: 'organization_member_aggregate', aggregate?: { __typename?: 'organization_member_aggregate_fields', count: number } | null } }>, organizationsAggregation: { __typename?: 'organization_aggregate', aggregate?: { __typename?: 'organization_aggregate_fields', count: number } | null } };

export type GetAttendeeAuditLogsQueryVariables = Exact<{
  where: Course_Participant_Audit_Bool_Exp;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<Course_Participant_Audit_Order_By> | Course_Participant_Audit_Order_By>;
}>;


export type GetAttendeeAuditLogsQuery = { __typename?: 'query_root', logs: Array<{ __typename?: 'course_participant_audit', id: any, created_at: any, updated_at: any, payload: any, newAttendeeEmail?: string | null, authorizedBy: { __typename?: 'profile', id: any, avatar?: string | null, fullName?: string | null }, profile: { __typename?: 'profile', id: any, avatar?: string | null, fullName?: string | null, email?: string | null }, course: { __typename?: 'course', id: number, course_code?: string | null }, fromCourse?: Array<{ __typename?: 'course', id: number, course_code?: string | null }> | null, toCourse?: Array<{ __typename?: 'course', id: number, course_code?: string | null }> | null }>, logsAggregate: { __typename?: 'course_participant_audit_aggregate', aggregate?: { __typename?: 'course_participant_audit_aggregate_fields', count: number } | null } };

export type GetCourseAuditLogsQueryVariables = Exact<{
  where: Course_Audit_Bool_Exp;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<Course_Audit_Order_By> | Course_Audit_Order_By>;
}>;


export type GetCourseAuditLogsQuery = { __typename?: 'query_root', logs: Array<{ __typename?: 'course_audit', id: any, created_at: any, updated_at: any, payload: any, authorizedBy: { __typename?: 'profile', id: any, avatar?: string | null, fullName?: string | null }, course: { __typename?: 'course', id: number, course_code?: string | null } }>, logsAggregate: { __typename?: 'course_audit_aggregate', aggregate?: { __typename?: 'course_audit_aggregate_fields', count: number } | null } };

export type GetWaitlistQueryVariables = Exact<{
  where: Waitlist_Bool_Exp;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<Waitlist_Order_By> | Waitlist_Order_By>;
}>;


export type GetWaitlistQuery = { __typename?: 'query_root', waitlist: Array<{ __typename?: 'waitlist', id: any, email: string, phone: string, orgName: string, courseId: number, confirmed: boolean, createdAt: any, givenName: string, familyName: string }>, waitlistAggregate: { __typename?: 'waitlist_aggregate', aggregate?: { __typename?: 'waitlist_aggregate_fields', count: number } | null } };

export type BookPrivateCourseMutationVariables = Exact<{
  booking: Private_Course_Booking_Insert_Input;
}>;


export type BookPrivateCourseMutation = { __typename?: 'mutation_root', insert_private_course_booking?: { __typename?: 'private_course_booking_mutation_response', affected_rows: number } | null };

export type InsertCourseEnquiryMutationVariables = Exact<{
  enquiry: Course_Enquiry_Insert_Input;
}>;


export type InsertCourseEnquiryMutation = { __typename?: 'mutation_root', insert_course_enquiry?: { __typename?: 'course_enquiry_mutation_response', affected_rows: number } | null };

export type InsertWaitlistMutationVariables = Exact<{
  input: Waitlist_Insert_Input;
}>;


export type InsertWaitlistMutation = { __typename?: 'mutation_root', waitlist?: { __typename?: 'waitlist_mutation_response', affectedRows: number } | null };

export type FindLegacyCertificateQueryVariables = Exact<{
  code: Scalars['String'];
  firstName: Scalars['String'];
  lastName: Scalars['String'];
}>;


export type FindLegacyCertificateQuery = { __typename?: 'query_root', results: Array<{ __typename?: 'legacy_certificate', id: any, number: string, courseName: string, expiryDate: any, certificationDate: any }> };

export type GetCertificateQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetCertificateQuery = { __typename?: 'query_root', certificate?: { __typename?: 'course_certificate', id: any, createdAt: any, updatedAt: any, number: string, expiryDate: any, certificationDate: any, courseName: string, courseLevel: string, profile?: { __typename?: 'profile', fullName?: string | null, id: any, avatar?: string | null } | null, participant?: { __typename?: 'course_participant', id: any, grade?: Grade_Enum | null, dateGraded?: any | null, gradingModules: Array<{ __typename?: 'course_participant_module', completed: boolean, module: { __typename?: 'module', id: any, name: string, moduleGroup?: { __typename?: 'module_group', id: any, name: string } | null } }>, course: { __typename?: 'course', id: number, name: string, deliveryType: Course_Delivery_Type_Enum }, certificateChanges: Array<{ __typename?: 'course_certificate_changelog', id: any, createdAt: any, updatedAt: any, oldGrade: Grade_Enum, newGrade: Grade_Enum, notes: string, author: { __typename?: 'profile', fullName?: string | null, avatar?: string | null } }> } | null } | null };

export type ImportLegacyCertificateMutationVariables = Exact<{
  id: Scalars['uuid'];
  number: Scalars['String'];
  expiryDate: Scalars['date'];
  certificationDate: Scalars['date'];
  courseName: Scalars['String'];
  courseLevel: Scalars['String'];
  profileId: Scalars['uuid'];
}>;


export type ImportLegacyCertificateMutation = { __typename?: 'mutation_root', insert_course_certificate_one?: { __typename?: 'course_certificate', id: any } | null, update_legacy_certificate?: { __typename?: 'legacy_certificate_mutation_response', returning: Array<{ __typename?: 'legacy_certificate', id: any }> } | null };

export type GetEvaluationQueryVariables = Exact<{
  courseId: Scalars['Int'];
  profileId: Scalars['uuid'];
}>;


export type GetEvaluationQuery = { __typename?: 'query_root', answers: Array<{ __typename?: 'course_evaluation_answers', id: any, answer?: string | null, question: { __typename?: 'course_evaluation_questions', id: any, type?: Course_Evaluation_Question_Type_Enum | null }, profile: { __typename?: 'profile', fullName?: string | null } }> };

export type GetEvaluationsSummaryQueryVariables = Exact<{
  courseId: Scalars['Int'];
}>;


export type GetEvaluationsSummaryQuery = { __typename?: 'query_root', answers: Array<{ __typename?: 'course_evaluation_answers', id: any, answer?: string | null, profile: { __typename?: 'profile', id: any, fullName?: string | null, avatar?: string | null }, question: { __typename?: 'course_evaluation_questions', questionKey?: string | null, type?: Course_Evaluation_Question_Type_Enum | null, group?: Course_Evaluation_Question_Group_Enum | null } }> };

export type GetEvaluationsQueryVariables = Exact<{
  courseId: Scalars['Int'];
}>;


export type GetEvaluationsQuery = { __typename?: 'query_root', evaluations: Array<{ __typename?: 'course_evaluation_answers', id: any, profile: { __typename?: 'profile', id: any, fullName?: string | null, email?: string | null, organizations: Array<{ __typename?: 'organization_member', organization: { __typename?: 'organization', name: string } }> } }>, attendees: Array<{ __typename?: 'course_participant', id: any, profile: { __typename?: 'profile', id: any } }>, trainers: Array<{ __typename?: 'course_trainer', id: any, type: Course_Trainer_Type_Enum, profile: { __typename?: 'profile', id: any } }> };

export type GetFeedbackUsersQueryVariables = Exact<{
  courseId: Scalars['Int'];
}>;


export type GetFeedbackUsersQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'course_evaluation_answers', profile: { __typename?: 'profile', id: any, fullName?: string | null, avatar?: string | null } }> };

export type GetCourseEvaluationQuestionsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCourseEvaluationQuestionsQuery = { __typename?: 'query_root', questions: Array<{ __typename?: 'course_evaluation_questions', id: any, type?: Course_Evaluation_Question_Type_Enum | null, questionKey?: string | null, group?: Course_Evaluation_Question_Group_Enum | null, displayOrder: number, required: boolean }> };

export type SaveCourseEvaluationMutationVariables = Exact<{
  answers: Array<Course_Evaluation_Answers_Insert_Input> | Course_Evaluation_Answers_Insert_Input;
}>;


export type SaveCourseEvaluationMutation = { __typename?: 'mutation_root', inserted?: { __typename?: 'course_evaluation_answers_mutation_response', rows: Array<{ __typename?: 'course_evaluation_answers', id: any }> } | null };

export type CancelCourseMutationVariables = Exact<{
  courseId: Scalars['Int'];
  cancellationFeePercent?: InputMaybe<Scalars['Int']>;
  cancellationReason: Scalars['String'];
}>;


export type CancelCourseMutation = { __typename?: 'mutation_root', cancelledCourse?: { __typename?: 'course', id: number } | null, delete_course_cancellation_request?: { __typename?: 'course_cancellation_request_mutation_response', affected_rows: number } | null };

export type CancelIndirectCourseMutationVariables = Exact<{
  courseId: Scalars['Int'];
  cancellationReason: Scalars['String'];
}>;


export type CancelIndirectCourseMutation = { __typename?: 'mutation_root', cancelledCourse?: { __typename?: 'course', id: number } | null, delete_course_cancellation_request?: { __typename?: 'course_cancellation_request_mutation_response', affected_rows: number } | null };

export type CancelMyselfFromCourseMutationVariables = Exact<{
  courseId: Scalars['Int'];
}>;


export type CancelMyselfFromCourseMutation = { __typename?: 'mutation_root', cancelMyselfFromCourse: boolean };

export type DeleteCourseCancellationRequestMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type DeleteCourseCancellationRequestMutation = { __typename?: 'mutation_root', delete_course_cancellation_request_by_pk?: { __typename?: 'course_cancellation_request', id: any } | null };

export type FinalizeCourseBuilderMutationVariables = Exact<{
  id: Scalars['Int'];
  duration: Scalars['Int'];
  status: Course_Status_Enum;
}>;


export type FinalizeCourseBuilderMutation = { __typename?: 'mutation_root', update_course_by_pk?: { __typename?: 'course', id: number } | null };

export type GetCourseByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetCourseByIdQuery = { __typename?: 'query_root', course?: { __typename?: 'course', freeSpaces?: number | null, accountCode?: string | null, level: Course_Level_Enum, id: number, createdAt: any, updatedAt: any, name: string, type: Course_Type_Enum, deliveryType: Course_Delivery_Type_Enum, status?: Course_Status_Enum | null, course_code?: string | null, reaccreditation?: boolean | null, min_participants: number, max_participants: number, gradingConfirmed: boolean, gradingStarted: boolean, go1Integration: boolean, aolCostOfCourse?: any | null, aolCountry?: string | null, aolRegion?: string | null, modulesDuration: number, notes?: string | null, start?: any | null, end?: any | null, cancellationRequest?: { __typename?: 'course_cancellation_request', id: any, reason: string } | null, trainers: Array<{ __typename?: 'course_trainer', id: any, type: Course_Trainer_Type_Enum, status?: Course_Invite_Status_Enum | null, profile: { __typename?: 'profile', id: any, givenName: string, familyName: string, fullName?: string | null, certificates: Array<{ __typename?: 'course_certificate', courseLevel: string, expiryDate: any }>, trainer_role_types: Array<{ __typename?: 'profile_trainer_role_type', trainer_role_type: { __typename?: 'trainer_role_type', id: any, name: string } }> } }>, schedule: Array<{ __typename?: 'course_schedule', id: any, createdAt: any, updatedAt: any, start: any, end: any, virtualLink?: string | null, venue?: { __typename?: 'venue', id: any, createdAt: any, updatedAt: any, name: string, city: string, addressLineOne: string, addressLineTwo?: string | null, postCode: string, geoCoordinates?: any | null, googlePlacesId?: string | null } | null }>, organization?: { __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null } | null, contactProfile?: { __typename?: 'profile', id: any, fullName?: string | null } | null, salesRepresentative?: { __typename?: 'profile', id: any, fullName?: string | null } | null, dates: { __typename?: 'course_schedule_aggregate', aggregate?: { __typename?: 'course_schedule_aggregate_fields', start?: { __typename?: 'course_schedule_min_fields', date?: any | null } | null, end?: { __typename?: 'course_schedule_max_fields', date?: any | null } | null } | null }, moduleGroupIds: Array<{ __typename?: 'course_module', module: { __typename?: 'module', moduleGroup?: { __typename?: 'module_group', id: any } | null } }>, certificateCount: { __typename?: 'course_participant_aggregate', aggregate?: { __typename?: 'course_participant_aggregate_fields', count: number } | null }, attendeesCount: { __typename?: 'course_participant_aggregate', aggregate?: { __typename?: 'course_participant_aggregate_fields', count: number } | null } } | null };

export type GetCourseDraftQueryVariables = Exact<{
  profileId: Scalars['uuid'];
  courseType: Scalars['String'];
}>;


export type GetCourseDraftQuery = { __typename?: 'query_root', course_draft: Array<{ __typename?: 'course_draft', data?: any | null }> };

export type CourseModulesQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type CourseModulesQuery = { __typename?: 'query_root', courseModules: Array<{ __typename?: 'course_module', id: any, covered?: boolean | null, module: { __typename?: 'module', id: any, name: string, moduleGroup?: { __typename?: 'module_group', id: any, name: string, mandatory: boolean } | null } }> };

export type GetCoursePricingNoIdQueryVariables = Exact<{
  type: Course_Type_Enum;
  level: Course_Level_Enum;
  blended: Scalars['Boolean'];
  reaccreditation: Scalars['Boolean'];
}>;


export type GetCoursePricingNoIdQuery = { __typename?: 'query_root', coursePricing: Array<{ __typename?: 'course_pricing', id: any, level: Course_Level_Enum, type: Course_Type_Enum, blended: boolean, reaccreditation: boolean, priceAmount: any, priceCurrency: string, xeroCode: string }> };

export type GetCoursePricingQueryVariables = Exact<{
  courseId: Scalars['Int'];
}>;


export type GetCoursePricingQuery = { __typename?: 'query_root', pricing?: { __typename?: 'GetCoursePricingOutput', priceAmount: number, priceCurrency: Currency, xeroCode: string } | null };

export type GetOrgCoursesQueryVariables = Exact<{
  where?: InputMaybe<Organization_Bool_Exp>;
  courseFilter?: InputMaybe<Course_Bool_Exp>;
}>;


export type GetOrgCoursesQuery = { __typename?: 'query_root', courses: Array<{ __typename?: 'course', id: number, createdAt: any, updatedAt: any, name: string, type: Course_Type_Enum, deliveryType: Course_Delivery_Type_Enum, status?: Course_Status_Enum | null, level: Course_Level_Enum, course_code?: string | null, reaccreditation?: boolean | null, min_participants: number, max_participants: number, gradingConfirmed: boolean, gradingStarted: boolean, go1Integration: boolean, aolCostOfCourse?: any | null, aolCountry?: string | null, aolRegion?: string | null, modulesDuration: number, notes?: string | null, start?: any | null, end?: any | null, schedules: Array<{ __typename?: 'course_schedule', start: any, end: any, virtualLink?: string | null, venue?: { __typename?: 'venue', name: string, addressLineOne: string, addressLineTwo?: string | null, city: string, postCode: string, geoCoordinates?: any | null } | null }>, participantsCount: { __typename?: 'course_participant_aggregate', aggregate?: { __typename?: 'course_participant_aggregate_fields', count: number } | null } }> };

export type TrainerCourseFragment = { __typename?: 'course', id: number, name: string, type: Course_Type_Enum, level: Course_Level_Enum, status?: Course_Status_Enum | null, course_code?: string | null, go1Integration: boolean, max_participants: number, organization?: { __typename?: 'organization', name: string } | null, trainers: Array<{ __typename?: 'course_trainer', id: any, type: Course_Trainer_Type_Enum, status?: Course_Invite_Status_Enum | null, profile: { __typename?: 'profile', id: any, fullName?: string | null, avatar?: string | null } }>, participantsAgg: { __typename?: 'course_participant_aggregate', aggregate?: { __typename?: 'course_participant_aggregate_fields', count: number } | null }, waitlistAgg: { __typename?: 'waitlist_aggregate', aggregate?: { __typename?: 'waitlist_aggregate_fields', count: number } | null }, dates: { __typename?: 'course_schedule_aggregate', aggregate?: { __typename?: 'course_schedule_aggregate_fields', start?: { __typename?: 'course_schedule_min_fields', date?: any | null } | null, end?: { __typename?: 'course_schedule_max_fields', date?: any | null } | null } | null }, modulesAgg: { __typename?: 'course_module_aggregate', aggregate?: { __typename?: 'course_module_aggregate_fields', count: number } | null }, schedule: Array<{ __typename?: 'course_schedule', id: any, virtualLink?: string | null, venue?: { __typename?: 'venue', id: any, name: string, city: string } | null }>, cancellationRequest?: { __typename?: 'course_cancellation_request', id: any } | null };

export type TrainerCoursesQueryVariables = Exact<{
  orderBy?: InputMaybe<Array<Course_Order_By> | Course_Order_By>;
  where?: InputMaybe<Course_Bool_Exp>;
  offset?: InputMaybe<Scalars['Int']>;
  limit?: InputMaybe<Scalars['Int']>;
}>;


export type TrainerCoursesQuery = { __typename?: 'query_root', courses: Array<{ __typename?: 'course', id: number, name: string, type: Course_Type_Enum, level: Course_Level_Enum, status?: Course_Status_Enum | null, course_code?: string | null, go1Integration: boolean, max_participants: number, organization?: { __typename?: 'organization', name: string } | null, trainers: Array<{ __typename?: 'course_trainer', id: any, type: Course_Trainer_Type_Enum, status?: Course_Invite_Status_Enum | null, profile: { __typename?: 'profile', id: any, fullName?: string | null, avatar?: string | null } }>, participantsAgg: { __typename?: 'course_participant_aggregate', aggregate?: { __typename?: 'course_participant_aggregate_fields', count: number } | null }, waitlistAgg: { __typename?: 'waitlist_aggregate', aggregate?: { __typename?: 'waitlist_aggregate_fields', count: number } | null }, dates: { __typename?: 'course_schedule_aggregate', aggregate?: { __typename?: 'course_schedule_aggregate_fields', start?: { __typename?: 'course_schedule_min_fields', date?: any | null } | null, end?: { __typename?: 'course_schedule_max_fields', date?: any | null } | null } | null }, modulesAgg: { __typename?: 'course_module_aggregate', aggregate?: { __typename?: 'course_module_aggregate_fields', count: number } | null }, schedule: Array<{ __typename?: 'course_schedule', id: any, virtualLink?: string | null, venue?: { __typename?: 'venue', id: any, name: string, city: string } | null }>, cancellationRequest?: { __typename?: 'course_cancellation_request', id: any } | null }>, course_aggregate: { __typename?: 'course_aggregate', aggregate?: { __typename?: 'course_aggregate_fields', count: number } | null } };

export type InsertCourseAuditMutationVariables = Exact<{
  object: Course_Audit_Insert_Input;
}>;


export type InsertCourseAuditMutation = { __typename?: 'mutation_root', insert_course_audit?: { __typename?: 'course_audit_mutation_response', affected_rows: number } | null };

export type InsertCourseMutationVariables = Exact<{
  course: Course_Insert_Input;
}>;


export type InsertCourseMutation = { __typename?: 'mutation_root', insertCourse?: { __typename?: 'course_mutation_response', affectedRows: number, inserted: Array<{ __typename?: 'course', id: number, course_code?: string | null, expenses: Array<{ __typename?: 'course_expenses', id: any }> }> } | null };

export type RemoveCourseDraftMutationVariables = Exact<{
  courseType: Scalars['String'];
  profileId: Scalars['uuid'];
}>;


export type RemoveCourseDraftMutation = { __typename?: 'mutation_root', delete_course_draft?: { __typename?: 'course_draft_mutation_response', returning: Array<{ __typename?: 'course_draft', id: any }> } | null };

export type RequestCourseCancellationMutationVariables = Exact<{
  cancellationRequest: Course_Cancellation_Request_Insert_Input;
}>;


export type RequestCourseCancellationMutation = { __typename?: 'mutation_root', insert_course_cancellation_request?: { __typename?: 'course_cancellation_request_mutation_response', affected_rows: number } | null };

export type SaveCourseAttendanceMutationVariables = Exact<{
  attended: Array<Scalars['uuid']> | Scalars['uuid'];
  notAttended: Array<Scalars['uuid']> | Scalars['uuid'];
  attendedAudit: Array<Course_Participant_Audit_Insert_Input> | Course_Participant_Audit_Insert_Input;
  notAttendedAudit: Array<Course_Participant_Audit_Insert_Input> | Course_Participant_Audit_Insert_Input;
}>;


export type SaveCourseAttendanceMutation = { __typename?: 'mutation_root', saveAttended?: { __typename?: 'course_participant_mutation_response', affectedRows: number } | null, saveAttendedAudit?: { __typename?: 'course_participant_audit_mutation_response', affectedRows: number } | null, saveNotAttended?: { __typename?: 'course_participant_mutation_response', affectedRows: number } | null, saveNotAttendedAudit?: { __typename?: 'course_participant_audit_mutation_response', affectedRows: number } | null };

export type SaveModuleSelectionMutationVariables = Exact<{
  coveredModules: Array<Scalars['uuid']> | Scalars['uuid'];
  notCoveredModules: Array<Scalars['uuid']> | Scalars['uuid'];
  courseId: Scalars['Int'];
}>;


export type SaveModuleSelectionMutation = { __typename?: 'mutation_root', saveCovered?: { __typename?: 'course_module_mutation_response', affectedRows: number } | null, saveNotCovered?: { __typename?: 'course_module_mutation_response', affectedRows: number } | null, gradingConfirmed?: { __typename?: 'course', id: number } | null };

export type SaveCourseModulesMutationVariables = Exact<{
  courseId: Scalars['Int'];
  modules: Array<Course_Module_Insert_Input> | Course_Module_Insert_Input;
}>;


export type SaveCourseModulesMutation = { __typename?: 'mutation_root', deleted?: { __typename?: 'course_module_mutation_response', count: number } | null, inserted?: { __typename?: 'course_module_mutation_response', count: number } | null };

export type SetCourseDraftMutationVariables = Exact<{
  courseType: Scalars['String'];
  profileId: Scalars['uuid'];
  data: Scalars['jsonb'];
}>;


export type SetCourseDraftMutation = { __typename?: 'mutation_root', insert_course_draft_one?: { __typename?: 'course_draft', id: any } | null };

export type SetCourseStatusMutationVariables = Exact<{
  id: Scalars['Int'];
  status?: InputMaybe<Course_Status_Enum>;
}>;


export type SetCourseStatusMutation = { __typename?: 'mutation_root', update_course_by_pk?: { __typename?: 'course', id: number } | null };

export type SetCourseTrainerStatusMutationVariables = Exact<{
  id: Scalars['uuid'];
  status: Course_Invite_Status_Enum;
}>;


export type SetCourseTrainerStatusMutation = { __typename?: 'mutation_root', update_course_trainer_by_pk?: { __typename?: 'course_trainer', id: any, status?: Course_Invite_Status_Enum | null } | null };

export type SetCourseTrainersMutationVariables = Exact<{
  courseId: Scalars['Int'];
  trainers: Array<Course_Trainer_Insert_Input> | Course_Trainer_Insert_Input;
}>;


export type SetCourseTrainersMutation = { __typename?: 'mutation_root', delete_course_trainer?: { __typename?: 'course_trainer_mutation_response', returning: Array<{ __typename?: 'course_trainer', id: any }> } | null, insert_course_trainer?: { __typename?: 'course_trainer_mutation_response', returning: Array<{ __typename?: 'course_trainer', id: any }> } | null };

export type UpdateCourseMutationVariables = Exact<{
  courseId: Scalars['Int'];
  courseInput: Course_Set_Input;
  scheduleId: Scalars['uuid'];
  scheduleInput: Course_Schedule_Set_Input;
  trainers: Array<Course_Trainer_Insert_Input> | Course_Trainer_Insert_Input;
}>;


export type UpdateCourseMutation = { __typename?: 'mutation_root', updateCourse?: { __typename?: 'course', id: number, level: Course_Level_Enum } | null, updateSchedule?: { __typename?: 'course_schedule', id: any } | null, deleteCourseTrainers?: { __typename?: 'course_trainer_mutation_response', returning: Array<{ __typename?: 'course_trainer', id: any }> } | null, insertCourseTrainers?: { __typename?: 'course_trainer_mutation_response', returning: Array<{ __typename?: 'course_trainer', id: any }> } | null };

export type FindEstablishmentQueryVariables = Exact<{
  where: Dfe_Establishment_Bool_Exp;
}>;


export type FindEstablishmentQuery = { __typename?: 'query_root', establishments: Array<{ __typename?: 'dfe_establishment', id: any, urn: string, name: string, localAuthority: string, trustType?: string | null, trustName?: string | null, addressLineOne?: string | null, addressLineTwo?: string | null, addressLineThree?: string | null, town?: string | null, county?: string | null, postcode?: string | null, headTitle?: string | null, headFirstName?: string | null, headLastName?: string | null, headJobTitle?: string | null, ofstedRating?: string | null, ofstedLastInspection?: string | null }>, total: { __typename?: 'dfe_establishment_aggregate', aggregate?: { __typename?: 'dfe_establishment_aggregate_fields', count: number } | null } };

export type OrganizationFragment = { __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null };

export type ProfileFragment = { __typename?: 'profile', id: any, givenName: string, familyName: string, fullName?: string | null, avatar?: string | null, title?: string | null, tags?: any | null, addresses: any, attributes: any, contactDetails: any, dietaryRestrictions?: string | null, disabilities?: string | null, preferences: any, createdAt: any, updatedAt: any, email?: string | null, phone?: string | null, dob?: any | null, jobTitle?: string | null, dbs?: string | null, lastActivity: any, organizations: Array<{ __typename?: 'organization_member', id: any, isAdmin?: boolean | null, position?: string | null, organization: { __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null } }>, roles: Array<{ __typename?: 'profile_role', role: { __typename?: 'role', id: any, name: string } }>, trainer_role_types: Array<{ __typename?: 'profile_trainer_role_type', trainer_role_type: { __typename?: 'trainer_role_type', id: any, name: string } }> };

export type ModuleFragment = { __typename?: 'module', id: any, name: string, description?: string | null, level: Course_Level_Enum, type: Module_Category_Enum, createdAt: any, updatedAt: any };

export type ModuleGroupFragment = { __typename?: 'module_group', id: any, name: string, level: Course_Level_Enum, color: Color_Enum, mandatory: boolean, createdAt: any, updatedAt: any };

export type CourseFragment = { __typename?: 'course', id: number, createdAt: any, updatedAt: any, name: string, type: Course_Type_Enum, deliveryType: Course_Delivery_Type_Enum, status?: Course_Status_Enum | null, level: Course_Level_Enum, course_code?: string | null, reaccreditation?: boolean | null, min_participants: number, max_participants: number, gradingConfirmed: boolean, gradingStarted: boolean, go1Integration: boolean, aolCostOfCourse?: any | null, aolCountry?: string | null, aolRegion?: string | null, modulesDuration: number, notes?: string | null, start?: any | null, end?: any | null };

export type CourseDatesFragment = { __typename?: 'course_schedule_aggregate', aggregate?: { __typename?: 'course_schedule_aggregate_fields', start?: { __typename?: 'course_schedule_min_fields', date?: any | null } | null, end?: { __typename?: 'course_schedule_max_fields', date?: any | null } | null } | null };

export type CourseScheduleFragment = { __typename?: 'course_schedule', id: any, createdAt: any, updatedAt: any, start: any, end: any, virtualLink?: string | null };

export type VenueFragment = { __typename?: 'venue', id: any, createdAt: any, updatedAt: any, name: string, city: string, addressLineOne: string, addressLineTwo?: string | null, postCode: string, geoCoordinates?: any | null, googlePlacesId?: string | null };

export type CertificateFragment = { __typename?: 'course_certificate', id: any, createdAt: any, updatedAt: any, number: string, expiryDate: any, certificationDate: any, courseName: string, courseLevel: string };

export type CertificateChangelogFragment = { __typename?: 'course_certificate_changelog', id: any, createdAt: any, updatedAt: any, oldGrade: Grade_Enum, newGrade: Grade_Enum, notes: string };

export type LegacyCertificateFragment = { __typename?: 'legacy_certificate', id: any, number: string, courseName: string, expiryDate: any, certificationDate: any };

export type VideoItemSummaryFragment = { __typename?: 'VideoSeriesItem', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, youtube?: { __typename?: 'VideoSeriesItem_Youtube', url?: string | null, duration?: number | null } | null, downloads?: { __typename?: 'VideoSeriesItem_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, videoSeriesCategories?: { __typename?: 'VideoSeriesItemToVideoSeriesCategoryConnection', nodes?: Array<{ __typename?: 'VideoSeriesCategory', id: string, name?: string | null } | null> | null } | null };

export type TagSummaryFragment = { __typename?: 'Tag', id: string, name?: string | null };

export type CategorySummaryFragment = { __typename?: 'Category', id: string, name?: string | null };

export type PostSummaryFragment = { __typename?: 'Post', id: string, title?: string | null, excerpt?: string | null, content?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, tags?: { __typename?: 'PostToTagConnection', nodes?: Array<{ __typename?: 'Tag', id: string, name?: string | null } | null> | null } | null, author?: { __typename?: 'NodeWithAuthorToUserConnectionEdge', node?: { __typename?: 'User', firstName?: string | null, lastName?: string | null } | null } | null, customAuthor?: { __typename?: 'Post_Customauthor', displayAuthor?: boolean | null, authorName?: string | null } | null, categories?: { __typename?: 'PostToCategoryConnection', nodes?: Array<{ __typename?: 'Category', id: string, name?: string | null } | null> | null } | null };

export type PodcastSummaryFragment = { __typename?: 'Podcast', id: string, name: string, thumbnail: string, publishedDate: string, mediaUrl: string, author: string, description?: string | null, episodeNumber: number };

export type EbookSummaryFragment = { __typename?: 'Ebook', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, downloads?: { __typename?: 'Ebook_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, ebooksCategories?: { __typename?: 'EbookToEbooksCategoryConnection', nodes?: Array<{ __typename?: 'EbooksCategory', id: string, name?: string | null } | null> | null } | null };

export type ResearchSummaryDetailsFragment = { __typename?: 'ResearchSummary', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, downloads?: { __typename?: 'ResearchSummary_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, researchSummariesCategories?: { __typename?: 'ResearchSummaryToResearchSummariesCategoryConnection', nodes?: Array<{ __typename?: 'ResearchSummariesCategory', id: string, name?: string | null } | null> | null } | null };

export type WebinarSummaryFragment = { __typename?: 'Webinar', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, youtube?: { __typename?: 'Webinar_Youtube', url?: string | null, duration?: number | null } | null, webinarsCategories?: { __typename?: 'WebinarToWebinarsCategoryConnection', nodes?: Array<{ __typename?: 'WebinarsCategory', id: string, name?: string | null } | null> | null } | null };

export type CourseTrainerInfoFragment = { __typename?: 'course_trainer', id: any, status?: Course_Invite_Status_Enum | null, type: Course_Trainer_Type_Enum, profile: { __typename?: 'profile', id: any, fullName?: string | null } };

export type WaitlistSummaryFragment = { __typename?: 'waitlist', id: any, email: string, phone: string, orgName: string, courseId: number, confirmed: boolean, createdAt: any, givenName: string, familyName: string };

export type XeroPhoneSummaryFragment = { __typename?: 'XeroPhone', phoneCountryCode?: string | null, phoneAreaCode?: string | null, phoneNumber?: string | null, phoneType: XeroPhoneType };

export type XeroAddressSummaryFragment = { __typename?: 'XeroAddress', addressType?: XeroAddressType | null, addressLine1?: string | null, addressLine2?: string | null, city?: string | null, region?: string | null, postalCode?: string | null, country?: string | null };

export type XeroContactSummaryFragment = { __typename?: 'XeroContact', name: string, firstName?: string | null, lastName?: string | null, emailAddress?: string | null, phones?: Array<{ __typename?: 'XeroPhone', phoneCountryCode?: string | null, phoneAreaCode?: string | null, phoneNumber?: string | null, phoneType: XeroPhoneType } | null> | null, addresses?: Array<{ __typename?: 'XeroAddress', addressType?: XeroAddressType | null, addressLine1?: string | null, addressLine2?: string | null, city?: string | null, region?: string | null, postalCode?: string | null, country?: string | null } | null> | null };

export type XeroItemSummaryFragment = { __typename?: 'XeroItem', itemID: string, code: string };

export type XeroLineItemSummaryFragment = { __typename?: 'XeroLineItem', description?: string | null, quantity: number, unitAmount: number, itemCode: string, accountCode?: string | null, taxType: string, taxAmount: number, lineAmount: number, item?: { __typename?: 'XeroItem', itemID: string, code: string } | null, tracking?: Array<{ __typename?: 'XeroTrackingCategory', name: string, option: string }> | null };

export type XeroInvoiceSummaryFragment = { __typename?: 'XeroInvoice', date: string, total: number, status: XeroInvoiceStatus, dueDate?: string | null, subTotal?: number | null, totalTax?: number | null, invoiceID: string, amountDue?: string | null, reference?: string | null, amountPaid?: string | null, currencyCode: Currency, invoiceNumber?: string | null, fullyPaidOnDate?: string | null, contact: { __typename?: 'XeroContact', name: string, firstName?: string | null, lastName?: string | null, emailAddress?: string | null, phones?: Array<{ __typename?: 'XeroPhone', phoneCountryCode?: string | null, phoneAreaCode?: string | null, phoneNumber?: string | null, phoneType: XeroPhoneType } | null> | null, addresses?: Array<{ __typename?: 'XeroAddress', addressType?: XeroAddressType | null, addressLine1?: string | null, addressLine2?: string | null, city?: string | null, region?: string | null, postalCode?: string | null, country?: string | null } | null> | null }, lineItems: Array<{ __typename?: 'XeroLineItem', description?: string | null, quantity: number, unitAmount: number, itemCode: string, accountCode?: string | null, taxType: string, taxAmount: number, lineAmount: number, item?: { __typename?: 'XeroItem', itemID: string, code: string } | null, tracking?: Array<{ __typename?: 'XeroTrackingCategory', name: string, option: string }> | null } | null> };

export type EstablishmentFragment = { __typename?: 'dfe_establishment', id: any, urn: string, name: string, localAuthority: string, trustType?: string | null, trustName?: string | null, addressLineOne?: string | null, addressLineTwo?: string | null, addressLineThree?: string | null, town?: string | null, county?: string | null, postcode?: string | null, headTitle?: string | null, headFirstName?: string | null, headLastName?: string | null, headJobTitle?: string | null, ofstedRating?: string | null, ofstedLastInspection?: string | null };

export type DeleteGo1LicenseMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type DeleteGo1LicenseMutation = { __typename?: 'mutation_root', delete_go1_licenses_by_pk?: { __typename?: 'go1_licenses', id: any } | null };

export type Go1LicensesChangeMutationVariables = Exact<{
  input: Go1LicensesChangeInput;
}>;


export type Go1LicensesChangeMutation = { __typename?: 'mutation_root', go1LicensesChange?: { __typename?: 'Go1LicensesChangeOutput', success: boolean, error?: Go1ChangeError | null } | null };

export type OrgLicensesWithHistoryQueryVariables = Exact<{
  id: Scalars['uuid'];
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  withHistory?: InputMaybe<Scalars['Boolean']>;
}>;


export type OrgLicensesWithHistoryQuery = { __typename?: 'query_root', organization_by_pk?: { __typename?: 'organization', id: any, go1Licenses?: number | null, reservedGo1Licenses?: number | null, go1LicensesHistory?: Array<{ __typename?: 'go1_licenses_history', id: any, captured_at: any, event: Go1_History_Events_Enum, payload?: any | null, balance: number, reservedBalance: number, change: number }>, go1LicensesHistory_aggregate?: { __typename?: 'go1_licenses_history_aggregate', aggregate?: { __typename?: 'go1_licenses_history_aggregate_fields', count: number } | null } } | null };

export type SaveCourseGradingMutationVariables = Exact<{
  modules: Array<Course_Participant_Module_Insert_Input> | Course_Participant_Module_Insert_Input;
  participantIds?: InputMaybe<Array<Scalars['uuid']> | Scalars['uuid']>;
  grade: Grade_Enum;
  feedback?: InputMaybe<Scalars['String']>;
  courseId: Scalars['Int'];
}>;


export type SaveCourseGradingMutation = { __typename?: 'mutation_root', saveModules?: { __typename?: 'course_participant_module_mutation_response', affectedRows: number } | null, saveParticipantsGrade?: { __typename?: 'course_participant_mutation_response', affectedRows: number } | null, gradingStarted?: { __typename?: 'course', id: number } | null };

export type UpdateGradeMutationVariables = Exact<{
  participantId: Scalars['uuid'];
  oldGrade: Grade_Enum;
  newGrade: Grade_Enum;
  note: Scalars['String'];
  authorId: Scalars['uuid'];
}>;


export type UpdateGradeMutation = { __typename?: 'mutation_root', updateCourseParticipant?: { __typename?: 'course_participant', id: any } | null, insertChangeLog?: { __typename?: 'course_certificate_changelog', id: any } | null };

export type AcceptInviteMutationVariables = Exact<{
  inviteId: Scalars['uuid'];
  courseId: Scalars['Int'];
}>;


export type AcceptInviteMutation = { __typename?: 'mutation_root', acceptInvite?: { __typename?: 'course_invites', status?: Course_Invite_Status_Enum | null } | null, addParticipant?: { __typename?: 'course_participant', id: any } | null };

export type AcceptOrgInviteMutationVariables = Exact<{
  profileId: Scalars['String'];
}>;


export type AcceptOrgInviteMutation = { __typename?: 'mutation_root', invite?: { __typename?: 'AcceptOrgInviteOutput', id: any } | null };

export type CancelCourseInviteMutationVariables = Exact<{
  inviteId: Scalars['uuid'];
}>;


export type CancelCourseInviteMutation = { __typename?: 'mutation_root', delete_course_invites_by_pk?: { __typename?: 'course_invites', id: any } | null };

export type CreateUserMutationVariables = Exact<{
  input: CreateAppUserInput;
}>;


export type CreateUserMutation = { __typename?: 'mutation_root', createUser: { __typename?: 'CreateUserOutput', cognitoId: string, profileId: string, email: string } };

export type DeclineInviteMutationVariables = Exact<{
  note?: InputMaybe<Scalars['String']>;
}>;


export type DeclineInviteMutation = { __typename?: 'mutation_root', invite?: { __typename?: 'DeclineInviteOutput', status: boolean } | null };

export type DeclineOrgInviteMutationVariables = Exact<{ [key: string]: never; }>;


export type DeclineOrgInviteMutation = { __typename?: 'mutation_root', invite?: { __typename?: 'DeclineOrgInviteOutput', id: any } | null };

export type DeleteOrgInviteMutationVariables = Exact<{
  inviteId: Scalars['uuid'];
}>;


export type DeleteOrgInviteMutation = { __typename?: 'mutation_root', delete_organization_invites_by_pk?: { __typename?: 'organization_invites', id: any } | null };

export type GetCourseInvitesQueryVariables = Exact<{
  courseId: Scalars['Int'];
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Course_Invites_Bool_Exp>;
  orderBy?: InputMaybe<Array<Course_Invites_Order_By> | Course_Invites_Order_By>;
}>;


export type GetCourseInvitesQuery = { __typename?: 'query_root', courseInvites: Array<{ __typename?: 'course_invites', id: any, email?: string | null, status?: Course_Invite_Status_Enum | null, createdAt: any }>, courseInvitesAggregate: { __typename?: 'course_invites_aggregate', aggregate?: { __typename?: 'course_invites_aggregate_fields', count: number } | null } };

export type GetInviteQueryVariables = Exact<{ [key: string]: never; }>;


export type GetInviteQuery = { __typename?: 'query_root', invite?: { __typename?: 'CourseInvite', id: string, status: InviteStatus, courseId: string, courseName: string, description?: string | null, trainerName: string, startDate: string, endDate: string, venueName: string, venueCoordinates?: string | null, venueAddress?: { __typename?: 'Address', addressLineOne?: string | null, addressLineTwo?: string | null, city?: string | null, postCode?: string | null } | null } | null };

export type GetOrgInviteQueryVariables = Exact<{ [key: string]: never; }>;


export type GetOrgInviteQuery = { __typename?: 'query_root', invite?: { __typename?: 'OrgInvite', id: string, orgName: string } | null };

export type GetOrgInvitesQueryVariables = Exact<{
  orgId: Scalars['uuid'];
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Organization_Invites_Bool_Exp>;
}>;


export type GetOrgInvitesQuery = { __typename?: 'query_root', orgInvites: Array<{ __typename?: 'organization_invites', id: any, createdAt: any, updatedAt: any, email: string, status: string, isAdmin: boolean, profile?: { __typename?: 'profile', id: any, givenName: string, familyName: string, fullName?: string | null, avatar?: string | null, title?: string | null, tags?: any | null, addresses: any, attributes: any, contactDetails: any, dietaryRestrictions?: string | null, disabilities?: string | null, preferences: any, createdAt: any, updatedAt: any, email?: string | null, phone?: string | null, dob?: any | null, jobTitle?: string | null, dbs?: string | null, lastActivity: any, organizations: Array<{ __typename?: 'organization_member', id: any, isAdmin?: boolean | null, position?: string | null, organization: { __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null } }>, roles: Array<{ __typename?: 'profile_role', role: { __typename?: 'role', id: any, name: string } }>, trainer_role_types: Array<{ __typename?: 'profile_trainer_role_type', trainer_role_type: { __typename?: 'trainer_role_type', id: any, name: string } }> } | null, organization: { __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null } }>, total: { __typename?: 'organization_invites_aggregate', aggregate?: { __typename?: 'organization_invites_aggregate_fields', count: number } | null } };

export type InitAuthQueryVariables = Exact<{ [key: string]: never; }>;


export type InitAuthQuery = { __typename?: 'query_root', initAuth: { __typename?: 'InitAuthOutput', email: string, authChallenge: string } };

export type RecreateCourseInviteMutationVariables = Exact<{
  inviteId: Scalars['uuid'];
  courseId?: InputMaybe<Scalars['Int']>;
  email?: InputMaybe<Scalars['String']>;
}>;


export type RecreateCourseInviteMutation = { __typename?: 'mutation_root', delete_course_invites_by_pk?: { __typename?: 'course_invites', id: any } | null, insert_course_invites_one?: { __typename?: 'course_invites', id: any } | null };

export type RecreateOrgInviteMutationVariables = Exact<{
  inviteId: Scalars['uuid'];
  orgId: Scalars['uuid'];
  email: Scalars['String'];
  isAdmin: Scalars['Boolean'];
}>;


export type RecreateOrgInviteMutation = { __typename?: 'mutation_root', delete_organization_invites_by_pk?: { __typename?: 'organization_invites', id: any } | null, insert_organization_invites_one?: { __typename?: 'organization_invites', id: any } | null };

export type SaveCourseInvitesMutationVariables = Exact<{
  invites: Array<Course_Invites_Insert_Input> | Course_Invites_Insert_Input;
}>;


export type SaveCourseInvitesMutation = { __typename?: 'mutation_root', insert_course_invites?: { __typename?: 'course_invites_mutation_response', returning: Array<{ __typename?: 'course_invites', id: any }> } | null };

export type SaveOrgInvitesMutationVariables = Exact<{
  invites: Array<Organization_Invites_Insert_Input> | Organization_Invites_Insert_Input;
}>;


export type SaveOrgInvitesMutation = { __typename?: 'mutation_root', insert_organization_invites?: { __typename?: 'organization_invites_mutation_response', returning: Array<{ __typename?: 'organization_invites', id: any }> } | null };

export type VerifyUserMutationVariables = Exact<{
  inviteId: Scalars['uuid'];
}>;


export type VerifyUserMutation = { __typename?: 'mutation_root', verifyUser: boolean };

export type BlogQueryVariables = Exact<{
  orderDirection?: OrderEnum;
  term?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  after?: InputMaybe<Scalars['String']>;
  last?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['String']>;
}>;


export type BlogQuery = { __typename?: 'query_root', content?: { __typename?: 'RootQuery', posts?: { __typename?: 'RootQueryToPostConnection', pageInfo?: { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } | null, nodes?: Array<{ __typename?: 'Post', id: string, title?: string | null, excerpt?: string | null, content?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, tags?: { __typename?: 'PostToTagConnection', nodes?: Array<{ __typename?: 'Tag', id: string, name?: string | null } | null> | null } | null, author?: { __typename?: 'NodeWithAuthorToUserConnectionEdge', node?: { __typename?: 'User', firstName?: string | null, lastName?: string | null } | null } | null, customAuthor?: { __typename?: 'Post_Customauthor', displayAuthor?: boolean | null, authorName?: string | null } | null, categories?: { __typename?: 'PostToCategoryConnection', nodes?: Array<{ __typename?: 'Category', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | null };

export type CategoryQueryVariables = Exact<{
  id: Scalars['ID'];
  orderDirection?: InputMaybe<OrderEnum>;
  term?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
}>;


export type CategoryQuery = { __typename?: 'query_root', content?: { __typename?: 'RootQuery', category?: { __typename?: 'Category', id: string, name?: string | null, posts?: { __typename?: 'CategoryToPostConnection', pageInfo?: { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } | null, nodes?: Array<{ __typename?: 'Post', id: string, title?: string | null, excerpt?: string | null, content?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, tags?: { __typename?: 'PostToTagConnection', nodes?: Array<{ __typename?: 'Tag', id: string, name?: string | null } | null> | null } | null, author?: { __typename?: 'NodeWithAuthorToUserConnectionEdge', node?: { __typename?: 'User', firstName?: string | null, lastName?: string | null } | null } | null, customAuthor?: { __typename?: 'Post_Customauthor', displayAuthor?: boolean | null, authorName?: string | null } | null, categories?: { __typename?: 'PostToCategoryConnection', nodes?: Array<{ __typename?: 'Category', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | null } | null };

export type EbooksQueryVariables = Exact<{
  term?: InputMaybe<Scalars['String']>;
  orderDirection?: InputMaybe<OrderEnum>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
}>;


export type EbooksQuery = { __typename?: 'query_root', content?: { __typename?: 'RootQuery', ebooks?: { __typename?: 'RootQueryToEbookConnection', pageInfo?: { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } | null, nodes?: Array<{ __typename?: 'Ebook', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, downloads?: { __typename?: 'Ebook_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, ebooksCategories?: { __typename?: 'EbookToEbooksCategoryConnection', nodes?: Array<{ __typename?: 'EbooksCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | null };

export type MembershipHomeQueryVariables = Exact<{ [key: string]: never; }>;


export type MembershipHomeQuery = { __typename?: 'query_root', podcasts?: { __typename?: 'PodcastsPayload', records: Array<{ __typename?: 'Podcast', id: string, name: string, thumbnail: string, publishedDate: string, mediaUrl: string, author: string, description?: string | null, episodeNumber: number }> } | null, content?: { __typename?: 'RootQuery', posts?: { __typename?: 'RootQueryToPostConnection', nodes?: Array<{ __typename?: 'Post', id: string, title?: string | null, excerpt?: string | null, content?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, tags?: { __typename?: 'PostToTagConnection', nodes?: Array<{ __typename?: 'Tag', id: string, name?: string | null } | null> | null } | null, author?: { __typename?: 'NodeWithAuthorToUserConnectionEdge', node?: { __typename?: 'User', firstName?: string | null, lastName?: string | null } | null } | null, customAuthor?: { __typename?: 'Post_Customauthor', displayAuthor?: boolean | null, authorName?: string | null } | null, categories?: { __typename?: 'PostToCategoryConnection', nodes?: Array<{ __typename?: 'Category', id: string, name?: string | null } | null> | null } | null } | null> | null } | null, videoSeriesItems?: { __typename?: 'RootQueryToVideoSeriesItemConnection', nodes?: Array<{ __typename?: 'VideoSeriesItem', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, youtube?: { __typename?: 'VideoSeriesItem_Youtube', url?: string | null, duration?: number | null } | null, downloads?: { __typename?: 'VideoSeriesItem_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, videoSeriesCategories?: { __typename?: 'VideoSeriesItemToVideoSeriesCategoryConnection', nodes?: Array<{ __typename?: 'VideoSeriesCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null, researchSummaries?: { __typename?: 'RootQueryToResearchSummaryConnection', nodes?: Array<{ __typename?: 'ResearchSummary', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, downloads?: { __typename?: 'ResearchSummary_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, researchSummariesCategories?: { __typename?: 'ResearchSummaryToResearchSummariesCategoryConnection', nodes?: Array<{ __typename?: 'ResearchSummariesCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null, webinars?: { __typename?: 'RootQueryToWebinarConnection', nodes?: Array<{ __typename?: 'Webinar', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, youtube?: { __typename?: 'Webinar_Youtube', url?: string | null, duration?: number | null } | null, webinarsCategories?: { __typename?: 'WebinarToWebinarsCategoryConnection', nodes?: Array<{ __typename?: 'WebinarsCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null, ebooks?: { __typename?: 'RootQueryToEbookConnection', nodes?: Array<{ __typename?: 'Ebook', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, downloads?: { __typename?: 'Ebook_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, ebooksCategories?: { __typename?: 'EbookToEbooksCategoryConnection', nodes?: Array<{ __typename?: 'EbooksCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | null };

export type PodcastQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PodcastQuery = { __typename?: 'query_root', podcast?: { __typename?: 'PodcastPayload', podcast?: { __typename?: 'Podcast', id: string, name: string, thumbnail: string, publishedDate: string, mediaUrl: string, author: string, description?: string | null, episodeNumber: number } | null } | null, recentPodcasts?: { __typename?: 'PodcastsPayload', records: Array<{ __typename?: 'Podcast', id: string, name: string, thumbnail: string, publishedDate: string, mediaUrl: string, author: string, description?: string | null, episodeNumber: number }> } | null };

export type PodcastsQueryVariables = Exact<{
  input: PodcastsInput;
}>;


export type PodcastsQuery = { __typename?: 'query_root', podcasts?: { __typename?: 'PodcastsPayload', total: number, records: Array<{ __typename?: 'Podcast', id: string, name: string, thumbnail: string, publishedDate: string, mediaUrl: string, author: string, description?: string | null, episodeNumber: number }> } | null };

export type PostQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type PostQuery = { __typename?: 'query_root', content?: { __typename?: 'RootQuery', post?: { __typename?: 'Post', id: string, title?: string | null, excerpt?: string | null, content?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, tags?: { __typename?: 'PostToTagConnection', nodes?: Array<{ __typename?: 'Tag', id: string, name?: string | null } | null> | null } | null, author?: { __typename?: 'NodeWithAuthorToUserConnectionEdge', node?: { __typename?: 'User', firstName?: string | null, lastName?: string | null } | null } | null, customAuthor?: { __typename?: 'Post_Customauthor', displayAuthor?: boolean | null, authorName?: string | null } | null, categories?: { __typename?: 'PostToCategoryConnection', nodes?: Array<{ __typename?: 'Category', id: string, name?: string | null } | null> | null } | null } | null, recentPosts?: { __typename?: 'RootQueryToPostConnection', nodes?: Array<{ __typename?: 'Post', id: string, title?: string | null, excerpt?: string | null, content?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, tags?: { __typename?: 'PostToTagConnection', nodes?: Array<{ __typename?: 'Tag', id: string, name?: string | null } | null> | null } | null, author?: { __typename?: 'NodeWithAuthorToUserConnectionEdge', node?: { __typename?: 'User', firstName?: string | null, lastName?: string | null } | null } | null, customAuthor?: { __typename?: 'Post_Customauthor', displayAuthor?: boolean | null, authorName?: string | null } | null, categories?: { __typename?: 'PostToCategoryConnection', nodes?: Array<{ __typename?: 'Category', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | null };

export type ResearchSummariesQueryVariables = Exact<{
  term?: InputMaybe<Scalars['String']>;
  orderDirection?: InputMaybe<OrderEnum>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
}>;


export type ResearchSummariesQuery = { __typename?: 'query_root', content?: { __typename?: 'RootQuery', researchSummaries?: { __typename?: 'RootQueryToResearchSummaryConnection', pageInfo?: { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } | null, nodes?: Array<{ __typename?: 'ResearchSummary', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, downloads?: { __typename?: 'ResearchSummary_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, researchSummariesCategories?: { __typename?: 'ResearchSummaryToResearchSummariesCategoryConnection', nodes?: Array<{ __typename?: 'ResearchSummariesCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | null };

export type TagQueryVariables = Exact<{
  id: Scalars['ID'];
  orderDirection?: InputMaybe<OrderEnum>;
  term?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
}>;


export type TagQuery = { __typename?: 'query_root', content?: { __typename?: 'RootQuery', tag?: { __typename?: 'Tag', id: string, name?: string | null, posts?: { __typename?: 'TagToPostConnection', pageInfo?: { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, endCursor?: string | null, startCursor?: string | null } | null, nodes?: Array<{ __typename?: 'Post', id: string, title?: string | null, excerpt?: string | null, content?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, tags?: { __typename?: 'PostToTagConnection', nodes?: Array<{ __typename?: 'Tag', id: string, name?: string | null } | null> | null } | null, author?: { __typename?: 'NodeWithAuthorToUserConnectionEdge', node?: { __typename?: 'User', firstName?: string | null, lastName?: string | null } | null } | null, customAuthor?: { __typename?: 'Post_Customauthor', displayAuthor?: boolean | null, authorName?: string | null } | null, categories?: { __typename?: 'PostToCategoryConnection', nodes?: Array<{ __typename?: 'Category', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | null } | null };

export type PaginationInfoFragment = { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null };

export type TermQueryVariables = Exact<{
  id: Scalars['ID'];
  orderDirection?: InputMaybe<OrderEnum>;
  term?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
}>;


export type TermQuery = { __typename?: 'query_root', content?: { __typename?: 'RootQuery', termNode?: { __typename: 'Category', id: string, name?: string | null, posts?: { __typename?: 'CategoryToPostConnection', pageInfo?: { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } | null, nodes?: Array<{ __typename?: 'Post', id: string, title?: string | null, excerpt?: string | null, content?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, tags?: { __typename?: 'PostToTagConnection', nodes?: Array<{ __typename?: 'Tag', id: string, name?: string | null } | null> | null } | null, author?: { __typename?: 'NodeWithAuthorToUserConnectionEdge', node?: { __typename?: 'User', firstName?: string | null, lastName?: string | null } | null } | null, customAuthor?: { __typename?: 'Post_Customauthor', displayAuthor?: boolean | null, authorName?: string | null } | null, categories?: { __typename?: 'PostToCategoryConnection', nodes?: Array<{ __typename?: 'Category', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | { __typename: 'EbooksCategory', id: string, name?: string | null, ebooks?: { __typename?: 'EbooksCategoryToEbookConnection', pageInfo?: { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } | null, nodes?: Array<{ __typename?: 'Ebook', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, downloads?: { __typename?: 'Ebook_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, ebooksCategories?: { __typename?: 'EbookToEbooksCategoryConnection', nodes?: Array<{ __typename?: 'EbooksCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | { __typename: 'PostFormat', id: string, name?: string | null } | { __typename: 'ResearchSummariesCategory', id: string, name?: string | null, researchSummaries?: { __typename?: 'ResearchSummariesCategoryToResearchSummaryConnection', pageInfo?: { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } | null, nodes?: Array<{ __typename?: 'ResearchSummary', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, downloads?: { __typename?: 'ResearchSummary_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, researchSummariesCategories?: { __typename?: 'ResearchSummaryToResearchSummariesCategoryConnection', nodes?: Array<{ __typename?: 'ResearchSummariesCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | { __typename: 'ResourceCategory', id: string, name?: string | null } | { __typename: 'Tag', id: string, name?: string | null, posts?: { __typename?: 'TagToPostConnection', pageInfo?: { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } | null, nodes?: Array<{ __typename?: 'Post', id: string, title?: string | null, excerpt?: string | null, content?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, tags?: { __typename?: 'PostToTagConnection', nodes?: Array<{ __typename?: 'Tag', id: string, name?: string | null } | null> | null } | null, author?: { __typename?: 'NodeWithAuthorToUserConnectionEdge', node?: { __typename?: 'User', firstName?: string | null, lastName?: string | null } | null } | null, customAuthor?: { __typename?: 'Post_Customauthor', displayAuthor?: boolean | null, authorName?: string | null } | null, categories?: { __typename?: 'PostToCategoryConnection', nodes?: Array<{ __typename?: 'Category', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | { __typename: 'VideoSeriesCategory', id: string, name?: string | null, videoSeriesItems?: { __typename?: 'VideoSeriesCategoryToVideoSeriesItemConnection', pageInfo?: { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } | null, nodes?: Array<{ __typename?: 'VideoSeriesItem', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, youtube?: { __typename?: 'VideoSeriesItem_Youtube', url?: string | null, duration?: number | null } | null, downloads?: { __typename?: 'VideoSeriesItem_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, videoSeriesCategories?: { __typename?: 'VideoSeriesItemToVideoSeriesCategoryConnection', nodes?: Array<{ __typename?: 'VideoSeriesCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | { __typename: 'WebinarsCategory', id: string, name?: string | null, webinars?: { __typename?: 'WebinarsCategoryToWebinarConnection', pageInfo?: { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: string | null, endCursor?: string | null } | null, nodes?: Array<{ __typename?: 'Webinar', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, youtube?: { __typename?: 'Webinar_Youtube', url?: string | null, duration?: number | null } | null, webinarsCategories?: { __typename?: 'WebinarToWebinarsCategoryConnection', nodes?: Array<{ __typename?: 'WebinarsCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | null } | null };

export type VideoItemQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type VideoItemQuery = { __typename?: 'query_root', content?: { __typename?: 'RootQuery', videoSeriesItem?: { __typename?: 'VideoSeriesItem', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, youtube?: { __typename?: 'VideoSeriesItem_Youtube', url?: string | null, duration?: number | null } | null, downloads?: { __typename?: 'VideoSeriesItem_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, videoSeriesCategories?: { __typename?: 'VideoSeriesItemToVideoSeriesCategoryConnection', nodes?: Array<{ __typename?: 'VideoSeriesCategory', id: string, name?: string | null } | null> | null } | null } | null, recentVideoItems?: { __typename?: 'RootQueryToVideoSeriesItemConnection', nodes?: Array<{ __typename?: 'VideoSeriesItem', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, youtube?: { __typename?: 'VideoSeriesItem_Youtube', url?: string | null, duration?: number | null } | null, downloads?: { __typename?: 'VideoSeriesItem_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, videoSeriesCategories?: { __typename?: 'VideoSeriesItemToVideoSeriesCategoryConnection', nodes?: Array<{ __typename?: 'VideoSeriesCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | null };

export type VideoSeriesQueryVariables = Exact<{
  term?: InputMaybe<Scalars['String']>;
  orderDirection?: InputMaybe<OrderEnum>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
}>;


export type VideoSeriesQuery = { __typename?: 'query_root', content?: { __typename?: 'RootQuery', videoSeriesItems?: { __typename?: 'RootQueryToVideoSeriesItemConnection', pageInfo?: { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, endCursor?: string | null, startCursor?: string | null } | null, nodes?: Array<{ __typename?: 'VideoSeriesItem', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, youtube?: { __typename?: 'VideoSeriesItem_Youtube', url?: string | null, duration?: number | null } | null, downloads?: { __typename?: 'VideoSeriesItem_Downloads', file?: { __typename?: 'MediaItem', mediaItemUrl?: string | null } | null } | null, videoSeriesCategories?: { __typename?: 'VideoSeriesItemToVideoSeriesCategoryConnection', nodes?: Array<{ __typename?: 'VideoSeriesCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | null };

export type WebinarQueryVariables = Exact<{
  id: Scalars['ID'];
}>;


export type WebinarQuery = { __typename?: 'query_root', content?: { __typename?: 'RootQuery', webinar?: { __typename?: 'Webinar', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, youtube?: { __typename?: 'Webinar_Youtube', url?: string | null, duration?: number | null } | null, webinarsCategories?: { __typename?: 'WebinarToWebinarsCategoryConnection', nodes?: Array<{ __typename?: 'WebinarsCategory', id: string, name?: string | null } | null> | null } | null } | null, recentWebinars?: { __typename?: 'RootQueryToWebinarConnection', nodes?: Array<{ __typename?: 'Webinar', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, youtube?: { __typename?: 'Webinar_Youtube', url?: string | null, duration?: number | null } | null, webinarsCategories?: { __typename?: 'WebinarToWebinarsCategoryConnection', nodes?: Array<{ __typename?: 'WebinarsCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | null };

export type WebinarsQueryVariables = Exact<{
  term?: InputMaybe<Scalars['String']>;
  orderDirection?: InputMaybe<OrderEnum>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
}>;


export type WebinarsQuery = { __typename?: 'query_root', content?: { __typename?: 'RootQuery', webinars?: { __typename?: 'RootQueryToWebinarConnection', pageInfo?: { __typename?: 'WPPageInfo', hasNextPage: boolean, hasPreviousPage: boolean, endCursor?: string | null, startCursor?: string | null } | null, nodes?: Array<{ __typename?: 'Webinar', id: string, title?: string | null, excerpt?: string | null, date?: string | null, featuredImage?: { __typename?: 'NodeWithFeaturedImageToMediaItemConnectionEdge', node?: { __typename?: 'MediaItem', mediaItemUrl?: string | null, srcSet?: string | null } | null } | null, youtube?: { __typename?: 'Webinar_Youtube', url?: string | null, duration?: number | null } | null, webinarsCategories?: { __typename?: 'WebinarToWebinarsCategoryConnection', nodes?: Array<{ __typename?: 'WebinarsCategory', id: string, name?: string | null } | null> | null } | null } | null> | null } | null } | null };

export type ModuleGroupsQueryVariables = Exact<{
  level: Course_Level_Enum;
  courseDeliveryType: Course_Delivery_Type_Enum;
  reaccreditation: Scalars['Boolean'];
  go1Integration: Scalars['Boolean'];
}>;


export type ModuleGroupsQuery = { __typename?: 'query_root', groups: Array<{ __typename?: 'module_group', id: any, name: string, level: Course_Level_Enum, color: Color_Enum, mandatory: boolean, createdAt: any, updatedAt: any, modules: Array<{ __typename?: 'module', id: any, name: string, description?: string | null, level: Course_Level_Enum, type: Module_Category_Enum, createdAt: any, updatedAt: any }>, duration: { __typename?: 'module_group_duration_aggregate', aggregate?: { __typename?: 'module_group_duration_aggregate_fields', sum?: { __typename?: 'module_group_duration_sum_fields', duration?: number | null } | null } | null } }> };

export type CreateOrderMutationVariables = Exact<{
  input: CreateOrderInput;
}>;


export type CreateOrderMutation = { __typename?: 'mutation_root', order?: { __typename?: 'CreateOrderOutput', id: any } | null };

export type GetOrderQueryVariables = Exact<{
  orderId: Scalars['uuid'];
}>;


export type GetOrderQuery = { __typename?: 'query_root', order?: { __typename?: 'order', id: any, courseId: number, profileId: any, quantity: number, registrants: any, paymentMethod: Payment_Methods_Enum, orderDue?: any | null, orderTotal?: any | null, currency?: string | null, stripePaymentId?: string | null, promoCodes?: any | null, xeroInvoiceNumber?: string | null, profile: { __typename?: 'profile', fullName?: string | null, email?: string | null, phone?: string | null }, course: { __typename?: 'course', id: number, course_code?: string | null, level: Course_Level_Enum, name: string, type: Course_Type_Enum, start?: any | null, end?: any | null, salesRepresentative?: { __typename?: 'profile', fullName?: string | null } | null } } | null };

export type GetOrdersQueryVariables = Exact<{
  orderBy?: InputMaybe<Array<Order_Order_By> | Order_Order_By>;
  where?: InputMaybe<Order_Bool_Exp>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
}>;


export type GetOrdersQuery = { __typename?: 'query_root', orders: Array<{ __typename?: 'order', id: any, createdAt: any, profileId: any, quantity: number, registrants: any, paymentMethod: Payment_Methods_Enum, orderDue?: any | null, orderTotal?: any | null, currency?: string | null, stripePaymentId?: string | null, xeroInvoiceNumber?: string | null, promoCodes?: any | null, course: { __typename?: 'course', name: string, schedule: Array<{ __typename?: 'course_schedule', start: any }> }, organization: { __typename?: 'organization', name: string, id: any } }>, order_aggregate: { __typename?: 'order_aggregate', aggregate?: { __typename?: 'order_aggregate_fields', count: number } | null } };

export type GetOrgWithKeyContactsQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetOrgWithKeyContactsQuery = { __typename?: 'query_root', organization?: { __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null, members: Array<{ __typename?: 'organization_member', profile: { __typename?: 'profile', id: any, givenName: string, familyName: string, fullName?: string | null, avatar?: string | null, title?: string | null, tags?: any | null, addresses: any, attributes: any, contactDetails: any, dietaryRestrictions?: string | null, disabilities?: string | null, preferences: any, createdAt: any, updatedAt: any, email?: string | null, phone?: string | null, dob?: any | null, jobTitle?: string | null, dbs?: string | null, lastActivity: any, organizations: Array<{ __typename?: 'organization_member', id: any, isAdmin?: boolean | null, position?: string | null, organization: { __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null } }>, roles: Array<{ __typename?: 'profile_role', role: { __typename?: 'role', id: any, name: string } }>, trainer_role_types: Array<{ __typename?: 'profile_trainer_role_type', trainer_role_type: { __typename?: 'trainer_role_type', id: any, name: string } }> } }> } | null };

export type GetOrgDetailsQueryVariables = Exact<{
  where?: InputMaybe<Organization_Bool_Exp>;
}>;


export type GetOrgDetailsQuery = { __typename?: 'query_root', orgs: Array<{ __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null }>, profiles: Array<{ __typename?: 'profile', id: any, fullName?: string | null, avatar?: string | null, lastActivity: any, createdAt: any, certificates: Array<{ __typename?: 'course_certificate', id: any, courseLevel: string, expiryDate: any, status?: string | null }>, go1Licenses: Array<{ __typename?: 'go1_licenses', id: any, expireDate: any }>, upcomingEnrollments: Array<{ __typename?: 'upcoming_enrollments', orgId?: any | null, orgName?: string | null, courseLevel?: string | null, courseId?: number | null }>, organizations: Array<{ __typename?: 'organization_member', id: any, position?: string | null, isAdmin?: boolean | null, profile: { __typename?: 'profile', fullName?: string | null }, organization: { __typename?: 'organization', id: any, name: string } }> }>, pendingInvitesCount: { __typename?: 'organization_invites_aggregate', aggregate?: { __typename?: 'organization_invites_aggregate_fields', count: number } | null } };

export type GetOrgUsersQueryVariables = Exact<{
  orgId: Scalars['uuid'];
  orderBy?: InputMaybe<Array<Organization_Member_Order_By> | Organization_Member_Order_By>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
}>;


export type GetOrgUsersQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'organization_member', id: any, isAdmin?: boolean | null, position?: string | null, profile: { __typename?: 'profile', id: any, givenName: string, familyName: string, fullName?: string | null, avatar?: string | null, title?: string | null, tags?: any | null, addresses: any, attributes: any, contactDetails: any, dietaryRestrictions?: string | null, disabilities?: string | null, preferences: any, createdAt: any, updatedAt: any, email?: string | null, phone?: string | null, dob?: any | null, jobTitle?: string | null, dbs?: string | null, lastActivity: any, activeCertificates: { __typename?: 'course_certificate_aggregate', aggregate?: { __typename?: 'course_certificate_aggregate_fields', count: number } | null }, organizations: Array<{ __typename?: 'organization_member', id: any, isAdmin?: boolean | null, position?: string | null, organization: { __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null } }>, roles: Array<{ __typename?: 'profile_role', role: { __typename?: 'role', id: any, name: string } }>, trainer_role_types: Array<{ __typename?: 'profile_trainer_role_type', trainer_role_type: { __typename?: 'trainer_role_type', id: any, name: string } }> } }>, total: { __typename?: 'organization_member_aggregate', aggregate?: { __typename?: 'organization_member_aggregate_fields', count: number } | null } };

export type GetOrganizationsQueryVariables = Exact<{
  orderBy?: InputMaybe<Array<Organization_Order_By> | Organization_Order_By>;
  where?: InputMaybe<Organization_Bool_Exp>;
}>;


export type GetOrganizationsQuery = { __typename?: 'query_root', orgs: Array<{ __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null, members: Array<{ __typename?: 'organization_member', profile: { __typename?: 'profile', lastActivity: any } }> }> };

export type InsertOrgMutationVariables = Exact<{
  name: Scalars['String'];
  trustName: Scalars['String'];
  trustType: Trust_Type_Enum;
  address: Scalars['jsonb'];
  attributes?: InputMaybe<Scalars['jsonb']>;
  xeroId?: InputMaybe<Scalars['String']>;
  invites?: InputMaybe<Array<Organization_Invites_Insert_Input> | Organization_Invites_Insert_Input>;
}>;


export type InsertOrgMutation = { __typename?: 'mutation_root', org?: { __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null } | null };

export type RemoveOrgMemberMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type RemoveOrgMemberMutation = { __typename?: 'mutation_root', delete_organization_member_by_pk?: { __typename?: 'organization_member', id: any } | null };

export type UpdateOrgMemberMutationVariables = Exact<{
  id: Scalars['uuid'];
  member: Organization_Member_Set_Input;
}>;


export type UpdateOrgMemberMutation = { __typename?: 'mutation_root', updated?: { __typename?: 'organization_member', id: any } | null };

export type UpdateOrgMutationVariables = Exact<{
  org?: InputMaybe<Organization_Set_Input>;
  id: Scalars['uuid'];
}>;


export type UpdateOrgMutation = { __typename?: 'mutation_root', updated?: { __typename?: 'organization', id: any } | null };

export type CancelIndividualFromCourseMutationVariables = Exact<{
  courseId: Scalars['Int'];
  profileId: Scalars['uuid'];
  reason: Scalars['String'];
  fee: Scalars['Int'];
}>;


export type CancelIndividualFromCourseMutation = { __typename?: 'mutation_root', cancelIndividualFromCourse: boolean };

export type CourseParticipantQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type CourseParticipantQuery = { __typename?: 'query_root', participant?: { __typename?: 'course_participant', id: any, attended?: boolean | null, grade?: Grade_Enum | null, dateGraded?: any | null, course: { __typename?: 'course', id: number, name: string, level: Course_Level_Enum, deliveryType: Course_Delivery_Type_Enum }, profile: { __typename?: 'profile', fullName?: string | null, email?: string | null, contactDetails: any, organizations: Array<{ __typename?: 'organization_member', organization: { __typename?: 'organization', id: any, name: string } }> }, gradingModules: Array<{ __typename?: 'course_participant_module', id: any, completed: boolean, module: { __typename?: 'module', id: any, name: string, moduleGroup?: { __typename?: 'module_group', id: any, name: string } | null } }>, certificate?: { __typename?: 'course_certificate', id: any, createdAt: any, updatedAt: any, number: string, expiryDate: any, certificationDate: any, courseName: string, courseLevel: string } | null } | null };

export type GetCourseParticipantIdQueryVariables = Exact<{
  profileId: Scalars['uuid'];
  courseId: Scalars['Int'];
}>;


export type GetCourseParticipantIdQuery = { __typename?: 'query_root', course_participant: Array<{ __typename?: 'course_participant', id: any, grade?: Grade_Enum | null, dateGraded?: any | null, attended?: boolean | null, healthSafetyConsent: boolean, profile: { __typename?: 'profile', fullName?: string | null }, gradingModules: Array<{ __typename?: 'course_participant_module', completed: boolean, module: { __typename?: 'module', id: any, name: string, moduleGroup?: { __typename?: 'module_group', id: any, name: string } | null } }>, certificate?: { __typename?: 'course_certificate', id: any, createdAt: any, updatedAt: any, number: string, expiryDate: any, certificationDate: any, courseName: string, courseLevel: string } | null }> };

export type CourseParticipantsQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Array<Course_Participant_Order_By> | Course_Participant_Order_By>;
  where?: InputMaybe<Course_Participant_Bool_Exp>;
}>;


export type CourseParticipantsQuery = { __typename?: 'query_root', courseParticipants: Array<{ __typename?: 'course_participant', id: any, attended?: boolean | null, invoiceID?: any | null, bookingDate?: any | null, go1EnrolmentStatus?: Blended_Learning_Status_Enum | null, grade?: Grade_Enum | null, profile: { __typename?: 'profile', id: any, fullName?: string | null, avatar?: string | null, email?: string | null, contactDetails: any, organizations: Array<{ __typename?: 'organization_member', organization: { __typename?: 'organization', id: any, name: string } }> }, certificate?: { __typename?: 'course_certificate', id: any, createdAt: any, updatedAt: any, number: string, expiryDate: any, certificationDate: any, courseName: string, courseLevel: string } | null, course: { __typename?: 'course', id: number, createdAt: any, updatedAt: any, name: string, type: Course_Type_Enum, deliveryType: Course_Delivery_Type_Enum, status?: Course_Status_Enum | null, level: Course_Level_Enum, course_code?: string | null, reaccreditation?: boolean | null, min_participants: number, max_participants: number, gradingConfirmed: boolean, gradingStarted: boolean, go1Integration: boolean, aolCostOfCourse?: any | null, aolCountry?: string | null, aolRegion?: string | null, modulesDuration: number, notes?: string | null, start?: any | null, end?: any | null } }>, courseParticipantsAggregation: { __typename?: 'course_participant_aggregate', aggregate?: { __typename?: 'course_participant_aggregate_fields', count: number } | null } };

export type DeleteTempProfileMutationVariables = Exact<{
  email: Scalars['String'];
}>;


export type DeleteTempProfileMutation = { __typename?: 'mutation_root', deleted?: { __typename?: 'profile_temp_mutation_response', affectedRows: number } | null };

export type FindProfilesQueryVariables = Exact<{
  where?: InputMaybe<Profile_Bool_Exp>;
}>;


export type FindProfilesQuery = { __typename?: 'query_root', profiles: Array<{ __typename?: 'profile', id: any, givenName: string, familyName: string, fullName?: string | null, avatar?: string | null, title?: string | null, tags?: any | null, addresses: any, attributes: any, contactDetails: any, dietaryRestrictions?: string | null, disabilities?: string | null, preferences: any, createdAt: any, updatedAt: any, email?: string | null, phone?: string | null, dob?: any | null, jobTitle?: string | null, dbs?: string | null, lastActivity: any, organizations: Array<{ __typename?: 'organization_member', id: any, isAdmin?: boolean | null, position?: string | null, organization: { __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null } }>, roles: Array<{ __typename?: 'profile_role', role: { __typename?: 'role', id: any, name: string } }>, trainer_role_types: Array<{ __typename?: 'profile_trainer_role_type', trainer_role_type: { __typename?: 'trainer_role_type', id: any, name: string } }> }> };

export type GetProfileDetailsQueryVariables = Exact<{
  profileId: Scalars['uuid'];
  withGo1Licenses?: InputMaybe<Scalars['Boolean']>;
  orgId?: InputMaybe<Scalars['uuid']>;
  withCourseHistory?: InputMaybe<Scalars['Boolean']>;
}>;


export type GetProfileDetailsQuery = { __typename?: 'query_root', profile?: { __typename?: 'profile', id: any, givenName: string, familyName: string, fullName?: string | null, avatar?: string | null, title?: string | null, tags?: any | null, addresses: any, attributes: any, contactDetails: any, dietaryRestrictions?: string | null, disabilities?: string | null, preferences: any, createdAt: any, updatedAt: any, email?: string | null, phone?: string | null, dob?: any | null, jobTitle?: string | null, dbs?: string | null, lastActivity: any, participantAudits: Array<{ __typename?: 'course_participant_audit', id: any, course_id: number, type: Course_Participant_Audit_Type_Enum, course: { __typename?: 'course', name: string, status?: Course_Status_Enum | null, dates: { __typename?: 'course_schedule_aggregate', aggregate?: { __typename?: 'course_schedule_aggregate_fields', start?: { __typename?: 'course_schedule_min_fields', date?: any | null } | null, end?: { __typename?: 'course_schedule_max_fields', date?: any | null } | null } | null } } }>, courses: Array<{ __typename?: 'course_participant', id: any, course: { __typename?: 'course', id: number, name: string, status?: Course_Status_Enum | null } }>, go1Licenses?: Array<{ __typename?: 'go1_licenses', id: any, orgId: any, expireDate: any, enrolledOn: any }>, organizations: Array<{ __typename?: 'organization_member', id: any, isAdmin?: boolean | null, position?: string | null, organization: { __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null } }>, roles: Array<{ __typename?: 'profile_role', role: { __typename?: 'role', id: any, name: string } }>, trainer_role_types: Array<{ __typename?: 'profile_trainer_role_type', trainer_role_type: { __typename?: 'trainer_role_type', id: any, name: string } }> } | null, certificates: Array<{ __typename?: 'course_certificate', id: any, createdAt: any, updatedAt: any, number: string, expiryDate: any, certificationDate: any, courseName: string, courseLevel: string, participant?: { __typename?: 'course_participant', grade?: Grade_Enum | null } | null }>, upcomingCourses: Array<{ __typename?: 'course', id: number, level: Course_Level_Enum }> };

export type GetProfilesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Profile_Bool_Exp>;
}>;


export type GetProfilesQuery = { __typename?: 'query_root', profiles: Array<{ __typename?: 'profile', id: any, fullName?: string | null, avatar?: string | null, email?: string | null, organizations: Array<{ __typename?: 'organization_member', organization: { __typename?: 'organization', id: any, name: string } }>, roles: Array<{ __typename?: 'profile_role', role: { __typename?: 'role', id: any, name: string } }>, trainer_role_types: Array<{ __typename?: 'profile_trainer_role_type', trainer_role_type: { __typename?: 'trainer_role_type', name: string, id: any } }> }>, profile_aggregate: { __typename?: 'profile_aggregate', aggregate?: { __typename?: 'profile_aggregate_fields', count: number } | null } };

export type GetTempProfileQueryVariables = Exact<{ [key: string]: never; }>;


export type GetTempProfileQuery = { __typename?: 'query_root', tempProfiles: Array<{ __typename?: 'profile_temp', quantity?: number | null, course?: { __typename?: 'course', id: number, name: string, type: Course_Type_Enum, level: Course_Level_Enum, freeSpaces?: number | null, maxParticipants: number, dates: { __typename?: 'course_schedule_aggregate', aggregate?: { __typename?: 'course_schedule_aggregate_fields', start?: { __typename?: 'course_schedule_min_fields', date?: any | null } | null, end?: { __typename?: 'course_schedule_max_fields', date?: any | null } | null } | null }, participants: { __typename?: 'course_participant_aggregate', aggregate?: { __typename?: 'course_participant_aggregate_fields', count: number } | null }, expenses: Array<{ __typename?: 'course_expenses', id: any, data: any, trainer: { __typename?: 'profile', id: any, fullName?: string | null } }>, schedule: Array<{ __typename?: 'course_schedule', venue?: { __typename?: 'venue', id: any, createdAt: any, updatedAt: any, name: string, city: string, addressLineOne: string, addressLineTwo?: string | null, postCode: string, geoCoordinates?: any | null, googlePlacesId?: string | null } | null }> } | null }> };

export type InsertProfileTempMutationVariables = Exact<{
  input: Profile_Temp_Insert_Input;
}>;


export type InsertProfileTempMutation = { __typename?: 'mutation_root', profile?: { __typename?: 'profile_temp_mutation_response', affectedRows: number } | null };

export type UpdateProfileActivityMutationVariables = Exact<{
  profileId: Scalars['uuid'];
}>;


export type UpdateProfileActivityMutation = { __typename?: 'mutation_root', update_profile_by_pk?: { __typename?: 'profile', id: any } | null };

export type UpdateAvatarMutationVariables = Exact<{
  avatar: Scalars['bytea'];
}>;


export type UpdateAvatarMutation = { __typename?: 'mutation_root', updateAvatar?: { __typename?: 'UpdateAvatarResponse', avatar: string } | null };

export type UpdateProfileRolesMutationVariables = Exact<{
  id: Scalars['uuid'];
  roles: Array<Profile_Role_Insert_Input> | Profile_Role_Insert_Input;
}>;


export type UpdateProfileRolesMutation = { __typename?: 'mutation_root', delete_profile_role?: { __typename?: 'profile_role_mutation_response', affected_rows: number } | null, insert_profile_role?: { __typename?: 'profile_role_mutation_response', affected_rows: number } | null };

export type UpdateProfileMutationVariables = Exact<{
  input?: InputMaybe<Profile_Set_Input>;
  profileId: Scalars['uuid'];
}>;


export type UpdateProfileMutation = { __typename?: 'mutation_root', updated?: { __typename?: 'profile', id: any } | null };

export type ApproveCodeMutationVariables = Exact<{
  id: Scalars['uuid'];
  approvedBy?: InputMaybe<Scalars['uuid']>;
}>;


export type ApproveCodeMutation = { __typename?: 'mutation_root', update_promo_code_by_pk?: { __typename?: 'promo_code', id: any } | null };

export type DenyCodeMutationVariables = Exact<{
  id: Scalars['uuid'];
  deniedBy?: InputMaybe<Scalars['uuid']>;
}>;


export type DenyCodeMutation = { __typename?: 'mutation_root', update_promo_code_by_pk?: { __typename?: 'promo_code', id: any } | null };

export type CanApplyPromoCodeQueryVariables = Exact<{
  input: CanApplyPromoCodeInput;
}>;


export type CanApplyPromoCodeQuery = { __typename?: 'query_root', canApplyPromoCode: { __typename?: 'CanApplyPromoCodeOutput', result?: { __typename?: 'PromoCodeOutput', code: string, amount: number, type: string } | null } };

export type GetPromoCodesQueryVariables = Exact<{
  orderBy?: InputMaybe<Array<Promo_Code_Order_By> | Promo_Code_Order_By>;
  where?: InputMaybe<Promo_Code_Bool_Exp>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
}>;


export type GetPromoCodesQuery = { __typename?: 'query_root', promoCodes: Array<{ __typename?: 'promo_code', id: any, code: string, description?: string | null, type: Promo_Code_Type_Enum, amount: any, validFrom: any, validTo?: any | null, bookerSingleUse: boolean, usesMax?: any | null, levels: any, enabled: boolean, approvedBy?: any | null, deniedBy?: any | null, createdBy: any, createdAt: any, updatedAt: any, courses: Array<{ __typename?: 'course_promo_code', course?: { __typename?: 'course', id: number, course_code?: string | null } | null }>, creator: { __typename?: 'profile', id: any, fullName?: string | null, avatar?: string | null } }>, promo_code_aggregate: { __typename?: 'promo_code_aggregate', aggregate?: { __typename?: 'promo_code_aggregate_fields', count: number } | null } };

export type InsertPromoCodeMutationVariables = Exact<{
  promoCode: Promo_Code_Insert_Input;
}>;


export type InsertPromoCodeMutation = { __typename?: 'mutation_root', insert_promo_code_one?: { __typename?: 'promo_code', id: any } | null };

export type TrainerScheduleQueryVariables = Exact<{ [key: string]: never; }>;


export type TrainerScheduleQuery = { __typename?: 'query_root', course: Array<{ __typename?: 'course', id: number, name: string, schedule: Array<{ __typename?: 'course_schedule', id: any, start: any, end: any, venue?: { __typename?: 'venue', city: string, addressLineOne: string, addressLineTwo?: string | null } | null }>, participants: { __typename?: 'course_participant_aggregate', aggregate?: { __typename?: 'course_participant_aggregate_fields', count: number } | null } }> };

export type GetTrainerRoleTypesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetTrainerRoleTypesQuery = { __typename?: 'query_root', trainer_role_type: Array<{ __typename?: 'trainer_role_type', id: any, name: string }> };

export type UpdateTrainerRoleTypeMutationVariables = Exact<{
  id: Scalars['uuid'];
  trainerRoleTypes: Array<Profile_Trainer_Role_Type_Insert_Input> | Profile_Trainer_Role_Type_Insert_Input;
}>;


export type UpdateTrainerRoleTypeMutation = { __typename?: 'mutation_root', delete_profile_trainer_role_type?: { __typename?: 'profile_trainer_role_type_mutation_response', affected_rows: number } | null, insert_profile_trainer_role_type?: { __typename?: 'profile_trainer_role_type_mutation_response', affected_rows: number } | null };

export type GetUserCourseByIdQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetUserCourseByIdQuery = { __typename?: 'query_root', course?: { __typename?: 'course', id: number, name: string, type: Course_Type_Enum, deliveryType: Course_Delivery_Type_Enum, level: Course_Level_Enum, course_code?: string | null, reaccreditation?: boolean | null, min_participants: number, max_participants: number, notes?: string | null, organization?: { __typename?: 'organization', id: any, name: string, members: Array<{ __typename?: 'organization_member', isAdmin?: boolean | null, profile_id: any }> } | null, trainers: Array<{ __typename?: 'course_trainer', id: any, type: Course_Trainer_Type_Enum, profile: { __typename?: 'profile', id: any, givenName: string, familyName: string, fullName?: string | null } }>, schedule: Array<{ __typename?: 'course_schedule', id: any, createdAt: any, updatedAt: any, start: any, end: any, virtualLink?: string | null, venue?: { __typename?: 'venue', id: any, createdAt: any, updatedAt: any, name: string, city: string, addressLineOne: string, addressLineTwo?: string | null, postCode: string, geoCoordinates?: any | null, googlePlacesId?: string | null } | null }>, dates: { __typename?: 'course_schedule_aggregate', aggregate?: { __typename?: 'course_schedule_aggregate_fields', start?: { __typename?: 'course_schedule_min_fields', date?: any | null } | null, end?: { __typename?: 'course_schedule_max_fields', date?: any | null } | null } | null } } | null };

export type UserCourseFragment = { __typename?: 'course', id: number, name: string, type: Course_Type_Enum, level: Course_Level_Enum, status?: Course_Status_Enum | null, course_code?: string | null, max_participants: number, trainers: Array<{ __typename?: 'course_trainer', id: any, status?: Course_Invite_Status_Enum | null, type: Course_Trainer_Type_Enum, profile: { __typename?: 'profile', id: any, fullName?: string | null } }>, schedule: Array<{ __typename?: 'course_schedule', id: any, start: any, end: any, virtualLink?: string | null, venue?: { __typename?: 'venue', id: any, name: string, city: string } | null }>, participants: Array<{ __typename?: 'course_participant', healthSafetyConsent: boolean, grade?: Grade_Enum | null, attended?: boolean | null }>, organization?: { __typename?: 'organization', id: any, name: string } | null, evaluation_answers_aggregate: { __typename?: 'course_evaluation_answers_aggregate', aggregate?: { __typename?: 'course_evaluation_answers_aggregate_fields', count: number } | null }, dates: { __typename?: 'course_schedule_aggregate', aggregate?: { __typename?: 'course_schedule_aggregate_fields', start?: { __typename?: 'course_schedule_min_fields', date?: any | null } | null, end?: { __typename?: 'course_schedule_max_fields', date?: any | null } | null } | null }, modulesAgg: { __typename?: 'course_module_aggregate', aggregate?: { __typename?: 'course_module_aggregate_fields', count: number } | null }, cancellationRequest?: { __typename?: 'course_cancellation_request', id: any } | null };

export type UserCoursesQueryVariables = Exact<{
  orderBy?: InputMaybe<Array<Course_Order_By> | Course_Order_By>;
  where?: InputMaybe<Course_Bool_Exp>;
  profileId: Scalars['uuid'];
  offset?: InputMaybe<Scalars['Int']>;
  limit?: InputMaybe<Scalars['Int']>;
  withParticipantAggregates?: InputMaybe<Scalars['Boolean']>;
}>;


export type UserCoursesQuery = { __typename?: 'query_root', courses: Array<{ __typename?: 'course', id: number, name: string, type: Course_Type_Enum, level: Course_Level_Enum, status?: Course_Status_Enum | null, course_code?: string | null, max_participants: number, participantsAgg: { __typename?: 'course_participant_aggregate', aggregate?: { __typename?: 'course_participant_aggregate_fields', count: number } | null }, waitlistAgg: { __typename?: 'waitlist_aggregate', aggregate?: { __typename?: 'waitlist_aggregate_fields', count: number } | null }, trainers: Array<{ __typename?: 'course_trainer', id: any, status?: Course_Invite_Status_Enum | null, type: Course_Trainer_Type_Enum, profile: { __typename?: 'profile', id: any, fullName?: string | null } }>, schedule: Array<{ __typename?: 'course_schedule', id: any, start: any, end: any, virtualLink?: string | null, venue?: { __typename?: 'venue', id: any, name: string, city: string } | null }>, participants: Array<{ __typename?: 'course_participant', healthSafetyConsent: boolean, grade?: Grade_Enum | null, attended?: boolean | null }>, organization?: { __typename?: 'organization', id: any, name: string } | null, evaluation_answers_aggregate: { __typename?: 'course_evaluation_answers_aggregate', aggregate?: { __typename?: 'course_evaluation_answers_aggregate_fields', count: number } | null }, dates: { __typename?: 'course_schedule_aggregate', aggregate?: { __typename?: 'course_schedule_aggregate_fields', start?: { __typename?: 'course_schedule_min_fields', date?: any | null } | null, end?: { __typename?: 'course_schedule_max_fields', date?: any | null } | null } | null }, modulesAgg: { __typename?: 'course_module_aggregate', aggregate?: { __typename?: 'course_module_aggregate_fields', count: number } | null }, cancellationRequest?: { __typename?: 'course_cancellation_request', id: any } | null }>, course_aggregate: { __typename?: 'course_aggregate', aggregate?: { __typename?: 'course_aggregate_fields', count: number } | null } };

export type ResendPasswordMutationVariables = Exact<{
  email: Scalars['String'];
}>;


export type ResendPasswordMutation = { __typename?: 'mutation_root', resendPassword: boolean };

export type SaveHealthSafetyConsentMutationVariables = Exact<{
  courseId: Scalars['Int'];
  profileId: Scalars['uuid'];
}>;


export type SaveHealthSafetyConsentMutation = { __typename?: 'mutation_root', update_course_participant?: { __typename?: 'course_participant_mutation_response', returning: Array<{ __typename?: 'course_participant', id: any }> } | null };

export type GetRolesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetRolesQuery = { __typename?: 'query_root', role: Array<{ __typename?: 'role', id: any, name: string }> };

export type GetProfileByIdQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type GetProfileByIdQuery = { __typename?: 'query_root', profile?: { __typename?: 'profile', id: any, givenName: string, familyName: string, fullName?: string | null, avatar?: string | null, title?: string | null, tags?: any | null, addresses: any, attributes: any, contactDetails: any, dietaryRestrictions?: string | null, disabilities?: string | null, preferences: any, createdAt: any, updatedAt: any, email?: string | null, phone?: string | null, dob?: any | null, jobTitle?: string | null, dbs?: string | null, lastActivity: any, adminRights: { __typename?: 'organization_member_aggregate', aggregate?: { __typename?: 'organization_member_aggregate_fields', count: number } | null }, organizations: Array<{ __typename?: 'organization_member', id: any, isAdmin?: boolean | null, position?: string | null, organization: { __typename?: 'organization', id: any, name: string, tags?: any | null, contactDetails: any, attributes: any, address: any, preferences: any, createdAt: any, updatedAt: any, xeroContactId?: string | null, sector?: string | null, trustName?: string | null, trustType?: Trust_Type_Enum | null, geoCoordinates?: any | null } }>, roles: Array<{ __typename?: 'profile_role', role: { __typename?: 'role', id: any, name: string } }>, trainer_role_types: Array<{ __typename?: 'profile_trainer_role_type', trainer_role_type: { __typename?: 'trainer_role_type', id: any, name: string } }> } | null };

export type FindVenuesQueryVariables = Exact<{
  query: Scalars['String'];
}>;


export type FindVenuesQuery = { __typename?: 'query_root', venues: Array<{ __typename?: 'venue', id: any, createdAt: any, updatedAt: any, name: string, city: string, addressLineOne: string, addressLineTwo?: string | null, postCode: string, geoCoordinates?: any | null, googlePlacesId?: string | null }> };

export type InsertVenueMutationVariables = Exact<{
  venue: Venue_Insert_Input;
}>;


export type InsertVenueMutation = { __typename?: 'mutation_root', venue?: { __typename?: 'venue', id: any, createdAt: any, updatedAt: any, name: string, city: string, addressLineOne: string, addressLineTwo?: string | null, postCode: string, geoCoordinates?: any | null, googlePlacesId?: string | null } | null };

export type GetXeroInvoicesForOrdersQueryVariables = Exact<{
  invoiceNumbers: Array<Scalars['String']> | Scalars['String'];
}>;


export type GetXeroInvoicesForOrdersQuery = { __typename?: 'query_root', invoices: Array<{ __typename?: 'XeroInvoice', date: string, total: number, status: XeroInvoiceStatus, dueDate?: string | null, subTotal?: number | null, totalTax?: number | null, invoiceID: string, amountDue?: string | null, reference?: string | null, amountPaid?: string | null, currencyCode: Currency, invoiceNumber?: string | null, fullyPaidOnDate?: string | null, contact: { __typename?: 'XeroContact', name: string, firstName?: string | null, lastName?: string | null, emailAddress?: string | null, phones?: Array<{ __typename?: 'XeroPhone', phoneCountryCode?: string | null, phoneAreaCode?: string | null, phoneNumber?: string | null, phoneType: XeroPhoneType } | null> | null, addresses?: Array<{ __typename?: 'XeroAddress', addressType?: XeroAddressType | null, addressLine1?: string | null, addressLine2?: string | null, city?: string | null, region?: string | null, postalCode?: string | null, country?: string | null } | null> | null }, lineItems: Array<{ __typename?: 'XeroLineItem', description?: string | null, quantity: number, unitAmount: number, itemCode: string, accountCode?: string | null, taxType: string, taxAmount: number, lineAmount: number, item?: { __typename?: 'XeroItem', itemID: string, code: string } | null, tracking?: Array<{ __typename?: 'XeroTrackingCategory', name: string, option: string }> | null } | null> } | null> };

export type GetXeroInvoicesStatusQueryVariables = Exact<{
  input: XeroInvoicesStatusInput;
}>;


export type GetXeroInvoicesStatusQuery = { __typename?: 'query_root', xeroInvoicesStatus?: { __typename?: 'XeroInvoicesStatusOutput', invoices: Array<{ __typename?: 'XeroInvoiceStatusKV', invoiceNumber: string, status: XeroInvoiceStatus } | null> } | null };

export type SearchXeroContactsQueryVariables = Exact<{
  input: XeroContactSearchInput;
}>;


export type SearchXeroContactsQuery = { __typename?: 'query_root', xero?: { __typename?: 'XeroContactSearchOutput', contacts: Array<{ __typename?: 'XeroContact', name: string, contactID: string }> } | null };
